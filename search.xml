<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AI笔记（5）：神经网络应用</title>
      <link href="/2023/08/03/5.%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/"/>
      <url>/2023/08/03/5.%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="1-数据划分：训练-验证-测试集"><a href="#1-数据划分：训练-验证-测试集" class="headerlink" title="1.数据划分：训练 &#x2F; 验证 &#x2F; 测试集"></a>1.数据划分：训练 &#x2F; 验证 &#x2F; 测试集</h2><h3 id="1-1-深度学习实践迭代优化"><a href="#1-1-深度学习实践迭代优化" class="headerlink" title="1.1 深度学习实践迭代优化"></a>1.1 深度学习实践迭代优化</h3><p>实际应用深度学习是一个迭代过程。</p><p>在构建一个神经网络的时候，我们需要设置许多超参数，例如<strong>神经网络的层数</strong> (#Layers) 、每个<strong>隐藏层包含的神经元个数</strong> (#Hidden Units) 、<strong>学习速率</strong> (Learning Rates) 、<strong>激活函数</strong> (Activation Functions) 的选择等。实际上很难在第一次设置的时候就选择到这些最佳的超参数，而是需要通过不断地迭代更新来获得。</p><p>循环迭代过程是如下这样的：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6435362d866ce37b006387d0ef48634d.png" alt="深度学习优化迭代过程"></p><ol start="11"><li>产生想法<strong>Idea</strong>，选择初始的参数值，构建神经网络模型结构；</li><li>通过代码<strong>Code</strong>实现上述想法；</li><li>通过实验<strong>Experiment</strong>验证这些超参数对应的神经网络的表现性能。</li><li>根据验证结果，我们对超参数进行适当的调整优化，再进行下一次的<strong>Idea-&gt;Code-&gt;Experiment</strong>循环。通过很多次的循环，不断调整超参数，选定最佳的参数值，从而让神经网络性能最优化。</li></ol><p>上述迭代过程中，决定整个训练过程快慢的关键在于<strong>单次循环所花费的时间</strong>，单次循环越快，训练过程越快。而设置合适的<strong>训练集</strong> (Training sets) 、<strong>验证集</strong> (Development sets) 、<strong>测试集</strong> (Test sets) 大小，能有效提高训练效率。</p><p>上述数据部分来源于建立模型的过程中，我们对于总体数据的划分：</p><ul><li><strong>训练集 (Training Sets)</strong> ：用训练集对算法或模型进行训练过程。</li><li><strong>验证集 ( (Development Sets)</strong> ：利用验证集 (又称为简单交叉验证集，hold-out cross validation set) 进行<strong>交叉验证，选择出最好的模型</strong>。</li><li><strong>测试集 (Test Sets)</strong> ：最后利用测试集对模型进行测试，获取模型运行的无偏估计 (对学习方法进行评估) 。</li></ul><h3 id="1-2-前大数据时代划分方式"><a href="#1-2-前大数据时代划分方式" class="headerlink" title="1.2 前大数据时代划分方式"></a>1.2 前大数据时代划分方式</h3><p>在小数据量的时代，如100、1000、10000的数据量大小，可以将数据集按照以下比例进行划分：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/dc724ddd049bd10b37276dd8abf8db14.png" alt="深度学习中的数据切分"></p><ul><li><strong>无验证集</strong>的情况：70%、30%</li><li><strong>有验证集</strong>的情况：60%、20%、20%</li></ul><h3 id="1-3-大数据时代划分方式"><a href="#1-3-大数据时代划分方式" class="headerlink" title="1.3 大数据时代划分方式"></a>1.3 大数据时代划分方式</h3><p>而在如今的大数据时代，对于一个问题，我们拥有的数据集的规模可能是百万级别的，所以验证集和测试集所占的比重会趋向于变得更小。</p><h4 id="关于验证集"><a href="#关于验证集" class="headerlink" title="关于验证集"></a>关于验证集</h4><p>验证集的目的是为了验证不同的算法哪种更加有效，所以验证集只要足够大到能够验证大约2-10种算法哪种更好，而不需要使用20%的数据作为验证集。如百万数据中抽取1万的数据作为验证集就可以了。</p><h4 id="关于测试集"><a href="#关于测试集" class="headerlink" title="关于测试集"></a>关于测试集</h4><p>测试集的主要目的是评估模型的效果，如在单个分类器中，往往在百万级别的数据中，我们选择其中10000条数据也足以评估单个模型的效果。</p><p>我们针对不同量级的大数据场景，可以采用如下的训练集 (Training sets) 、验证集 (Development sets) 、测试集 (Test sets) 数据<strong>划分方式</strong>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b1863ea32bf92e46c37bf2bac7238987.png" alt="深度学习中的数据切分"></p><ul><li><strong>100万数据量</strong>：98%、1%、1%</li><li><strong>超百万数据量</strong>：99.5%、0.25%、0.25% (或者99.5%、0.4%、0.1%)</li></ul><h3 id="1-4-数据划分建议"><a href="#1-4-数据划分建议" class="headerlink" title="1.4 数据划分建议"></a>1.4 数据划分建议</h3><p>建议验证集要和训练集来自于同一个分布 (数据来源一致) ，可以使得机器学习算法变得更快并获得更好的效果。</p><p><strong>假设你开发一个手机app，可以让用户上传图片，然后app识别出猫的图片</strong>。在app识别算法中，你的<strong>训练样本</strong>可能来自<strong>网络</strong>下载，而你的<strong>验证和测试样本</strong>可能来自不同用户的上传。从网络下载的图片一般像素较高而且比较正规，而用户上传的图片往往像素不稳定，且图片质量不一。这种情况下验证集和测试集的作用就受影响了。</p><p>如果不需要用<strong>无偏估计</strong>来评估模型的性能，则可以不需要测试集。</p><p><strong>Test sets测试集的目标主要是进行无偏估计</strong>。我们可以通过Train sets训练不同的算法模型，然后分别在Dev sets上进行验证，根据结果选择最好的算法模型。这样也是可以的，不需要再进行无偏估计了。如果只有Train sets和Dev sets，通常也有人把这里的Dev sets称为Test sets，我们要注意加以区别。</p><h2 id="2-模型估计：偏差-方差"><a href="#2-模型估计：偏差-方差" class="headerlink" title="2.模型估计：偏差 &#x2F; 方差"></a>2.模型估计：偏差 &#x2F; 方差</h2><h3 id="2-1-模型状态与评估"><a href="#2-1-模型状态与评估" class="headerlink" title="2.1 模型状态与评估"></a>2.1 模型状态与评估</h3><p><strong>偏差 (Bias)</strong> 和<strong>方差 (Variance)</strong> 是机器学习领域非常重要的两个概念和需要解决的问题。在传统的机器学习算法中，Bias和Variance是对立的，分别对应着欠拟合和过拟合，我们常常需要在Bias和Variance之间进行权衡。而在深度学习中，我们可以同时减小Bias和Variance，构建最佳神经网络模型。</p><p>我们先来梳理一下上面提到的概念：</p><ul><li><strong>偏差 (Bias)</strong> ：度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法本身的拟合能力。</li><li><strong>方差 (Variance)</strong> ：度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响。</li><li><strong>噪声 (noise)</strong> ：表达了在当前任务上任何学习算法所能够达到的期望泛化误差的下界，即刻画了<strong>学习问题本身的难度</strong>。</li></ul><p>如图是二维平面上二分类问题对应的几种模型状态 (High Bias，Just Right，High Variance) 示例图。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7d1e174b52cbf7eb44f54cc2e6a49680.png" alt="模型估计：偏差/方差"></p><p>其中，<strong>High Bias对应着欠拟合</strong>，而<strong>High Variance对应着过拟合</strong>。在欠拟合 (underfitting) 的情况下，出现高偏差 (High Bias) 的情况，即不能很好地对数据进行分类。</p><p>这个例子中输入特征是二维的，High Bias和High Variance可以直接从图中分类线看出来。而<strong>对于输入特征是高维的情况，如何来判断是否出现了High Bias或者High Variance呢</strong>？</p><p><img src="https://img-blog.csdnimg.cn/img_convert/def768cf9fce584e155bd435de77dc80.png" alt="模型估计：偏差/方差"></p><p>这就要特别借助于上一节我们提到几个数据集的评估来完成了</p><p><img src="https://img-blog.csdnimg.cn/img_convert/40b427cd93898e7e9c1e2f4c6927cbf2.png" alt="模型估计：偏差/方差"></p><p>一般来说，训练集错误率体现了是否出现Bias (偏差) ，验证集 (和训练集差异) 错误率体现了是否出现Variance (方差) 。当训练出一个模型以后：</p><ul><li>训练集的错误率较小，而验证集的错误率却较大，说明模型存在较大方差 (Variance) ，可能出现了过拟合。</li><li>训练集和验证集的错误率都较大，且两者相当，说明模型存在较大偏差 (Bias) ，可能出现了欠拟合。</li><li>训练集错误率较大，且验证集的错误率远较训练集大，说明方差和偏差都较大，模型很差。</li><li>训练集和验证集的错误率都较小，且两者的相差也较小，说明方差和偏差都较小，这个模型效果比较好。</li></ul><p><strong>神经网络模型甚至可能出现High Bias and High Variance的糟糕状态</strong>，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a42fc5903db6a420e7a63ba4a8559cfc.png" alt="模型估计：偏差/方差"></p><h3 id="2-2-应对方法"><a href="#2-2-应对方法" class="headerlink" title="2.2 应对方法"></a>2.2 应对方法</h3><p>模型可能处于上述提到的不同状态中，在我们对模型状态评估完毕之后，针对不同的状态，优化方式如下：</p><ul><li>模型存在<strong>高偏差</strong>：扩大网络规模，如添加隐藏层或隐藏单元数目；寻找合适的网络架构，使用更大的NN结构；花费更长时间训练。</li><li>模型存在<strong>高方差</strong>：获取更多的数据；正则化 (Regularization) ；寻找更合适的网络结构。</li><li>不断尝试，直到找到低偏差、低方差的框架。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/c39aa29a54a97f93303b872e5b58f4e4.png" alt="模型估计：偏差/方差"></p><p>在深度学习的早期阶段，没有太多方法能做到只减少偏差或方差而不影响到另外一方。而在大数据时代，深度学习对监督式学习大有裨益，使得我们不用像以前一样太过关注如何平衡偏差和方差的权衡问题，通过以上方法可以在不增加某一方的前提下减少另一方的值。</p><h2 id="3-正则化-Regularization"><a href="#3-正则化-Regularization" class="headerlink" title="3.正则化 (Regularization)"></a>3.正则化 (Regularization)</h2><h3 id="3-1-正则化"><a href="#3-1-正则化" class="headerlink" title="3.1 正则化"></a>3.1 正则化</h3><p>如果模型出现了过拟合 (High Variance) 状态，可以通过正则化Regularization来缓解解决。虽然扩大训练样本数量也是减小High Variance的一种方法，但是通常获得更多训练样本的成本太高，比较困难。所以，更可行有效的办法就是使用正则。</p><h3 id="3-2-Logistic-回归中的正则化"><a href="#3-2-Logistic-回归中的正则化" class="headerlink" title="3.2 Logistic 回归中的正则化"></a>3.2 Logistic 回归中的正则化</h3><p>我们先回顾一下之前介绍过的逻辑回归模型，我们在Cost Function里添加了<strong>L2 Regularization</strong> ，表达式如下：</p><p><img src="https://www.zhihu.com/equation?tex=J(w,b)=%5Cfrac1m%20%5Csum_%7Bi=1%7D%5Em%20L(%5Chat%20y%5E%7B(i)%7D,y%5E%7B(i)%7D)+%5Cfrac%7B%5Clambda%7D%7B2m%7D%7C%7Cw%7C%7C_2%5E2" alt="公式"></p><blockquote><p><strong>为什么只对 w 进行正则化而不对b 进行正则化呢</strong>？</p><p>其实也可以对 <strong>b</strong>进行正则化。但是一般w的维度很大，而 <strong>b</strong>只是一个常数。相比较来说，参数很大程度上由 <strong>w</strong> 决定，改变 <strong>b</strong> 值对整体模型影响较小。所以，一般为了简便，就忽略对 <strong>b</strong> 的正则化了。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/3b4e96c266754c35c5939a43d17187c2.png" alt="正则化"></p><p>除了L2正则化之外，我们在逻辑回归中也可以<strong>添加L1正则化</strong>。表达式如下：</p><p><img src="https://www.zhihu.com/equation?tex=J(w,b)=%5Cfrac1m%5Csum_%7Bi=1%7D%5EmL(%5Chat%20y%5E%7B(i)%7D,y%5E%7B(i)%7D)+%5Cfrac%7B%5Clambda%7D%7B2m%7D%7C%7Cw%7C%7C_1" alt="公式"></p><p>与L2正则化相比，<strong>L1正则化更容易得到稀疏的w 解</strong>，即最后训练得到的权重 w 中有很多为零值。L1正则化优点是节约存储空间 (因为大部分 w 为0) 。但实际上L1正则化在解决过拟合问题上并不优于L2正则化，且L1的在微分求导方面比较复杂。所以一般更常用的还是L2正则化。</p><p>L1、L2正则化中的 <img src="https://www.zhihu.com/equation?tex=%5Clambda" alt="公式"> 就是正则化参数 (超参数的一种) 。可以设置 <img src="https://www.zhihu.com/equation?tex=%5Clambda" alt="公式"> 为不同的值，在验证集Dev set中进行验证，选择最佳的 <img src="https://www.zhihu.com/equation?tex=%5Clambda" alt="公式">。</p><h3 id="3-3-神经网络中的正则化"><a href="#3-3-神经网络中的正则化" class="headerlink" title="3.3 神经网络中的正则化"></a>3.3 神经网络中的正则化</h3><p>在深度学习模型中，<strong>L2正则化的表达式</strong>如图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/742b968fe0a1fe8725cc5328c8801dbf.png" alt="神经网络的正则化"></p><p>通常，我们把 <img src="https://www.zhihu.com/equation?tex=%7C%7Cw%5E%7B%5Bl%5D%7D%7C%7C%5E2" alt="公式"> 称为<strong>弗罗贝尼乌斯范数</strong> (Frobenius Norm) ，记为 <img src="https://www.zhihu.com/equation?tex=%7C%7Cw%5E%7B%5Bl%5D%7D%7C%7C_F%5E2" alt="公式">。</p><p>由于在Cost Function中加入了正则化项，梯度下降算法中的 <img src="https://www.zhihu.com/equation?tex=dw%5E%7B%5Bl%5D%7D" alt="公式"> 计算表达式需要做如下修改：</p><p><img src="https://www.zhihu.com/equation?tex=dw%5E%7B%5Bl%5D%7D=dw%5E%7B%5Bl%5D%7D_%7Bbefore%7D+%5Cfrac%7B%5Clambda%7D%7Bm%7Dw%5E%7B%5Bl%5D%7D" alt="公式"> <img src="https://www.zhihu.com/equation?tex=w%5E%7B%5Bl%5D%7D:=w%5E%7B%5Bl%5D%7D-%5Calpha%5Ccdot%20dw%5E%7B%5Bl%5D%7D" alt="公式"></p><p><strong>大家有时候也会听到L2正则化被称做weight decay</strong>。这是因为，由于加上了正则项，<img src="https://www.zhihu.com/equation?tex=dw%5E%7B%5Bl%5D%7D" alt="公式"> 有个增量，在更新 <img src="https://www.zhihu.com/equation?tex=w%5E%7B%5Bl%5D%7D" alt="公式"> 的时候，会多减去这个增量，使得 <img src="https://www.zhihu.com/equation?tex=w%5E%7B%5Bl%5D%7D" alt="公式"> 比没有正则项的值要小一些。不断迭代更新，不断地减小。</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D%20w%5E%7B%5Bl%5D%7D%20:&%20=%20w%5E%7B%5Bl%5D%7D-%5Calpha%5Ccdot%20dw%5E%7B%5Bl%5D%7D%5C%5C%20&%20=%20w%5E%7B%5Bl%5D%7D-%5Calpha%5Ccdot(dw%5E%7B%5Bl%5D%7D_%7Bbefore%7D+%5Cfrac%7B%5Clambda%7D%7Bm%7Dw%5E%7B%5Bl%5D%7D)%5C%5C%20&%20=%20(1-%5Calpha%5Cfrac%7B%5Clambda%7D%7Bm%7D)w%5E%7B%5Bl%5D%7D-%5Calpha%5Ccdot%20dw%5E%7B%5Bl%5D%7D_%7Bbefore%7D%20%5Cend%7Baligned%7D" alt="公式"></p><p>其中，<img src="https://www.zhihu.com/equation?tex=(1-%5Calpha%5Cfrac%7B%5Clambda%7D%7Bm%7D)%3C1" alt="公式"> 。</p><h3 id="3-4-正则化可以减小过拟合的原因"><a href="#3-4-正则化可以减小过拟合的原因" class="headerlink" title="3.4 正则化可以减小过拟合的原因"></a>3.4 正则化可以减小过拟合的原因</h3><h4 id="1-直观解释"><a href="#1-直观解释" class="headerlink" title="(1) 直观解释"></a>(1) 直观解释</h4><p>我们回到上面模型状态的那张图，从左到右，分别表示了<strong>欠拟合</strong>、<strong>刚好拟合</strong>、<strong>过拟合</strong>三种情况。选择图中的复杂神经网络模型，那么不添加正则化的情况下，我们可能得到图中的过拟合分类边界。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f2f0b0eb9093743b8831799bb8b71314.png" alt="神经网络的正则化"></p><p>如果使用L2正则化，当 <img src="https://www.zhihu.com/equation?tex=%5Clambda" alt="公式"> 很大时，<img src="https://www.zhihu.com/equation?tex=w%5E%7B%5Bl%5D%7D%5Capprox0" alt="公式"> 即 <img src="https://www.zhihu.com/equation?tex=w%5E%7B%5Bl%5D%7D" alt="公式"> 近似为零，意味着该神经网络模型中的某些神经元实际的作用很小，可以忽略。从效果上来看，其实是将某些神经元给忽略掉了。这样原本过于复杂的神经网络模型就变得不那么复杂了，而变得非常简单化了。</p><p>如图所示，整个简化的神经网络模型变成了一个逻辑回归模型。<strong>问题就从High Variance变成了High Bias了</strong>。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e4258e08d75c71d2fec898e9acbcc76c.png" alt="神经网络的正则化"></p><p>因此，总结一下，直观的一种理解是：正则化因子设置的足够大的情况下，为了使成本函数最小化，权重矩阵 <img src="https://www.zhihu.com/equation?tex=W" alt="公式"> 就会被设置为接近于0的值，直观上相当于消除了很多神经元的影响，那么大的神经网络就会变成一个较小的网络。当然，实际上隐藏层的神经元依然存在，但是其影响减弱了，过拟合可能性大大减小。</p><h4 id="2-数学解释"><a href="#2-数学解释" class="headerlink" title="(2) 数学解释"></a>(2) 数学解释</h4><p>假设神经元中使用的激活函数为 <img src="https://www.zhihu.com/equation?tex=g(z)%20=%20tanh(z)" alt="公式"> (sigmoid同理) 。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0a6a8c049dcb3ac6d9272879062f7cd6.png" alt="神经网络的正则化"></p><p>在加入正则化项后，当 <img src="https://www.zhihu.com/equation?tex=%5Clambda" alt="公式"> 增大，导致 <img src="https://www.zhihu.com/equation?tex=W%5E%7B%5Bl%5D%7D" alt="公式"> 减小，<img src="https://www.zhihu.com/equation?tex=Z%5E%7B%5Bl%5D%7D%20=%20W%5E%7B%5Bl%5D%7Da%5E%7B%5Bl-1%5D%7D%20+%20b%5E%7B%5Bl%5D%7D" alt="公式"> 便会减小。通过上图我们会发现，在 <img src="https://www.zhihu.com/equation?tex=z" alt="公式"> 较小 (接近于0) 的区域里，<img src="https://www.zhihu.com/equation?tex=tanh(z)" alt="公式"> 函数近似线性，所以每层的函数就近似线性函数，整个网络就成为一个简单的近似线性的网络，因此不会发生过拟合。</p><h4 id="3-其他解释"><a href="#3-其他解释" class="headerlink" title="(3) 其他解释"></a>(3) 其他解释</h4><p>在权值 <img src="https://www.zhihu.com/equation?tex=w%5E%7B%5BL%5D%7D" alt="公式"> 变小之下，输入样本 <img src="https://www.zhihu.com/equation?tex=X" alt="公式"> 随机的变化不会对神经网络模造成过大的影响，神经网络受局部噪音的影响的可能性变小。这就是正则化能够降低模型方差的原因。</p><h2 id="4-Dropout-正则化"><a href="#4-Dropout-正则化" class="headerlink" title="4.Dropout 正则化"></a>4.Dropout 正则化</h2><p>在神经网络中，另外一种很有效的正则化方式叫做Dropout (随机失活) ，它是指在神经网络的隐藏层为每个神经元结点设置一个随机关闭的概率，保留下来的神经元形成一个结点较少、规模较小的网络用于训练。网络模型得到简化，从而避免发生过拟合。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/4b98f5e6e6a0f3dd94bd6514c9f7696c.png" alt="Dropout正则化"></p><h3 id="4-1-反向随机失活-Inverted-Dropout"><a href="#4-1-反向随机失活-Inverted-Dropout" class="headerlink" title="4.1 反向随机失活 (Inverted Dropout)"></a>4.1 反向随机失活 (Inverted Dropout)</h3><p>Dropout有不同的实现方法，一种常用的方法是<strong>Inverted Dropout</strong>。假设对于第l层神经元，设定保留神经元比例概率keep_prob&#x3D;0.8，即该层有20%的神经元停止工作。<strong>dl</strong> 为Dropout向量，设置 <strong>dl</strong>为随机vector，其中80%的元素为1，20%的元素为0。</p><p><strong>Dropout vector的生成python代码如下所示</strong>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d1e0b6f58a2f6c17e72b04cf076d7d2b.png" alt="Dropout正则化"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keep_prob = 0.8  # 设置神经元保留概率dl = np.random.rand (al.shape[0], al.shape[1]) &lt; keep_probal = np.multiply (al, dl)al /= keep_prob</span><br></pre></td></tr></table></figure><ul><li>最后一步<code>al /= keep_prob</code>是因为 <img src="https://www.zhihu.com/equation?tex=a%5E%7B%5Bl%5D%7D" alt="公式"> 中的一部分元素失活 (相当于被归零) ，为了在下一层计算时不影响 <img src="https://www.zhihu.com/equation?tex=Z%5E%7B%5Bl+1%5D%7D%20=%20W%5E%7B%5Bl+1%5D%7Da%5E%7B%5Bl%5D%7D%20+%20b%5E%7B%5Bl+1%5D%7D" alt="公式"> 的期望值，因此除以一个<code>keep_prob</code>。</li></ul><p>Inverted Dropout 的另外一个好处就是在对该 Dropout 后的神经网络进行测试时能够减少 scaling 问题。因为在训练时，使用 scale up 保证 al 的期望值没有大的变化，测试时就不需要再对样本数据进行类似的尺度伸缩操作了。</p><ul><li>对于 <img src="https://www.zhihu.com/equation?tex=m" alt="公式"> 个样本，单次迭代训练时，随机删除掉隐藏层一定数量的神经元；</li><li>然后，在删除后的剩下的神经元上正向和反向更新权重 <img src="https://www.zhihu.com/equation?tex=w" alt="公式"> 和常数项 <img src="https://www.zhihu.com/equation?tex=b" alt="公式"> ；</li><li>接着，下一次迭代中，再恢复之前删除的神经元，重新随机删除一定数量的神经元，进行正向和反向更新 <img src="https://www.zhihu.com/equation?tex=w" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=b" alt="公式"> 。</li><li>不断重复上述过程，直至迭代训练完成。</li></ul><p><strong>注意</strong>：使用Dropout训练结束后，在测试和实际应用模型时，不需要进行Dropout和随机删减神经元，所有的神经元都在工作。</p><h3 id="4-2-理解-Dropout"><a href="#4-2-理解-Dropout" class="headerlink" title="4.2 理解 Dropout"></a>4.2 理解 Dropout</h3><h4 id="4-2-1-Dropout理解视角1"><a href="#4-2-1-Dropout理解视角1" class="headerlink" title="4.2.1 Dropout理解视角1"></a>4.2.1 Dropout理解视角1</h4><p>Dropout通过每次迭代训练时，随机选择不同的神经元，相当于每次都在不同的神经网络上进行训练，类似机器学习中Bagging的方法  ，能够防止过拟合。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6158c68b161eeaac6798855e68661dc2.png" alt="Dropout正则化"></p><h4 id="4-2-2-Dropout理解视角2"><a href="#4-2-2-Dropout理解视角2" class="headerlink" title="4.2.2 Dropout理解视角2"></a>4.2.2 Dropout理解视角2</h4><p>第2个理解的视角是Dropout会减小权重 <img src="https://www.zhihu.com/equation?tex=w" alt="公式"> 的值。</p><p>对于某个神经元来说，某次训练时，它的某些输入在Dropout的作用被过滤了。而在下一次训练时，又有不同的某些输入被过滤。经过多次训练后，某些输入被过滤，某些输入被保留。这样，神经元不会再特别依赖于任何一个输入特征。也就是说，对应的权重 <img src="https://www.zhihu.com/equation?tex=w" alt="公式"> 不会很大。<strong>这从效果上来说，与L2 正则化是类似的，都是对权重 <img src="https://www.zhihu.com/equation?tex=w" alt="公式"> 进行「惩罚」，减小了 <img src="https://www.zhihu.com/equation?tex=w" alt="公式"> 的值</strong>。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/80521020b9fc659dc904f57b8bedf3b2.png" alt="Dropout正则化"></p><p>因此，通过传播过程，Dropout将产生和 <img src="https://www.zhihu.com/equation?tex=L2" alt="公式"> 正则化相同的收缩权重的效果。</p><h3 id="4-3-Dropout取值"><a href="#4-3-Dropout取值" class="headerlink" title="4.3 Dropout取值"></a>4.3 Dropout取值</h3><p>一般来说，神经元多的隐藏层，<code>keep_prob</code>可以设置得小一些，例如0.5；神经元越少的隐藏层，<code>keep_out</code>可以设置的大一些，例如0.8，设置是1。</p><p>实际应用中，不建议对输入层进行Dropout，如果输入层维度很大，例如图片，那么可以设置Dropout，但<code>keep_prob</code>应设置的大一些，例如0.8，0.9。</p><p>总体来说，就是越容易出现overfitting的隐藏层，其<code>keep_prob</code>就设置的相对小一些。没有准确固定的做法，通常可以根据validation进行选择。</p><p><strong>注意</strong>：Dropout的一大缺点是成本函数无法被明确定义。因为每次迭代都会随机消除一些神经元结点的影响，因此无法确保成本函数单调递减。因此，使用Dropout时，先将<code>keep_prob</code>全部设置为1.0后运行代码，确保 <img src="https://www.zhihu.com/equation?tex=J(w,%20b)" alt="公式"> 函数单调递减，再打开Dropout。</p><h2 id="5-其他正则化方法"><a href="#5-其他正则化方法" class="headerlink" title="5.其他正则化方法"></a>5.其他正则化方法</h2><h3 id="5-1-数据扩增-Data-Augmentation"><a href="#5-1-数据扩增-Data-Augmentation" class="headerlink" title="5.1 数据扩增 (Data Augmentation)"></a>5.1 数据扩增 (Data Augmentation)</h3><p>数据扩增 (Data Augmentation) 是深度学习中常见和有效的技巧，特别的，在计算机视觉领域，它指的<strong>通过图片的一些变换 (翻转，局部放大后切割等) ，得到更多的训练集和验证集</strong>。如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e4f6c33b494415bf800bb9366b747964.png" alt="其他正则化方法"></p><h3 id="5-2-早停止法-Early-Stopping"><a href="#5-2-早停止法-Early-Stopping" class="headerlink" title="5.2 早停止法 (Early Stopping)"></a>5.2 早停止法 (Early Stopping)</h3><p>因为深度学习的训练过程是一个不断迭代优化训练集cost function的过程，但是迭代次数过多会导致模型过度拟合训练集而对其他数据泛化能力变弱。一个处理方法是使用早停止法 (Early Stopping) 。</p><p>在早停止法 (Early Stopping) 中，我们会把训练集和验证集进行梯度下降时的成本变化曲线画在同一个坐标轴内。当训练集误差降低但验证集误差升高，两者开始发生较大偏差时及时停止迭代，并返回具有最小验证集误差的连接权和阈值，以避免过拟合。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f798556a5c3a56c20c16f976a4f58ff9.png" alt="其他正则化方法"></p><p><strong>Early Stopping也有其自身缺点</strong>。</p><p>回顾我们应用机器学习训练模型有两个目标：① 优化Cost Function，尽量减小 <img src="https://www.zhihu.com/equation?tex=J" alt="公式"> ；② 防止过拟合，希望在新数据上有好的泛化能力。这两个目标彼此对立的，即减小 <img src="https://www.zhihu.com/equation?tex=J" alt="公式"> 的同时可能会造成过拟合，反之亦然。</p><p>前面提到过，在深度学习中，神经网络可以同时减小Bias和Variance，构建最佳模型。但是，Early Stopping的做法通过减少得带训练次数来防止过拟合，这样 <img src="https://www.zhihu.com/equation?tex=J" alt="公式"> 就不会足够小。也就是说，<strong>Early Stopping将上述两个目标融合在一起，同时优化，但可能没有「分而治之」的效果好</strong>。</p><p><strong>对比Early Stopping，L2正则化可以实现「分而治之」的效果：迭代训练足够多，减小 <img src="https://www.zhihu.com/equation?tex=J" alt="公式">，而且也能有效防止过拟合。而L2正则化的缺点之一是最优的正则化参数 <img src="https://www.zhihu.com/equation?tex=%5Clambda" alt="公式"> 的选择比较复杂，这点上Early Stopping比较简单</strong>。</p><p>总体上 <img src="https://www.zhihu.com/equation?tex=L2" alt="公式"> 正则化更加常用一些。</p><h2 id="6-标准化输入"><a href="#6-标准化输入" class="headerlink" title="6.标准化输入"></a>6.标准化输入</h2><h3 id="6-1-标准化输入操作"><a href="#6-1-标准化输入操作" class="headerlink" title="6.1 标准化输入操作"></a>6.1 标准化输入操作</h3><p>在训练神经网络时，对输入标准化可以提高训练的速度。标准化就是对训练数据集进行归一化的操作，即将原始数据减去其均值 <img src="https://www.zhihu.com/equation?tex=%5Cmu" alt="公式"> 后，再除以其方差 <img src="https://www.zhihu.com/equation?tex=%5Csigma%5E2" alt="公式"> ：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cmu=%5Cfrac1m%5Csum_%7Bi=1%7D%5EmX%5E%7B(i)%7D" alt="公式"></p><p><img src="https://www.zhihu.com/equation?tex=%5Csigma%5E2=%5Cfrac1m%5Csum_%7Bi=1%7D%5Em(X%5E%7B(i)%7D)%5E2" alt="公式"></p><p><img src="https://www.zhihu.com/equation?tex=X:=%5Cfrac%7BX-%5Cmu%7D%7B%5Csigma%5E2%7D" alt="公式"></p><p>下图展示二维数据的归一化过程及其分布变化：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/afe49db5fe17fe884ddd13652a0f0a94.png" alt="标准化输入"></p><p><strong>注意</strong>：实际建模应用时，对于测试集，应该使用训练集同样的 <img src="https://www.zhihu.com/equation?tex=%5Cmu" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=%5Csigma%5E2" alt="公式"> 对其进行标准化处理。这样保证了训练集和测试集的标准化操作一致。</p><h3 id="6-2-标准化输入原因"><a href="#6-2-标准化输入原因" class="headerlink" title="6.2 标准化输入原因"></a>6.2 标准化输入原因</h3><p>标准化输入可以让所有输入调整到同样的尺度scale上，方便进行梯度下降算法时能够更快更准确地找到全局最优解。</p><p>以二维数据为例，如果输入数据有 <img src="https://www.zhihu.com/equation?tex=x_1" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=x_2" alt="公式"> 两个维度，<img src="https://www.zhihu.com/equation?tex=x_1" alt="公式"> 的范围是 <img src="https://www.zhihu.com/equation?tex=%5B1,1000%5D" alt="公式">，<img src="https://www.zhihu.com/equation?tex=x_2" alt="公式"> 的范围是 <img src="https://www.zhihu.com/equation?tex=%5B0,1%5D" alt="公式">。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/86829f849204d8c2c64eeb629e95439a.png" alt="标准化输入"></p><h4 id="1-未做标准化的情形"><a href="#1-未做标准化的情形" class="headerlink" title="(1) 未做标准化的情形"></a>(1) 未做标准化的情形</h4><p>不进行标准化处理的情况下，<img src="https://www.zhihu.com/equation?tex=x_1" alt="公式"> 与 <img src="https://www.zhihu.com/equation?tex=x_2" alt="公式"> 之间分布极不平衡，训练得到的 <img src="https://www.zhihu.com/equation?tex=w_1" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=w_2" alt="公式"> 也会在数量级上差别很大。这种情形下的Cost Function与 <img src="https://www.zhihu.com/equation?tex=w" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=b" alt="公式"> 的关系可能是一个非常细长的椭圆形碗，如图左所示。</p><p>对这种Cost Function进行梯度下降优化时，由于 <img src="https://www.zhihu.com/equation?tex=w_1" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=w_2" alt="公式"> 数值差异很大，只能选择很小的学习因子 <img src="https://www.zhihu.com/equation?tex=%5Calpha" alt="公式">，来避免 <img src="https://www.zhihu.com/equation?tex=J" alt="公式"> 发生振荡。一旦 <img src="https://www.zhihu.com/equation?tex=%5Calpha" alt="公式"> 较大，必然发生振荡，<img src="https://www.zhihu.com/equation?tex=J" alt="公式"> 不再单调下降。</p><h4 id="2-做完标准化的情形"><a href="#2-做完标准化的情形" class="headerlink" title="(2) 做完标准化的情形"></a>(2) 做完标准化的情形</h4><p>如果进行了标准化操作，<img src="https://www.zhihu.com/equation?tex=x_1" alt="公式"> 与 <img src="https://www.zhihu.com/equation?tex=x_2" alt="公式"> 分布均匀，<img src="https://www.zhihu.com/equation?tex=w_1" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=w_2" alt="公式"> 数值差别不大，得到的Cost Function与 <img src="https://www.zhihu.com/equation?tex=w" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=b" alt="公式"> 的关系是类似圆形碗，如右图所示。对其进行梯度下降优化时，<img src="https://www.zhihu.com/equation?tex=%5Calpha" alt="公式"> 可以选择相对大一些，且 <img src="https://www.zhihu.com/equation?tex=J" alt="公式"> 一般不会发生振荡，保证了 <img src="https://www.zhihu.com/equation?tex=J" alt="公式"> 是单调下降的。</p><p>如果输入特征之间的范围本来就比较接近，那么不进行标准化操作也是没有太大影响的。但是，标准化处理在大多数场合下还是值得做的。</p><h2 id="7-梯度消失和梯度爆炸"><a href="#7-梯度消失和梯度爆炸" class="headerlink" title="7.梯度消失和梯度爆炸"></a>7.梯度消失和梯度爆炸</h2><h3 id="7-1-梯度爆炸与梯度消失"><a href="#7-1-梯度爆炸与梯度消失" class="headerlink" title="7.1 梯度爆炸与梯度消失"></a>7.1 梯度爆炸与梯度消失</h3><p>在深度神经网络里，我们在计算损失函数梯度时，有时会出现以指数级递增或者递减的情况，它们分别对应神经网络的梯度爆炸和梯度消失问题。</p><p>举个例子来说明，假设一个多层的每层只包含两个神经元的深度神经网络模型，如下图所示：</p><p>为了简化复杂度，便于分析，我们令各层的激活函数为线性函数，且忽略各层常数项 <img src="https://www.zhihu.com/equation?tex=b" alt="公式"> 的影响，即假定 <img src="https://www.zhihu.com/equation?tex=g(z)%20=%20z" alt="公式">，<img src="https://www.zhihu.com/equation?tex=b%5E%7B%5Bl%5D%7D%20=%200" alt="公式">，对于目标输出 <img src="https://www.zhihu.com/equation?tex=%5Chat%7By%7D" alt="公式"> 有：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/19bcef759195d6b081a4ae9ffd5dc2a5.png" alt="梯度消失和梯度爆炸"></p><p>这种叠乘会带来下面2种情况：</p><ul><li>对于 <img src="https://www.zhihu.com/equation?tex=W%5E%7B%5Bl%5D%7D" alt="公式"> 的值大于1的情况，激活函数的值将以指数级递增；</li><li>对于 <img src="https://www.zhihu.com/equation?tex=W%5E%7B%5Bl%5D%7D" alt="公式"> 的值小于1的情况，激活函数的值将以指数级递减。</li></ul><p>计算梯度是一个类似的过程，根据求导链式法则，也会有叠乘情况出现，梯度函数会以指数级递增或递减，导致训练导数难度上升，梯度下降算法的步长会变得非常小，需要训练的时间将会非常长。</p><h3 id="7-2-权重初始化缓解梯度消失和爆炸"><a href="#7-2-权重初始化缓解梯度消失和爆炸" class="headerlink" title="7.2 权重初始化缓解梯度消失和爆炸"></a>7.2 权重初始化缓解梯度消失和爆炸</h3><p>那么怎么改善梯度消失和爆炸问题呢？一种方法是对权重 <img src="https://www.zhihu.com/equation?tex=w" alt="公式"> 进行一些初始化处理。</p><p>深度神经网络模型中，以单个神经元为例，其输出计算为 <img src="https://www.zhihu.com/equation?tex=%5Chat%7By%7D" alt="公式"> ：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/dd21ac81e1f28c17a943096a332cd8a7.png" alt="梯度消失和梯度爆炸"></p><p>为了让 <img src="https://www.zhihu.com/equation?tex=%5Chat%7By%7D" alt="公式"> 不会过大或者过小，思路是让 <img src="https://www.zhihu.com/equation?tex=w" alt="公式"> 与 <img src="https://www.zhihu.com/equation?tex=n" alt="公式"> 有关，且 <img src="https://www.zhihu.com/equation?tex=n" alt="公式"> 越大，<img src="https://www.zhihu.com/equation?tex=w" alt="公式"> 应该越小才好。一种方法是在初始化w时，令其方差为 <img src="https://www.zhihu.com/equation?tex=1/n" alt="公式">，这里称为<strong>Xavier initialization</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## 针对tanh激活函数的Xavier初始化WL = np.random.randn (WL.shape[0], WL.shape[1]) * np.sqrt (1/n)</span><br></pre></td></tr></table></figure><p>其中 <img src="https://www.zhihu.com/equation?tex=n" alt="公式"> 是输入的神经元个数，即 <code>WL.shape[1]</code>。</p><p>这样，激活函数的输入 <img src="https://www.zhihu.com/equation?tex=x" alt="公式"> 近似设置成均值为0，标准方差为1，神经元输出 <img src="https://www.zhihu.com/equation?tex=z" alt="公式"> 的方差就正则化到1了。虽然没有解决梯度消失和爆炸的问题，但其在一定程度上确实减缓了梯度消失和爆炸的速度。</p><p>如果使用的是ReLU激活函数，权重 <img src="https://www.zhihu.com/equation?tex=w" alt="公式"> 的初始化一般令其方差为 <img src="https://www.zhihu.com/equation?tex=2/n" alt="公式"> 对应 Python 代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w[l] = np.random.randn(n[l],n[l-1])*np.sqrt(2/n[l-1])</span><br></pre></td></tr></table></figure><h2 id="8-梯度检验-Gradient-checking"><a href="#8-梯度检验-Gradient-checking" class="headerlink" title="8.梯度检验 (Gradient checking)"></a>8.梯度检验 (Gradient checking)</h2><h3 id="8-1-梯度的数值逼近"><a href="#8-1-梯度的数值逼近" class="headerlink" title="8.1 梯度的数值逼近"></a>8.1 梯度的数值逼近</h3><p>我们知道梯度下降法会大程度依赖梯度来完成，在数学上，我们可以基于微分的定义，使用极限的计算去逼近导数，我们有如下的「<strong>单边误差法</strong>」和「<strong>双边误差法</strong>」，其中后者精度要高一些。</p><h4 id="1-单边误差"><a href="#1-单边误差" class="headerlink" title="(1) 单边误差"></a>(1) 单边误差</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/81833856e91a598bbb404056f5f800a5.png" alt="梯度检验"></p><h4 id="2-双边误差求导-即导数的定义"><a href="#2-双边误差求导-即导数的定义" class="headerlink" title="(2) 双边误差求导 (即导数的定义)"></a>(2) 双边误差求导 (即导数的定义)</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/fa8ef333db58212e7656fe6634bcaa54.png" alt="梯度检验"></p><p>当 <img src="https://www.zhihu.com/equation?tex=%5Cvarepsilon" alt="公式"> 越小时，结果越接近真实的导数，也就是梯度值。可以使用这种方法来判断反向传播进行梯度下降时，是否出现了错误。</p><h2 id="8-2-梯度检验"><a href="#8-2-梯度检验" class="headerlink" title="8.2 梯度检验"></a>8.2 梯度检验</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/df6bc97d7b89467098498e6be29a1e78.png" alt="梯度检验 Gradient Checking"></p><p>当我们计算出数值梯度后，要进行梯度检查，来验证训练过程中是否有问题。</p><h4 id="1-连接参数"><a href="#1-连接参数" class="headerlink" title="(1) 连接参数"></a>(1) 连接参数</h4><p>将 <img src="https://www.zhihu.com/equation?tex=W%5E%7B%5B1%5D%7D" alt="公式">，<img src="https://www.zhihu.com/equation?tex=b%5E%7B%5B1%5D%7D" alt="公式">，…，<img src="https://www.zhihu.com/equation?tex=W%5E%7B%5BL%5D%7D" alt="公式">，<img src="https://www.zhihu.com/equation?tex=b%5E%7B%5BL%5D%7D" alt="公式"> 全部连接出来，成为一个巨型向量 <img src="https://www.zhihu.com/equation?tex=%5Ctheta" alt="公式">。</p><p>同时，对 <img src="https://www.zhihu.com/equation?tex=dW%5E%7B%5B1%5D%7D" alt="公式">，<img src="https://www.zhihu.com/equation?tex=db%5E%7B%5B1%5D%7D" alt="公式">，…，<img src="https://www.zhihu.com/equation?tex=dW%5E%7B%5BL%5D%7D" alt="公式">，<img src="https://www.zhihu.com/equation?tex=db%5E%7B%5BL%5D%7D" alt="公式"> 执行同样的操作得到巨型向量 <img src="https://www.zhihu.com/equation?tex=d%5Ctheta" alt="公式">，它和 <img src="https://www.zhihu.com/equation?tex=%5Ctheta" alt="公式"> 有同样的维度。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/24e05cc98bf10bdb1beef77247ea6032.png" alt="连接参数"></p><p>现在，我们需要找到 <img src="https://www.zhihu.com/equation?tex=d%5Ctheta" alt="公式"> 和代价函数 <img src="https://www.zhihu.com/equation?tex=J" alt="公式"> 的梯度的关系。</p><h4 id="2-进行梯度检验"><a href="#2-进行梯度检验" class="headerlink" title="(2) 进行梯度检验"></a>(2) 进行梯度检验</h4><p>求得一个梯度逼近值 <img src="https://www.zhihu.com/equation?tex=d%5Ctheta_%7Bapprox%7D%5Bi%5D" alt="公式">，应该 <img src="https://www.zhihu.com/equation?tex=%5Capprox%20d%5Ctheta%5Bi%5D%20=%20%5Cfrac%7B%5Cpartial%20J%7D%7B%5Cpartial%20%5Ctheta_i%7D" alt="公式"> 。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d5e682a6896731de7e5b716972732f76.png" alt="梯度检验"></p><p>因此，我们用梯度检验值检验反向传播的实施是否正确。其中，<img src="https://www.zhihu.com/equation?tex=%7B%7C%7Cx%7C%7C%7D_2" alt="公式"> 表示向量 <img src="https://www.zhihu.com/equation?tex=x" alt="公式"> 的<strong>2-范数</strong> (也称「<strong>欧几里德范数</strong>」) 。</p><p><strong>如果梯度检验值和 <img src="https://www.zhihu.com/equation?tex=%5Cvarepsilon" alt="公式"> 的值相近，说明神经网络的实施是正确的，否则要去检查代码是否存在bug</strong>。</p><h3 id="8-3在神经网络实施梯度检验的实用技巧和注意事项"><a href="#8-3在神经网络实施梯度检验的实用技巧和注意事项" class="headerlink" title="8.3在神经网络实施梯度检验的实用技巧和注意事项"></a>8.3在神经网络实施梯度检验的实用技巧和注意事项</h3><p>在进行梯度检查的过程中有几点需要注意的地方：</p><ul><li>不要在整个训练过程中使用梯度检验，它仅仅用于调试。</li><li>如果算法的梯度检验失败，找到对应出错的梯度 (即 <img src="https://www.zhihu.com/equation?tex=d%5Ctheta%20%5Capprox%20%5Bi%5D" alt="公式"> 与 <img src="https://www.zhihu.com/equation?tex=d%5Ctheta" alt="公式"> 的值相差比较大的项) ，检查其推导是否出现错误。</li><li>计算近似梯度时，要带上正则项。</li><li>梯度检查时关闭dropout，检查完毕后再打开dropout。</li></ul>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI笔记（4）：深层神经网络</title>
      <link href="/2023/08/03/4.%E6%B7%B1%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/08/03/4.%E6%B7%B1%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="1-深层神经网络"><a href="#1-深层神经网络" class="headerlink" title="1.深层神经网络"></a>1.深层神经网络</h2><p>我们在前面提到了浅层神经网络，深层神经网络其实就是包含更多隐层的神经网络。下图分别列举了不同深度的神经网络模型结构：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/fe1b0d2a870df4aa84d2dbb262eee095.png" alt="深层神经网络"></p><p>我们会参考「隐层个数」和「输出层」对齐命名。如上图逻辑回归可以叫做<strong>1 layer NN</strong>，单隐层神经网络可以叫做<strong>2 layer NN</strong>，2个隐层的神经网络叫做<strong>3 layer NN</strong>，以此类推。所以当我们提到<strong>L layer NN</strong>，指的是包含 <img src="https://www.zhihu.com/equation?tex=L-1" alt="公式"> 个隐层的神经网络。</p><p>下面我们来了解一下神经网络的一些标记写法。以如下图的<strong>4层神经网络</strong>为例：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a39a6af8b64d1f10b20b7bec8de24997.png" alt="深层神经网络"></p><ol start="11"><li>总层数用 <img src="https://www.zhihu.com/equation?tex=L" alt="公式"> 表示， <img src="https://www.zhihu.com/equation?tex=L=4" alt="公式"></li></ol><ul><li><p>输入层是第 <img src="https://www.zhihu.com/equation?tex=0" alt="公式"> 层，输出层是第 <img src="https://www.zhihu.com/equation?tex=L" alt="公式"> 层</p></li><li><p><img src="https://www.zhihu.com/equation?tex=n%5E%7B%5Bl%5D%7D" alt="公式"> 表示第 <img src="https://www.zhihu.com/equation?tex=l" alt="公式"> 层包含的单元个数， <img src="https://www.zhihu.com/equation?tex=l=0,1,%5Ccdots,L" alt="公式"></p></li><li><p>下图模型中， <img src="https://www.zhihu.com/equation?tex=n%5E%7B%5B0%5D%7D=n_x=3" alt="公式">，表示三个输入特征 <img src="https://www.zhihu.com/equation?tex=x_1" alt="公式"> 、<img src="https://www.zhihu.com/equation?tex=x_2" alt="公式"> 、<img src="https://www.zhihu.com/equation?tex=x_3" alt="公式"></p></li><li><p>下图模型中 <img src="https://www.zhihu.com/equation?tex=n%5E%7B%5B1%5D%7D=5" alt="公式">，<img src="https://www.zhihu.com/equation?tex=n%5E%7B%5B2%5D%7D=5" alt="公式">，<img src="https://www.zhihu.com/equation?tex=n%5E%7B%5B3%5D%7D=3" alt="公式">，<img src="https://www.zhihu.com/equation?tex=n%5E%7B%5B4%5D%7D=n%5E%7B%5BL%5D%7D=1" alt="公式"></p></li><li><p>第 <img src="https://www.zhihu.com/equation?tex=l" alt="公式"> 层的激活函数输出用 <img src="https://www.zhihu.com/equation?tex=a%5E%7B%5Bl%5D%7D" alt="公式"> 表示，<img src="https://www.zhihu.com/equation?tex=a%5E%7B%5Bl%5D%7D=g%5E%7B%5Bl%5D%7D(z%5E%7B%5Bl%5D%7D)" alt="公式"></p></li><li><p><img src="https://www.zhihu.com/equation?tex=W%5E%7B%5Bl%5D%7D" alt="公式"> 表示第 <img src="https://www.zhihu.com/equation?tex=l" alt="公式"> 层的权重，用于计算 <img src="https://www.zhihu.com/equation?tex=z%5E%7B%5Bl%5D%7D" alt="公式"></p></li><li><p>输入 <img src="https://www.zhihu.com/equation?tex=x" alt="公式"> 记为 <img src="https://www.zhihu.com/equation?tex=a%5E%7B%5B0%5D%7D" alt="公式"></p></li><li><p>输出层 <img src="https://www.zhihu.com/equation?tex=%5Chat%20y" alt="公式"> 记为 <img src="https://www.zhihu.com/equation?tex=a%5E%7B%5BL%5D%7D" alt="公式"></p></li></ul><blockquote><p>注意， <img src="https://www.zhihu.com/equation?tex=a%5E%7B%5Bl%5D%7D" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=W%5E%7B%5Bl%5D%7D" alt="公式"> 中的上标 <img src="https://www.zhihu.com/equation?tex=l" alt="公式"> 都是从1开始的，<img src="https://www.zhihu.com/equation?tex=l=1,%5Ccdots,L" alt="公式">。</p></blockquote><h2 id="2-深层神经网络前向运算"><a href="#2-深层神经网络前向运算" class="headerlink" title="2.深层神经网络前向运算"></a>2.深层神经网络前向运算</h2><p>下面我们来推导一下深层神经网络的前向传播计算过程。依旧是上面提到的4层神经网络，我们以其为例来做讲解。</p><h3 id="2-1-单个样本的计算"><a href="#2-1-单个样本的计算" class="headerlink" title="2.1 单个样本的计算"></a>2.1 单个样本的计算</h3><p>对于<strong>单个样本</strong>，我们有：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/aca91359be984aed66ae23b1142f8ad5.png" alt="深层神经网络前向运算"></p><h3 id="2-2-m个样本的批量计算"><a href="#2-2-m个样本的批量计算" class="headerlink" title="2.2 m个样本的批量计算"></a>2.2 m个样本的批量计算</h3><p>对于 <img src="https://www.zhihu.com/equation?tex=m" alt="公式"> 个训练样本的情况，我们以<strong>向量化矩阵形式</strong>来并行计算：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b28cf1ac43f39d83adbe1792eefc9945.png" alt="深层神经网络前向运算"></p><p>以此类推，对于第 <img src="https://www.zhihu.com/equation?tex=l" alt="公式"> 层，其前向传播过程的 <img src="https://www.zhihu.com/equation?tex=Z%5E%7B%5Bl%5D%7D" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=A%5E%7B%5Bl%5D%7D" alt="公式"> 可以表示为：</p><p><img src="https://www.zhihu.com/equation?tex=Z%5E%7B%5Bl%5D%7D=W%5E%7B%5Bl%5D%7DA%5E%7B%5Bl-1%5D%7D+b%5E%7B%5Bl%5D%7D" alt="公式"></p><p><img src="https://www.zhihu.com/equation?tex=A%5E%7B%5Bl%5D%7D=g%5E%7B%5Bl%5D%7D(Z%5E%7B%5Bl%5D%7D)" alt="公式"></p><ul><li>其中 <img src="https://www.zhihu.com/equation?tex=l=1,%5Ccdots,L" alt="公式"></li></ul><h2 id="3-向量化形态下的矩阵维度"><a href="#3-向量化形态下的矩阵维度" class="headerlink" title="3.向量化形态下的矩阵维度"></a>3.向量化形态下的矩阵维度</h2><p>在单个训练样本的场景下，输入 <img src="https://www.zhihu.com/equation?tex=x" alt="公式"> 的维度是 <img src="https://www.zhihu.com/equation?tex=(n%5E%7B%5B0%5D%7D,1)" alt="公式"> 神经网络的参数 <img src="https://www.zhihu.com/equation?tex=W%5E%7B%5Bl%5D%7D" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=b%5E%7B%5Bl%5D%7D" alt="公式"> 的维度分别是：</p><ul><li><img src="https://www.zhihu.com/equation?tex=W%5E%7B%5Bl%5D%7D:%20(n%5E%7B%5Bl%5D%7D,n%5E%7B%5Bl-1%5D%7D)" alt="公式"></li><li><img src="https://www.zhihu.com/equation?tex=b%5E%7B%5Bl%5D%7D:%20(n%5E%7B%5Bl%5D%7D,1)" alt="公式"></li></ul><p>其中，</p><ul><li><img src="https://www.zhihu.com/equation?tex=l=1,%5Ccdots,L" alt="公式"></li><li><img src="https://www.zhihu.com/equation?tex=n%5E%7B%5Bl%5D%7D" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=n%5E%7B%5Bl-1%5D%7D" alt="公式"> 分别表示第 <img src="https://www.zhihu.com/equation?tex=l" alt="公式"> 层和 <img src="https://www.zhihu.com/equation?tex=l-1" alt="公式"> 层的所含单元个数</li><li><img src="https://www.zhihu.com/equation?tex=n%5E%7B%5B0%5D%7D=n_x" alt="公式">，表示输入层特征数目</li></ul><p>对应的<strong>反向传播</strong>过程中的 <img src="https://www.zhihu.com/equation?tex=dW%5E%7B%5Bl%5D%7D" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=db%5E%7B%5Bl%5D%7D" alt="公式"> 的维度分别是：</p><ul><li><img src="https://www.zhihu.com/equation?tex=dW%5E%7B%5Bl%5D%7D:%5C%20(n%5E%7B%5Bl%5D%7D,n%5E%7B%5Bl-1%5D%7D)" alt="公式"></li><li><img src="https://www.zhihu.com/equation?tex=db%5E%7B%5Bl%5D%7D:%5C%20(n%5E%7B%5Bl%5D%7D,1)" alt="公式"></li><li>注意到， <img src="https://www.zhihu.com/equation?tex=W%5E%7B%5Bl%5D%7D" alt="公式"> 与 <img src="https://www.zhihu.com/equation?tex=dW%5E%7B%5Bl%5D%7D" alt="公式"> 维度相同， <img src="https://www.zhihu.com/equation?tex=b%5E%7B%5Bl%5D%7D" alt="公式"> 与 <img src="https://www.zhihu.com/equation?tex=db%5E%7B%5Bl%5D%7D" alt="公式"> 维度相同。这很容易理解。</li></ul><p><strong>正向传播过程中的 <img src="https://www.zhihu.com/equation?tex=z%5E%7B%5Bl%5D%7D" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=a%5E%7B%5Bl%5D%7D" alt="公式"> 的维度分别是</strong>：</p><ul><li><img src="https://www.zhihu.com/equation?tex=z%5E%7B%5Bl%5D%7D:%5C%20(n%5E%7B%5Bl%5D%7D,1)" alt="公式"></li><li><img src="https://www.zhihu.com/equation?tex=a%5E%7B%5Bl%5D%7D:%5C%20(n%5E%7B%5Bl%5D%7D,1)" alt="公式"></li><li><img src="https://www.zhihu.com/equation?tex=z%5E%7B%5Bl%5D%7D" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=a%5E%7B%5Bl%5D%7D" alt="公式"> 的维度是一样的，且 <img src="https://www.zhihu.com/equation?tex=dz%5E%7B%5Bl%5D%7D" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=da%5E%7B%5Bl%5D%7D" alt="公式"> 的维度均与 <img src="https://www.zhihu.com/equation?tex=z%5E%7B%5Bl%5D%7D" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=a%5E%7B%5Bl%5D%7D" alt="公式"> 的维度一致。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/13daf26025fdc3819468a817f650becf.png" alt="深层神经网络前向运算"></p><p><strong>对于 <img src="https://www.zhihu.com/equation?tex=m" alt="公式"> 个训练样本</strong>，输入矩阵 <img src="https://www.zhihu.com/equation?tex=X" alt="公式"> 的维度是 <img src="https://www.zhihu.com/equation?tex=(n%5E%7B%5B0%5D%7D,m)" alt="公式">。需要注意的是 <img src="https://www.zhihu.com/equation?tex=W%5E%7B%5Bl%5D%7D" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=b%5E%7B%5Bl%5D%7D" alt="公式"> 的维度与只有单个样本是一致的：</p><ul><li><img src="https://www.zhihu.com/equation?tex=W%5E%7B%5Bl%5D%7D:%5C%20(n%5E%7B%5Bl%5D%7D,n%5E%7B%5Bl-1%5D%7D)" alt="公式"></li><li><img src="https://www.zhihu.com/equation?tex=b%5E%7B%5Bl%5D%7D:%5C%20(n%5E%7B%5Bl%5D%7D,1)" alt="公式"></li></ul><p>只不过在运算 <img src="https://www.zhihu.com/equation?tex=Z%5E%7B%5Bl%5D%7D=W%5E%7B%5Bl%5D%7DA%5E%7B%5Bl-1%5D%7D+b%5E%7B%5Bl%5D%7D" alt="公式"> 中， <img src="https://www.zhihu.com/equation?tex=b%5E%7B%5Bl%5D%7D" alt="公式"> 会被当成 <img src="https://www.zhihu.com/equation?tex=(n%5E%7B%5Bl%5D%7D,m)" alt="公式"> 矩阵进行运算，这是基于python numpy的广播特性，且 <img src="https://www.zhihu.com/equation?tex=b%5E%7B%5Bl%5D%7D" alt="公式"> 每一列向量都是一样的。 <img src="https://www.zhihu.com/equation?tex=dW%5E%7B%5Bl%5D%7D" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=db%5E%7B%5Bl%5D%7D" alt="公式"> 的维度分别与 <img src="https://www.zhihu.com/equation?tex=W%5E%7B%5Bl%5D%7D" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=b%5E%7B%5Bl%5D%7D" alt="公式"> 的相同。</p><p>不过， <img src="https://www.zhihu.com/equation?tex=Z%5E%7B%5Bl%5D%7D" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=A%5E%7B%5Bl%5D%7D" alt="公式"> 的维度发生了变化：</p><ul><li><img src="https://www.zhihu.com/equation?tex=Z%5E%7B%5Bl%5D%7D:%5C%20(n%5E%7B%5Bl%5D%7D,m)" alt="公式"></li><li><img src="https://www.zhihu.com/equation?tex=A%5E%7B%5Bl%5D%7D:%5C%20(n%5E%7B%5Bl%5D%7D,m)" alt="公式"></li><li><img src="https://www.zhihu.com/equation?tex=dZ%5E%7B%5Bl%5D%7D" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=dA%5E%7B%5Bl%5D%7D" alt="公式"> 的维度分别与 <img src="https://www.zhihu.com/equation?tex=Z%5E%7B%5Bl%5D%7D" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=A%5E%7B%5Bl%5D%7D" alt="公式"> 的相同。</li></ul><h2 id="4-为什么需要深度网络"><a href="#4-为什么需要深度网络" class="headerlink" title="4.为什么需要深度网络"></a>4.为什么需要深度网络</h2><p>当今大家看到的很多AI智能场景背后都是巨大的神经网络在支撑，强大能力很大一部分来源于神经网络足够“深”，也就是说随着网络层数增多，神经网络就更加复杂参数更多，学习能力也更强。下面是一些典型的场景例子说明。</p><h3 id="4-1-人脸识别例子"><a href="#4-1-人脸识别例子" class="headerlink" title="4.1 人脸识别例子"></a>4.1 人脸识别例子</h3><p>如下图所示的<strong>人脸识别场景</strong>，训练得到的神经网络，每一层的作用有差别：</p><ul><li>第一层所做的事就是从原始图片中提取出<strong>人脸的轮廓与边缘</strong>，即<strong>边缘检测</strong>。这样每个神经元得到的是一些边缘信息。</li><li>第二层所做的事情就是<strong>将前一层的边缘进行组合</strong>，组合成<strong>人脸一些局部特征</strong>，比如眼睛、鼻子、嘴巴等。</li><li>后续层次逐层把这些<strong>局部特征组合起来</strong>，融合成人脸的模样。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/73286a1c9b6585bdbb9eb5c8a6b588ff.png" alt="为什么需要深度网络"></p><p>可以看出，随着层数由浅到深，神经网络提取的特征也是<strong>从边缘到局部特征到整体，由简单到复杂</strong>。隐藏层越多，能够提取的特征就越丰富、越复杂，模型的准确率也可能会随之越高。</p><h3 id="4-2-语音识别例子"><a href="#4-2-语音识别例子" class="headerlink" title="4.2 语音识别例子"></a>4.2 语音识别例子</h3><p><strong>语音识别模型</strong>也是类似的道理：</p><ul><li>浅层的神经元能够检测一些简单的音调</li><li>较深的神经元能够检测出基本的音素</li><li>更深的神经元就能够检测出单词信息</li><li>网络足够深的话，还能对短语、句子进行检测</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/57bc2518c4ab9bf06c59786b2bdf6ef3.png" alt="为什么需要深度网络"></p><p>神经网络从浅到深，提取的特征从简单到复杂。特征复杂度与神经网络层数成正相关。特征越来越复杂，表达能力和功能也越强。</p><h3 id="4-3-深度网络其他优势"><a href="#4-3-深度网络其他优势" class="headerlink" title="4.3 深度网络其他优势"></a>4.3 深度网络其他优势</h3><p>除学习能力与特征提取强度之外，深层网络还有另外一个优点，就是能够减少神经元个数，从而减少计算量。</p><p>下面有一个例子，使用电路理论，计算逻辑输出：</p><p><img src="https://www.zhihu.com/equation?tex=y=x_1%5Coplus%20x_2%5Coplus%20x_3%5Coplus%5Ccdots%5Coplus%20x_n" alt="公式"></p><ul><li>上面的计算表达式中， <img src="https://www.zhihu.com/equation?tex=%5Coplus" alt="公式"> 表示「<strong>异或</strong>」操作。</li></ul><p>对于这个逻辑运算，如果使用深度网络完成，每层将前一层的两两单元进行异或，最后到一个输出，如下图左边所示。</p><p>这样，整个深度网络的层数是 <img src="https://www.zhihu.com/equation?tex=log_2(n)" alt="公式"> (不包含输入层)。总共使用的神经元个数为：</p><p><img src="https://www.zhihu.com/equation?tex=1+2+%5Ccdots+2%5E%7Blog_2(n)-1%7D=1%5Ccdot%5Cfrac%7B1-2%5E%7Blog_2(n)%7D%7D%7B1-2%7D=2%5E%7Blog_2(n)%7D-1=n-1" alt="公式"></p><p>可见，输入个数是 <img src="https://www.zhihu.com/equation?tex=n" alt="公式">，这种深层网络所需的神经元个数仅仅是 <img src="https://www.zhihu.com/equation?tex=n-1" alt="公式"> 个。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0bfafb21ce4984b41e53c219c863f783.png" alt="为什么需要深度网络"></p><p>如果不用深层网络，仅仅使用单个隐藏层，如上右图所示，由于包含了所有的逻辑位(0和1)，那么需要的神经元个数 <img src="https://www.zhihu.com/equation?tex=O(2%5En)" alt="公式"> 是指数级别的大小。</p><p>对于其他场景和问题也一样，处理同样的逻辑问题，深层网络所需的神经元个数比浅层网络要少很多。这也是深层神经网络的优点之一。</p><p>尽管深度学习有着非常显著的优势，吴恩达老师还是建议对实际问题进行建模时，尽量先选择层数少的神经网络模型，这也符合奥卡姆剃刀定律 (Occam’s Razor)。对于比较复杂的问题，再使用较深的神经网络模型。</p><h2 id="5-构建深度网络单元块"><a href="#5-构建深度网络单元块" class="headerlink" title="5.构建深度网络单元块"></a>5.构建深度网络单元块</h2><p>下面用流程块图来解释神经网络前向传播和反向传播过程。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/68352e6774da5595a53fbc6dd1cc50bb.png" alt="构建深度网络单元块"></p><p>如图所示，对于第 <img src="https://www.zhihu.com/equation?tex=l" alt="公式"> 层来说，<strong>前向传播</strong>过程中，我们有：</p><ul><li><strong>输入</strong>：<img src="https://www.zhihu.com/equation?tex=a%5E%7B%5Bl-1%5D%7D" alt="公式"></li><li><strong>输出</strong>：<img src="https://www.zhihu.com/equation?tex=a%5E%7B%5Bl%5D%7D" alt="公式"></li><li><strong>参数</strong>：<img src="https://www.zhihu.com/equation?tex=W%5E%7B%5Bl%5D%7D" alt="公式"> 、 <img src="https://www.zhihu.com/equation?tex=b%5E%7B%5Bl%5D%7D" alt="公式"></li><li><strong>缓存变量</strong>：<img src="https://www.zhihu.com/equation?tex=z%5E%7B%5Bl%5D%7D" alt="公式"></li></ul><p><strong>反向传播</strong>过程中：</p><ul><li><strong>输入</strong>：<img src="https://www.zhihu.com/equation?tex=da%5E%7B%5Bl%5D%7D" alt="公式"></li><li><strong>输出</strong>：<img src="https://www.zhihu.com/equation?tex=da%5E%7B%5Bl-1%5D%7D" alt="公式"> 、 <img src="https://www.zhihu.com/equation?tex=dW%5E%7B%5Bl%5D%7D" alt="公式"> 、 <img src="https://www.zhihu.com/equation?tex=db%5E%7B%5Bl%5D%7D" alt="公式"></li><li><strong>参数</strong>：<img src="https://www.zhihu.com/equation?tex=W%5E%7B%5Bl%5D%7D" alt="公式"> 、 <img src="https://www.zhihu.com/equation?tex=b%5E%7B%5Bl%5D%7D" alt="公式"></li></ul><p>上面是第 <img src="https://www.zhihu.com/equation?tex=l" alt="公式"> 层的流程块图，对于神经网络所有层，整体的流程块图前向传播过程和反向传播过程如下所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/400c9534e57d223a6bde471b398db644.png" alt="构建深度网络单元块"></p><h2 id="6-前向传播与反向传播"><a href="#6-前向传播与反向传播" class="headerlink" title="6.前向传播与反向传播"></a>6.前向传播与反向传播</h2><p>我们继续接着上一部分流程块图的内容，推导神经网络正向传播过程和反向传播过程的具体表达式。</p><h3 id="6-1-前向传播过程"><a href="#6-1-前向传播过程" class="headerlink" title="6.1 前向传播过程"></a>6.1 前向传播过程</h3><p>令层数为第 <img src="https://www.zhihu.com/equation?tex=l" alt="公式"> 层，输入是 <img src="https://www.zhihu.com/equation?tex=a%5E%7B%5Bl-1%5D%7D" alt="公式">，输出是 <img src="https://www.zhihu.com/equation?tex=a%5E%7B%5Bl%5D%7D" alt="公式">，缓存变量是 <img src="https://www.zhihu.com/equation?tex=z%5E%7B%5Bl%5D%7D" alt="公式">。其表达式如下：</p><p><img src="https://www.zhihu.com/equation?tex=z%5E%7B%5Bl%5D%7D=W%5E%7B%5Bl%5D%7Da%5E%7B%5Bl-1%5D%7D+b%5E%7B%5Bl%5D%7D" alt="公式"></p><p><img src="https://www.zhihu.com/equation?tex=a%5E%7B%5Bl%5D%7D=g%5E%7B%5Bl%5D%7D(z%5E%7B%5Bl%5D%7D)" alt="公式"></p><p><img src="https://www.zhihu.com/equation?tex=m" alt="公式"> <strong>个训练样本</strong>的形态下，<strong>向量化</strong>形式为：</p><p><img src="https://www.zhihu.com/equation?tex=Z%5E%7B%5Bl%5D%7D=W%5E%7B%5Bl%5D%7DA%5E%7B%5Bl-1%5D%7D+b%5E%7B%5Bl%5D%7D" alt="公式"></p><p><img src="https://www.zhihu.com/equation?tex=A%5E%7B%5Bl%5D%7D=g%5E%7B%5Bl%5D%7D(Z%5E%7B%5Bl%5D%7D)" alt="公式"></p><h3 id="6-2-反向传播过程"><a href="#6-2-反向传播过程" class="headerlink" title="6.2 反向传播过程"></a>6.2 反向传播过程</h3><p>输入是 <img src="https://www.zhihu.com/equation?tex=da%5E%7B%5Bl%5D%7D" alt="公式">，输出是 <img src="https://www.zhihu.com/equation?tex=da%5E%7B%5Bl-1%5D%7D" alt="公式"> 、 <img src="https://www.zhihu.com/equation?tex=dW%5E%7B%5Bl%5D%7D" alt="公式"> 、 <img src="https://www.zhihu.com/equation?tex=db%5E%7B%5Bl%5D%7D" alt="公式">。其表达式如下：</p><p><img src="https://www.zhihu.com/equation?tex=dz%5E%7B%5Bl%5D%7D=da%5E%7B%5Bl%5D%7D%5Cast%20g%5E%7B%5Bl%5D%5Cprime%7D(z%5E%7B%5Bl%5D%7D)" alt="公式"></p><p><img src="https://www.zhihu.com/equation?tex=dW%5E%7B%5Bl%5D%7D=dz%5E%7B%5Bl%5D%7D%5Ccdot%20a%5E%7B%5Bl-1%5D%7D" alt="公式"></p><p><img src="https://www.zhihu.com/equation?tex=db%5E%7B%5Bl%5D%7D=dz%5E%7B%5Bl%5D%7D" alt="公式"></p><p><img src="https://www.zhihu.com/equation?tex=da%5E%7B%5Bl-1%5D%7D=W%5E%7B%5Bl%5DT%7D%5Ccdot%20dz%5E%7B%5Bl%5D%7D" alt="公式"></p><p>由上述第四个表达式可得 <img src="https://www.zhihu.com/equation?tex=da%5E%7B%5Bl%5D%7D=W%5E%7B%5Bl+1%5DT%7D%5Ccdot%20dz%5E%7B%5Bl+1%5D%7D" alt="公式">，将 <img src="https://www.zhihu.com/equation?tex=da%5E%7B%5Bl%5D%7D" alt="公式"> 代入第一个表达式中可以得到：</p><p><img src="https://www.zhihu.com/equation?tex=dz%5E%7B%5Bl%5D%7D=W%5E%7B%5Bl+1%5DT%7D%5Ccdot%20dz%5E%7B%5Bl+1%5D%7D%5Cast%20g%5E%7B%5Bl%5D%5Cprime%7D(z%5E%7B%5Bl%5D%7D)" alt="公式"></p><p>该式非常重要，反映了 <img src="https://www.zhihu.com/equation?tex=dz%5E%7B%5Bl+1%5D%7D" alt="公式"> 与 <img src="https://www.zhihu.com/equation?tex=dz%5E%7B%5Bl%5D%7D" alt="公式"> 的递推关系。</p><p><img src="https://www.zhihu.com/equation?tex=m" alt="公式"> <strong>个训练样本</strong>的形态下，<strong>向量化</strong>形式为：</p><p><img src="https://www.zhihu.com/equation?tex=d%20Z%5E%7B%5Bl%5D%7D=d%20A%5E%7B%5Bl%5D%7D%5Cast%20g%5E%7B%5Bl%5D%5Cprime%7D%20(Z%5E%7B%5Bl%5D%7D)" alt="公式"></p><p><img src="https://www.zhihu.com/equation?tex=dW%5E%7B%5Bl%5D%7D=%5Cfrac1mdZ%5E%7B%5Bl%5D%7D%5Ccdot%20A%5E%7B%5Bl-1%5DT%7D" alt="公式"></p><p><img src="https://www.zhihu.com/equation?tex=db%5E%7B%5Bl%5D%7D=%5Cfrac1mnp.sum(dZ%5E%7B%5Bl%5D%7D,axis=1,keepdim=True)" alt="公式"></p><p><img src="https://www.zhihu.com/equation?tex=dA%5E%7B%5Bl-1%5D%7D=W%5E%7B%5Bl%5DT%7D%5Ccdot%20dZ%5E%7B%5Bl%5D%7D" alt="公式"></p><p><img src="https://www.zhihu.com/equation?tex=dZ%5E%7B%5Bl%5D%7D=W%5E%7B%5Bl+1%5DT%7D%5Ccdot%20dZ%5E%7B%5Bl+1%5D%7D%5Cast%20g%5E%7B%5Bl%5D%5Cprime%7D(Z%5E%7B%5Bl%5D%7D)" alt="公式"></p><h2 id="7-参数与超参数"><a href="#7-参数与超参数" class="headerlink" title="7.参数与超参数"></a>7.参数与超参数</h2><p>神经网络中有两个大家要重点区分的概念：<strong>参数</strong>(<strong>parameters</strong>)和<strong>超参数</strong>(<strong>hyperparameters</strong>)。</p><ul><li>神经网络中的参数就是我们熟悉的 <img src="https://www.zhihu.com/equation?tex=W%5E%7B%5Bl%5D%7D" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=b%5E%7B%5Bl%5D%7D" alt="公式">。</li><li>神经网络的超参数是例如学习率 <img src="https://www.zhihu.com/equation?tex=%5Calpha" alt="公式">，训练迭代次数 <img src="https://www.zhihu.com/equation?tex=N" alt="公式">，神经网络层数 <img src="https://www.zhihu.com/equation?tex=L" alt="公式">，各层神经元个数 <img src="https://www.zhihu.com/equation?tex=n%5E%7B%5Bl%5D%7D" alt="公式">，激活函数 <img src="https://www.zhihu.com/equation?tex=g(z)" alt="公式"> 等。</li><li>之所以叫做超参数，是因为它们需要提前敲定，而且它们会决定参数 <img src="https://www.zhihu.com/equation?tex=W%5E%7B%5Bl%5D%7D" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=b%5E%7B%5Bl%5D%7D" alt="公式"> 的值。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/4ac1059666e255e2bead507164482c29.png" alt="参数与超参数"></p><p>如何设置最优的超参数是一个比较困难的、需要经验知识的问题。通常的做法是选择超参数一定范围内的值，分别代入神经网络进行训练，测试cost function随着迭代次数增加的变化，根据结果选择cost function最小时对应的超参数值。这类似于机器学习中的实验验证的方法。</p><h2 id="8-神经网络vs人脑"><a href="#8-神经网络vs人脑" class="headerlink" title="8.神经网络vs人脑"></a>8.神经网络vs人脑</h2><p>神经网络跟人脑机制到底有什么联系呢？究竟有多少的相似程度？</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e630b075438c9ae623890c7ea95d1edd.png" alt="深度网络 VS 大脑"></p><p>我们前面看到神经网络实际上可以分成两个部分：<strong>前向传播</strong>过程和<strong>反向传播</strong>过程。神经网络的每个神经元采用激活函数的方式，类似于感知机模型。这种模型与人脑神经元是类似的，但是一种非常简化的人脑神经元模型。</p><p><strong>人脑神经元可分为树突、细胞体、轴突三部分</strong>。树突接收外界电刺激信号(类比神经网络中神经元输入)，传递给细胞体进行处理(类比神经网络中神经元激活函数运算)，最后由轴突传递给下一个神经元(类比神经网络中神经元输出)。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/83fb4374f57e3227de58cd11493a4df3.png" alt="深度网络 VS 大脑"></p><p><strong>人脑神经元的结构和处理方式要复杂的多，神经网络模型只是非常简化的模型</strong>。</p><p>人脑如何进行学习？是否也是通过反向传播和梯度下降算法现在还不清楚，可能会更加复杂。这是值得生物学家探索的事情。</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI笔记（3）：浅层神经网络</title>
      <link href="/2023/08/03/3.%E6%B5%85%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/08/03/3.%E6%B5%85%E5%B1%82%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="1-神经网络表示"><a href="#1-神经网络表示" class="headerlink" title="1.神经网络表示"></a>1.神经网络表示</h2><p>图示为两层神经网络，也可以称作<strong>单隐层神经网络</strong> (<strong>a single hidden layer neural network</strong>) 。这就是典型的浅层 (shallow) 神经网络，结构上，从左到右，可以分成三层：</p><ul><li><strong>输入层</strong> (input layer) ：竖向堆叠起来的输入特征向量。</li><li><strong>隐藏层</strong> (hidden layer) ：抽象的非线性的中间层。</li><li><strong>输出层</strong> (output layer) ：输出预测值。</li></ul><p>注意：<strong>当我们计算网络的层数时，通常不考虑输入层</strong>。因此图中隐藏层是第一层，输出层是第二层。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3f6d6638ab4d7b7b847e81c662265f23.png" alt="神经网络表示"></p><p>有一些约定俗成的符号表示，如下：</p><ul><li>输入层的激活值为 <img src="https://www.zhihu.com/equation?tex=a%5E%7B%5B0%5D%7D" alt="公式"> ，隐藏层产生的激活值，记作 <img src="https://www.zhihu.com/equation?tex=a%5E%7B%5B1%5D%7D" alt="公式"> 。</li><li>隐藏层的第一个单元 (或者说节点) 就记作 <img src="https://www.zhihu.com/equation?tex=a%5E%7B%5B1%5D%7D_1" alt="公式"> ，输出层同理。</li><li>隐藏层和输出层都是带有参数 <img src="https://www.zhihu.com/equation?tex=W" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=b" alt="公式"> 的，它们都使用上标[1]来表示是和第一个隐藏层有关，或者上标[2]来表示是和输出层有关。</li></ul><h2 id="2-计算神经网络的输出"><a href="#2-计算神经网络的输出" class="headerlink" title="2.计算神经网络的输出"></a>2.计算神经网络的输出</h2><h3 id="2-1-两层神经网络"><a href="#2-1-两层神经网络" class="headerlink" title="2.1 两层神经网络"></a>2.1 两层神经网络</h3><p><strong>接下来我们开始详细推导神经网络的计算过程</strong>。</p><p>我们依旧来看看我们熟悉的逻辑回归，我们用其构建两层神经网络。逻辑回归的前向传播计算可以分解成计算 <img src="https://www.zhihu.com/equation?tex=z" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=a" alt="公式"> 的两部分。</p><p>如果我们基于逻辑回归构建两层神经网络，前向计算从前往后要做2次计算：</p><ul><li>从输入层到隐藏层，对应一次逻辑回归运算。</li><li>从隐藏层到输出层，对应一次逻辑回归运算。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/dee4707bee4f6677c6ae375b431df3da.png" alt="神经网络前向计算"></p><p>在每层计算中，我们注意对应的上标和下标：</p><ul><li>我们记上标方括号 <img src="https://www.zhihu.com/equation?tex=%5E%7B%5B%20%5D%7D" alt="公式"> 表示layer，记下标表示第几个神经元。例如， <img src="https://www.zhihu.com/equation?tex=a_i%5E%7B%5Bl%5D%7D" alt="公式"> 表示第 <img src="https://www.zhihu.com/equation?tex=l" alt="公式"> 层的第 <img src="https://www.zhihu.com/equation?tex=i" alt="公式"> 个神经元。</li><li>注意， <img src="https://www.zhihu.com/equation?tex=i" alt="公式"> 从 <img src="https://www.zhihu.com/equation?tex=1" alt="公式"> 开始， <img src="https://www.zhihu.com/equation?tex=l" alt="公式"> 从 <img src="https://www.zhihu.com/equation?tex=0" alt="公式"> 开始。</li></ul><h3 id="2-2-单个样本计算方式"><a href="#2-2-单个样本计算方式" class="headerlink" title="2.2 单个样本计算方式"></a>2.2 单个样本计算方式</h3><p>我们将<strong>输入层到隐藏层</strong>的计算公式列出来：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/dfd836d220b8197dcb29588a03f20725.png" alt="神经网络前向计算"></p><p>后续<strong>从隐藏层到输出层</strong>的计算公式为：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b1736e46a9615d88615402548fa75d59.png" alt="神经网络前向计算"></p><p><strong>上述每个节点的计算都对应着一次逻辑运算的过程，分别由计算</strong> <img src="https://www.zhihu.com/equation?tex=z" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=a" alt="公式"> <strong>两部分组成</strong>。</p><h3 id="2-3-向量化计算"><a href="#2-3-向量化计算" class="headerlink" title="2.3 向量化计算"></a>2.3 向量化计算</h3><p>我们引入向量化思想提升计算效率，<strong>将上述表达式转换成矩阵运算的形式</strong>，如下所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/4e1dc2e4b65e7c65b24f192e50137604.png" alt="神经网络前向计算"></p><p>我们这里特别注意一下数据维度：</p><ul><li><img src="https://www.zhihu.com/equation?tex=W%5E%7B%5B1%5D%7D" alt="公式"> 的维度是 <img src="https://www.zhihu.com/equation?tex=(4,3)" alt="公式"></li><li><img src="https://www.zhihu.com/equation?tex=b%5E%7B%5B1%5D%7D" alt="公式"> 的维度是 <img src="https://www.zhihu.com/equation?tex=(4,1)" alt="公式"></li><li><img src="https://www.zhihu.com/equation?tex=W%5E%7B%5B2%5D%7D" alt="公式"> 的维度是 <img src="https://www.zhihu.com/equation?tex=(1,4)" alt="公式"></li><li><img src="https://www.zhihu.com/equation?tex=b%5E%7B%5B2%5D%7D" alt="公式"> 的维度是 <img src="https://www.zhihu.com/equation?tex=(1,1)" alt="公式"></li></ul><h3 id="2-4-数据集向量化计算"><a href="#2-4-数据集向量化计算" class="headerlink" title="2.4 数据集向量化计算"></a>2.4 数据集向量化计算</h3><p>上面部分提到的是单个样本的神经网络正向传播矩阵运算过程。对于 <img src="https://www.zhihu.com/equation?tex=m" alt="公式"> 个训练样本，我们也可以使用向量化矩阵运算的形式来提升计算效率。形式上，它和单个样本的矩阵运算十分相似，比较简单。我们记输入矩阵 <img src="https://www.zhihu.com/equation?tex=X" alt="公式"> 的维度为 <img src="https://www.zhihu.com/equation?tex=(n_x,m)" alt="公式"> ，则有：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/22bfa78baa87b764caff7869586220da.png" alt="神经网络前向计算"></p><p>上述公式中， <img src="https://www.zhihu.com/equation?tex=Z%5E%7B%5B1%5D%7D" alt="公式"> 的维度是 <img src="https://www.zhihu.com/equation?tex=(4,m)" alt="公式"> ，4是隐藏层神经元的个数； <img src="https://www.zhihu.com/equation?tex=A%5E%7B%5B1%5D%7D" alt="公式"> 的维度与 <img src="https://www.zhihu.com/equation?tex=Z%5E%7B%5B1%5D%7D" alt="公式"> 相同； <img src="https://www.zhihu.com/equation?tex=Z%5E%7B%5B2%5D%7D" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=A%5E%7B%5B2%5D%7D" alt="公式"> 的维度均为 <img src="https://www.zhihu.com/equation?tex=(1,m)" alt="公式"> 。</p><p>我们可以这样理解上述的矩阵：<strong>行表示神经元个数，列表示样本数目</strong> <img src="https://www.zhihu.com/equation?tex=m" alt="公式">。</p><h2 id="3-激活函数"><a href="#3-激活函数" class="headerlink" title="3.激活函数"></a>3.激活函数</h2><h3 id="3-1-不同的激活函数与选择"><a href="#3-1-不同的激活函数与选择" class="headerlink" title="3.1 不同的激活函数与选择"></a>3.1 不同的激活函数与选择</h3><p>在神经网络中，隐藏层和输出层都需要激活函数 (activation function) ，前面的例子中我们都默认使用 Sigmoid 函数 <img src="https://www.zhihu.com/equation?tex=%5Csigma(z)" alt="公式"> 作为激活函数。实际我们有不同的激活函数可以选择，而且它们有各自的优点：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/bd32338c19bcc2b587e024f4b84afae2.png" alt="激活函数"></p><h4 id="1-tanh-函数"><a href="#1-tanh-函数" class="headerlink" title="(1) tanh 函数"></a>(1) tanh 函数</h4><p><strong>the hyperbolic tangent function，双曲正切函数</strong></p><p><img src="https://www.zhihu.com/equation?tex=a%20=%20%5Cfrac%7Be%5Ez%20-%20e%5E%7B-z%7D%7D%7Be%5Ez%20+%20e%5E%7B-z%7D%7D" alt="公式"></p><p><strong>优点</strong>：函数输出介于 <img src="https://www.zhihu.com/equation?tex=(-1,1)" alt="公式"> ，激活函数的平均值就更接近0，有类似数据中心化的效果。效果几乎总比 Sigmoid 函数好 (二元分类的输出层我们还是会用 Sigmoid ，因为我们希望输出的结果介于 <img src="https://www.zhihu.com/equation?tex=(0,1)" alt="公式"> ) 。</p><p><strong>缺点</strong>：当 <img src="https://www.zhihu.com/equation?tex=z" alt="公式"> 趋紧无穷大 (或无穷小) ，导数的梯度 (即函数的斜率) 就趋紧于0，这使得梯度算法的速度大大减缓。这一点和 Sigmoid 一样。</p><h4 id="2-ReLU函数"><a href="#2-ReLU函数" class="headerlink" title="(2) ReLU函数"></a>(2) ReLU函数</h4><p><strong>the rectified linear unit，修正线性单元</strong></p><p><img src="https://www.zhihu.com/equation?tex=a=max(0,z)" alt="公式"></p><p><strong>优点</strong>：当 <img src="https://www.zhihu.com/equation?tex=z%20%3E%200" alt="公式"> 时，梯度始终为1，从而提高神经网络基于梯度算法的运算速度，收敛速度远大于 Sigmoid 和tanh。</p><p><strong>缺点</strong>：当 <img src="https://www.zhihu.com/equation?tex=z%20%3C%200" alt="公式"> 时，梯度一直为0，但是实际的运用中，该缺陷的影响不是很大。</p><h4 id="3-Leaky-ReLU"><a href="#3-Leaky-ReLU" class="headerlink" title="(3) Leaky ReLU"></a>(3) Leaky ReLU</h4><p><strong>带泄漏的ReLU</strong></p><p><img src="https://www.zhihu.com/equation?tex=a=max(0.01z,z)" alt="公式"></p><p><strong>优点</strong>：Leaky ReLU保证在 <img src="https://www.zhihu.com/equation?tex=z%20%3C%200" alt="公式"> 的时候，梯度仍然不为0。</p><p>理论上来说，Leaky ReLU有ReLU的所有优点，但在实际操作中没有证明总是好于ReLU，因此不常用。</p><p><strong>总结</strong></p><p>在选择激活函数的时候，如果在不知道该选什么的时候就选择ReLU。当然也没有固定答案，要依据实际问题在交叉验证集合中进行验证分析。注意，我们可以在不同层选用不同的激活函数。</p><h3 id="3-2-使用非线性激活函数的原因"><a href="#3-2-使用非线性激活函数的原因" class="headerlink" title="3.2 使用非线性激活函数的原因"></a>3.2 使用非线性激活函数的原因</h3><p>使用线性激活函数和不使用激活函数、无论神经网络有多少层，输出都是输入的线性组合，<strong>与没有隐藏层效果相当</strong>，就成了最原始的感知器了。我们以2层神经网络做一个简单推导，如下：</p><p>假设所有的激活函数都是线性的，为了更简单一点，我们直接令激活函数 <img src="https://www.zhihu.com/equation?tex=g(z)=z" alt="公式"> ，即 <img src="https://www.zhihu.com/equation?tex=a=z" alt="公式"> 。那么，浅层神经网络的各层输出为：</p><p><img src="https://www.zhihu.com/equation?tex=z%5E%7B%5B1%5D%7D=W%5E%7B%5B1%5D%7Dx+b%5E%7B%5B1%5D%7D" alt="公式"> <img src="https://www.zhihu.com/equation?tex=a%5E%7B%5B1%5D%7D=z%5E%7B%5B1%5D%7D" alt="公式"> <img src="https://www.zhihu.com/equation?tex=z%5E%7B%5B2%5D%7D=W%5E%7B%5B2%5D%7Da%5E%7B%5B1%5D%7D+b%5E%7B%5B2%5D%7D" alt="公式"> <img src="https://www.zhihu.com/equation?tex=a%5E%7B%5B2%5D%7D=z%5E%7B%5B2%5D%7D" alt="公式"></p><p>我们对上述公式中 <img src="https://www.zhihu.com/equation?tex=a%5E%7B%5B2%5D%7D" alt="公式"> 展开计算，得：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D%20a%5E%7B%5B2%5D%7D=z%5E%7B%5B2%5D%7D%20&=W%5E%7B%5B2%5D%7D%20a%5E%7B%5B1%5D%7D+b%5E%7B%5B2%5D%7D%20%5C%5C%20&=W%5E%7B%5B2%5D%7D%5Cleft(W%5E%7B%5B1%5D%7D%20x+b%5E%7B%5B1%5D%7D%5Cright)+b%5E%7B%5B2%5D%7D%20%5C%5C%20&=%5Cleft(W%5E%7B%5B2%5D%7D%20W%5E%7B%5B1%5D%7D%5Cright)%20x+%5Cleft(W%5E%7B%5B2%5D%7D%20b%5E%7B%5B1%5D%7D+b%5E%7B%5B2%5D%7D%5Cright)%20%5C%5C%20&=W%5E%7B%5Cprime%7D%20x+b%5E%7B%5Cprime%7D%20%5Cend%7Baligned%7D" alt="公式"></p><p>上述推导后，我们可以发现 <img src="https://www.zhihu.com/equation?tex=a%5E%7B%5B2%5D%7D" alt="公式"> 仍是输入变量 <img src="https://www.zhihu.com/equation?tex=x" alt="公式"> 的线性组合！后续堆叠更多的层次，也可以依次类推，这表明，使用神经网络，如果不使用激活函数或使用线性激活函数，与直接使用线性模型的效果并没有什么两样！因此，隐藏层的激活函数必须要是非线性的。</p><p>不过，在部分场景下，比如是回归预测问题而不是分类问题，输出值 <img src="https://www.zhihu.com/equation?tex=y" alt="公式"> 为连续值，输出层的激活函数可以使用线性函数。如果输出 <img src="https://www.zhihu.com/equation?tex=y" alt="公式"> 恒为正值，则也可以使用ReLU激活函数，这些具体情况具体分析。</p><h3 id="3-3-激活函数的导数"><a href="#3-3-激活函数的导数" class="headerlink" title="3.3 激活函数的导数"></a>3.3 激活函数的导数</h3><p>我们来看一下不同激活函数的导数，这将在我们反向传播中频繁用到。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d38028def5728926f3dbe1c104b6b32e.png" alt="激活函数"></p><h2 id="4-神经网络的梯度下降法"><a href="#4-神经网络的梯度下降法" class="headerlink" title="4.神经网络的梯度下降法"></a>4.神经网络的梯度下降法</h2><p>下面我们来一起看看，神经网络中的梯度计算。</p><p>我们依旧以浅层神经网络为例，它包含的参数为 <img src="https://www.zhihu.com/equation?tex=W%5E%7B%5B1%5D%7D" alt="公式"> ， <img src="https://www.zhihu.com/equation?tex=b%5E%7B%5B1%5D%7D" alt="公式"> ， <img src="https://www.zhihu.com/equation?tex=W%5E%7B%5B2%5D%7D" alt="公式"> ， <img src="https://www.zhihu.com/equation?tex=b%5E%7B%5B2%5D%7D" alt="公式"> 。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2480a21c2bf56c54d958dfca514dd103.png" alt="神经网络的梯度下降法"></p><p>令输入层的特征向量个数 <img src="https://www.zhihu.com/equation?tex=n_x=n%5E%7B%5B0%5D%7D" alt="公式"> ，隐藏层神经元个数为 <img src="https://www.zhihu.com/equation?tex=n%5E%7B%5B1%5D%7D" alt="公式"> ，输出层神经元个数为 <img src="https://www.zhihu.com/equation?tex=n%5E%7B%5B2%5D%7D=1" alt="公式"> 。则：</p><ul><li><img src="https://www.zhihu.com/equation?tex=W%5E%7B%5B1%5D%7D" alt="公式"> 的维度为 <img src="https://www.zhihu.com/equation?tex=(n%5E%7B%5B1%5D%7D,n%5E%7B%5B0%5D%7D)" alt="公式"></li><li><img src="https://www.zhihu.com/equation?tex=b%5E%7B%5B1%5D%7D" alt="公式"> 的维度为 <img src="https://www.zhihu.com/equation?tex=(n%5E%7B%5B1%5D%7D,1)" alt="公式"></li><li><img src="https://www.zhihu.com/equation?tex=W%5E%7B%5B2%5D%7D" alt="公式"> 的维度为 <img src="https://www.zhihu.com/equation?tex=(n%5E%7B%5B2%5D%7D,n%5E%7B%5B1%5D%7D)" alt="公式"></li><li><img src="https://www.zhihu.com/equation?tex=b%5E%7B%5B2%5D%7D" alt="公式"> 的维度为 <img src="https://www.zhihu.com/equation?tex=(n%5E%7B%5B2%5D%7D,1)" alt="公式"></li></ul><h3 id="4-1-神经网络中的梯度下降"><a href="#4-1-神经网络中的梯度下降" class="headerlink" title="4.1 神经网络中的梯度下降"></a>4.1 神经网络中的梯度下降</h3><p>上述神经网络的<strong>前向传播</strong>过程，对应的公式如<strong>下图左侧</strong>。反向传播过程，我们会进行梯度计算，我们先列出Cost Function对各个参数的梯度，如<strong>下图右侧</strong>公式。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/4176b00f4d09fe1c10170db797f57863.png" alt="神经网络的梯度下降法"></p><p>其中，<code>np.sum</code>使用到python中的numpy工具库。</p><h3 id="4-2-反向传播（拓展补充）"><a href="#4-2-反向传播（拓展补充）" class="headerlink" title="4.2 反向传播（拓展补充）"></a>4.2 反向传播（拓展补充）</h3><p>我们使用上篇内容 <a href="https://www.showmeai.tech/article-detail/213"><strong>神经网络基础</strong></a> 中的计算图方式来推导神经网络反向传播。回忆我们前面提到的逻辑回归，推导前向传播和反向传播的计算图如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3d94a8afab2bf72764ebc6b780a25b27.png" alt="神经网络的梯度下降法"></p><p>因为多了隐藏层，神经网络的计算图要比逻辑回归的复杂一些，如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/8f998ffd676240193dae921c5988e821.png" alt="神经网络的梯度下降法"></p><p>综上，对于浅层神经网络（包含一个隐藏层）而言，「<strong>单个样本</strong>」和「<strong>m个训练样本</strong>」的反向传播过程分别对应如下的6个表达式（都是向量化矩阵形式）：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/96dc9a77b00d2ed723bc11a50c60e2da.png" alt="神经网络的梯度下降法"></p><h2 id="5-随机初始化"><a href="#5-随机初始化" class="headerlink" title="5.随机初始化"></a>5.随机初始化</h2><h3 id="5-1-全零初始化权重问题"><a href="#5-1-全零初始化权重问题" class="headerlink" title="5.1 全零初始化权重问题"></a>5.1 全零初始化权重问题</h3><p>我们在很多机器学习模型中，会初始化权重为0。但在神经网络模型中，参数权重 <img src="https://www.zhihu.com/equation?tex=W" alt="公式"> 是不能全部初始化为零的，它会带来对称性问题 (symmetry breaking problem) ，下面是分析过程。</p><p>假设一个浅层神经网络包含两个输入，隐藏层包含两个神经元。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0aaa9c8a7430a3f4d9cc80a0ffc6be1e.png" alt="NN权重初始化"></p><p>如果权重 <img src="https://www.zhihu.com/equation?tex=W%5E%7B%5B1%5D%7D" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=W%5E%7B%5B2%5D%7D" alt="公式"> 都初始化为零，这样使得隐藏层第一个神经元的输出等于第二个神经元的输出，即 <img src="https://www.zhihu.com/equation?tex=a_1%5E%7B%5B1%5D%7D=a_2%5E%7B%5B1%5D%7D" alt="公式"> 。容易得到 <img src="https://www.zhihu.com/equation?tex=dz_1%5E%7B%5B1%5D%7D=dz_2%5E%7B%5B1%5D%7D" alt="公式"> ，以及 <img src="https://www.zhihu.com/equation?tex=dW_1%5E%7B%5B1%5D%7D=dW_2%5E%7B%5B1%5D%7D" alt="公式"> 。</p><p>我们发现：隐藏层两个神经元对应的权重行向量 <img src="https://www.zhihu.com/equation?tex=W_1%5E%7B%5B1%5D%7D" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=W_2%5E%7B%5B1%5D%7D" alt="公式"> 每次迭代更新都会得到完全相同的结果， <img src="https://www.zhihu.com/equation?tex=W_1%5E%7B%5B1%5D%7D" alt="公式"> 始终等于 <img src="https://www.zhihu.com/equation?tex=W_2%5E%7B%5B1%5D%7D" alt="公式"> ，完全对称！这样隐藏层设置多个神经元就没有任何意义了。</p><p>当然，因为中间层每次只会有1个偏置项参数 <img src="https://www.zhihu.com/equation?tex=b" alt="公式"> ，它可以全部初始化为零，并不会影响神经网络训练效果。</p><h3 id="5-2-解决方法"><a href="#5-2-解决方法" class="headerlink" title="5.2 解决方法"></a>5.2 解决方法</h3><p>上述提到的权重W全部初始化为零带来的问题就是symmetry breaking problem (对称性) 。解决方法也很简单：在初始化的时候， <img src="https://www.zhihu.com/equation?tex=W" alt="公式"> 参数要进行随机初始化，不可以设置为0。而 <img src="https://www.zhihu.com/equation?tex=b" alt="公式"> 因为不存在对称性的问题，可以设置为 0。</p><p>以 2 个输入，2 个隐藏神经元为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W = np.random.rand (2,2) * 0.01b = np.zeros ( (2,1) )</span><br></pre></td></tr></table></figure><p>这里将 <img src="https://www.zhihu.com/equation?tex=W" alt="公式"> 的值乘以 0.01 (或者其他的常数值) 的原因是为了使得权重 <img src="https://www.zhihu.com/equation?tex=W" alt="公式"> 初始化为较小的值，这是因为使用 Sigmoid 函数或者 tanh 函数作为激活函数时：</p><ul><li>若 <img src="https://www.zhihu.com/equation?tex=W" alt="公式"> 比较小，则 <img src="https://www.zhihu.com/equation?tex=Z=WX+b" alt="公式"> 所得的值趋近于 0，梯度较大，能够提高算法的更新速度。</li><li>若 <img src="https://www.zhihu.com/equation?tex=W" alt="公式"> 设置的太大，得到的梯度较小，训练过程因此会变得很慢。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/dc92e1cb42dc0dfabec153c2dde842bc.png" alt="NN权重初始化"></p><p>ReLU 和 Leaky ReLU 作为激活函数时不存在这种问题，因为在大于 0 的时候，梯度均为 1。如果输出层是 Sigmoid 函数，则对应的权重 <img src="https://www.zhihu.com/equation?tex=W" alt="公式"> 最好初始化到比较小的值</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell笔记</title>
      <link href="/2023/08/02/shell%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/08/02/shell%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h1 id="第1章-Shell概述"><a href="#第1章-Shell概述" class="headerlink" title="第1章 Shell概述"></a>第1章 Shell概述</h1><p><img src="https://img-blog.csdnimg.cn/c06d9693a5ca45179c1cf7c10c66f58b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5aSn5pWw5o2uX-Wwj-iigQ==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h1 id="第2章-Shell解析器"><a href="#第2章-Shell解析器" class="headerlink" title="第2章 Shell解析器"></a>第2章 Shell解析器</h1><p>（1）Linux提供的Shell解析器有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]$ <span class="built_in">cat</span> /etc/shells </span><br><span class="line">/bin/sh <span class="comment">#是bash的一个快捷方式 </span></span><br><span class="line">/bin/bash <span class="comment">#bash是大多数Linux默认的shell，包含的功能几乎可以涵盖shell所有的功能 </span></span><br><span class="line">/sbin/nologin <span class="comment">#表示非交互，不能登录操作系统 </span></span><br><span class="line">/bin/dash <span class="comment">#小巧，高效，功能相比少一些 </span></span><br><span class="line">/bin/csh <span class="comment">#具有C语言风格的一种shell，具有许多特性，但也有一些缺陷</span></span><br><span class="line">/bin/tcsh <span class="comment">#是csh的增强版，完全兼容csh</span></span><br></pre></td></tr></table></figure><p>（2）bash和sh的关系</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master bin]$ ll | grep bash</span><br><span class="line">-rwxr-xr-x. 1 root root 941880 5月  11 2016 bash</span><br><span class="line">lrwxrwxrwx. 1 root root      4 5月  27 2017 sh -&gt; bash</span><br></pre></td></tr></table></figure><p>（3）Centos默认的解析器是bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master bin]$ <span class="built_in">echo</span> <span class="variable">$SHELL</span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure><h1 id="第3章-Shell脚本入门"><a href="#第3章-Shell脚本入门" class="headerlink" title="第3章 Shell脚本入门"></a>第3章 Shell脚本入门</h1><p><strong>1）脚本格式</strong></p><p>脚本以<code>#!/bin/bash</code>开头（指定解析器）</p><p><strong>2）第一个Shell脚本：helloworld</strong></p><p>（1）需求：创建一个Shell脚本，输出helloworld</p><p>（2）案例实操：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">touch</span> helloworld.sh</span><br><span class="line">[root@master datas]$ vi helloworld.sh</span><br></pre></td></tr></table></figure><p>在helloworld.sh中输入如下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;helloworld&quot;</span></span><br></pre></td></tr></table></figure><p>（3）脚本的常用执行方式</p><blockquote><p>第一种：采用bash或sh+脚本的相对路径或绝对路径（不用赋予脚本+x权限）</p></blockquote><ul><li><p>sh+脚本的相对路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ sh helloworld.sh </span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure></li><li><p>sh+脚本的绝对路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ sh /home/atguigu/datas/helloworld.sh </span><br><span class="line">helloworld</span><br></pre></td></tr></table></figure></li><li><p>bash+脚本的相对路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ bash helloworld.sh </span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure></li><li><p>bash+脚本的绝对路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ bash /home/atguigu/datas/helloworld.sh </span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>第二种：采用输入脚本的绝对路径或相对路径执行脚本（必须具有可执行权限+x）</p></blockquote><p>（a）首先要赋予helloworld.sh 脚本的+x权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">chmod</span> 777 helloworld.sh</span><br></pre></td></tr></table></figure><p>（b）执行脚本</p><ul><li><p>相对路径（推荐使用）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ ./helloworld.sh </span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure></li><li><p>绝对路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ /home/atguigu/datas/helloworld.sh </span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：第一种执行方法，本质是bash解析器帮你执行脚本，所以脚本本身不需要执行权限。第二种执行方法，本质是脚本需要自己执行，所以需要执行权限</span><br></pre></td></tr></table></figure><p><strong>3）第二个Shell脚本：多命令处理</strong></p><p>（1）需求： 在&#x2F;home&#x2F;atguigu&#x2F;目录下创建一个cls.txt,在cls.txt文件中增加“I love cls”。</p><p>（2）案例实操：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">touch</span> batch.sh</span><br><span class="line">[root@master datas]$ vi batch.sh</span><br></pre></td></tr></table></figure><p>在batch.sh中输入如下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /home/atguigu</span><br><span class="line"><span class="built_in">touch</span> cls.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;I love cls&quot;</span> &gt;&gt;cls.txt</span><br></pre></td></tr></table></figure><h1 id="第4章-Shell中的变量"><a href="#第4章-Shell中的变量" class="headerlink" title="第4章 Shell中的变量"></a>第4章 Shell中的变量</h1><h2 id="4-1-系统变量"><a href="#4-1-系统变量" class="headerlink" title="4.1 系统变量"></a>4.1 系统变量</h2><p><strong>1）常用系统变量</strong></p><p>HOME、<em>H<strong>O</strong>M**E</em>、PWD、SHELL、<em>S<strong>H</strong>E<strong>L</strong>L</em>、USER等</p><p><strong>2）案例实操</strong></p><p>（1）查看系统变量的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">echo</span> <span class="variable">$HOME</span></span><br><span class="line">/home/atguigu</span><br></pre></td></tr></table></figure><p>（2）显示当前Shell中所有变量：set</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">set</span></span><br><span class="line">BASH=/bin/bash</span><br><span class="line">BASH_ALIASES=()</span><br><span class="line">BASH_ARGC=()</span><br><span class="line">BASH_ARGV=()</span><br></pre></td></tr></table></figure><h2 id="4-2-自定义变量"><a href="#4-2-自定义变量" class="headerlink" title="4.2 自定义变量"></a>4.2 自定义变量</h2><p><strong>1．基本语法</strong></p><p>（1）定义变量：变量&#x3D;值</p><p>（2）撤销变量：unset 变量</p><p>（3）声明静态变量：readonly 变量，注意：不能unset</p><p><strong>2．变量定义规则</strong></p><p>（1）变量名称可以由字母、数字和下划线组成，但是不能以数字开头，<code>环境变量名建议大写</code></p><p>（2）<code>等号两侧不能有空格!</code></p><p>（3）在bash中，变量默认类型都是字符串类型，无法直接进行数值运算。</p><p>（4）变量的值如果有空格，需要使用双引号或单引号括起来。</p><p><strong>3．案例实操</strong></p><p>（1）定义变量A</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ A=5</span><br><span class="line">[root@master datas]$ <span class="built_in">echo</span> <span class="variable">$A</span></span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>（2）给变量A重新赋值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ A=8</span><br><span class="line">[root@master datas]$ <span class="built_in">echo</span> <span class="variable">$A</span></span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>（3）撤销变量A</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">unset</span> A</span><br><span class="line">[root@master datas]$ <span class="built_in">echo</span> <span class="variable">$A</span></span><br></pre></td></tr></table></figure><p>（4）声明静态的变量B&#x3D;2，不能unset（重启自动消失）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">readonly</span> B=2</span><br><span class="line">[root@master datas]$ <span class="built_in">echo</span> <span class="variable">$B</span></span><br><span class="line">2</span><br><span class="line">[root@master datas]$ B=9</span><br><span class="line">-bash: B: <span class="built_in">readonly</span> variable</span><br></pre></td></tr></table></figure><p>（5）在bash中，变量默认类型都是字符串类型，无法直接进行数值运算</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]$ C=1+2</span><br><span class="line">[root@master ~]$ <span class="built_in">echo</span> <span class="variable">$C</span></span><br><span class="line">1+2</span><br></pre></td></tr></table></figure><p>（6）变量的值如果有空格，需要使用双引号或单引号括起来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]$ D=I love banzhang</span><br><span class="line">-bash: world: <span class="built_in">command</span> not found</span><br><span class="line">[root@master ~]$ D=<span class="string">&quot;I love banzhang&quot;</span></span><br><span class="line">[root@master ~]$ <span class="built_in">echo</span> <span class="variable">$D</span></span><br><span class="line">I love banzhang</span><br></pre></td></tr></table></figure><p>（7）可把变量提升为全局环境变量，可供其他Shell程序使用</p><p>格式：export 变量名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ vim helloworld.sh </span><br></pre></td></tr></table></figure><p>在helloworld.sh文件中增加echo $B</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;helloworld&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$B</span></span><br><span class="line">[root@master datas]$ ./helloworld.sh </span><br><span class="line">Helloworld</span><br></pre></td></tr></table></figure><p>发现并没有打印输出变量B的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">export</span> B</span><br><span class="line">[root@master datas]$ ./helloworld.sh </span><br><span class="line">helloworld</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="4-3-特殊变量：-n"><a href="#4-3-特殊变量：-n" class="headerlink" title="4.3 特殊变量：$n"></a>4.3 特殊变量：$n</h2><p><strong>1．基本语法</strong></p><blockquote><p><code>$n</code>（功能描述：n为数字，<code>$0</code>代表该脚本名称，<code>$1-$9</code>代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如<code>$&#123;10&#125;</code>）</p></blockquote><p><strong>2．案例实操</strong></p><p>（1）输出该脚本文件名称、输入参数1和输入参数2 的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">touch</span> parameter.sh </span><br><span class="line">[root@master datas]$ vim parameter.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$0</span>  <span class="variable">$1</span>  <span class="variable">$2</span>&quot;</span></span><br><span class="line"></span><br><span class="line">[root@master datas]$ <span class="built_in">chmod</span> 777 parameter.sh</span><br><span class="line"></span><br><span class="line">[root@master datas]$ ./parameter.sh 1 2</span><br><span class="line">parameter.sh  1 2</span><br></pre></td></tr></table></figure><h2 id="4-4-特殊变量："><a href="#4-4-特殊变量：" class="headerlink" title="4.4 特殊变量：$#"></a>4.4 特殊变量：$#</h2><p><strong>1．基本语法</strong></p><blockquote><p><code>$#</code> （功能描述：获取所有输入参数个数，常用于循环）。</p></blockquote><p><strong>2．案例实操</strong></p><p>（1）获取输入参数的个数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ vim parameter.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$0</span>  <span class="variable">$1</span>   <span class="variable">$2</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$#</span></span><br><span class="line"></span><br><span class="line">[root@master datas]$ <span class="built_in">chmod</span> 777 parameter.sh</span><br><span class="line"></span><br><span class="line">[root@master datas]$ ./parameter.sh cls  xz</span><br><span class="line">parameter.sh cls xz </span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="4-5-特殊变量：-、"><a href="#4-5-特殊变量：-、" class="headerlink" title="4.5 特殊变量：$*、$@"></a>4.5 特殊变量：<code>$*、$@</code></h2><p><strong>1．基本语法</strong></p><blockquote><p><code>$*</code> （功能描述：这个变量代表命令行中所有的参数，<code>$*</code>把所有的参数看成一个整体）<br><code>$@</code> （功能描述：这个变量也代表命令行中所有的参数，不过<code>$@</code>把每个参数区分对待）</p></blockquote><p><strong>2．案例实操</strong></p><p>（1）打印输入的所有参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ vim parameter.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$0</span>  <span class="variable">$1</span>   <span class="variable">$2</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$#</span></span><br><span class="line"><span class="built_in">echo</span> $*</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">[root@master datas]$ bash parameter.sh 1 2 3</span><br><span class="line">parameter.sh  1   2</span><br><span class="line">3</span><br><span class="line">1 2 3</span><br><span class="line">1 2 3</span><br></pre></td></tr></table></figure><h2 id="4-6-特殊变量：-？"><a href="#4-6-特殊变量：-？" class="headerlink" title="4.6 特殊变量：$？"></a>4.6 特殊变量：$？</h2><p><strong>1．基本语法</strong></p><blockquote><p><code>$？</code> （功能描述：最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0（具体是哪个数，由命令自己来决定），则证明上一个命令执行不正确了。）</p></blockquote><p><strong>2．案例实操</strong></p><p>（1）判断helloworld.sh脚本是否正确执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ ./helloworld.sh </span><br><span class="line">hello world</span><br><span class="line">[root@master datas]$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h1 id="第5章-运算符"><a href="#第5章-运算符" class="headerlink" title="第5章 运算符"></a>第5章 运算符</h1><p><strong>1．基本语法</strong></p><p>（1）“<code>$((运算式))</code>”或“<code>$[运算式]</code>”</p><p>（2）expr + , - , *, &#x2F;, % 加，减，乘，除，取余</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：expr运算符间要有空格</span><br></pre></td></tr></table></figure><p><strong>2．案例实操：</strong></p><p>（1）计算3+2的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">expr</span> 2 + 3</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>（2）计算3-2的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">expr</span> 3 - 2 </span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>（3）计算（2+3）X 4的值</p><ul><li><p>（a）expr一步完成计算</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">expr</span> `<span class="built_in">expr</span> 2 + 3` \* 4 <span class="comment">#这个小·是tab上面那个键，不是单引号</span></span><br><span class="line">20</span><br></pre></td></tr></table></figure></li><li><p>（b）采用<code>$</code>[运算式]方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ S=$[(2+3)*4]</span><br><span class="line">[root@master datas]$ <span class="built_in">echo</span> <span class="variable">$S</span></span><br><span class="line">20</span><br></pre></td></tr></table></figure></li></ul><h1 id="第6章-条件判断"><a href="#第6章-条件判断" class="headerlink" title="第6章 条件判断"></a>第6章 条件判断</h1><p><strong>1．基本语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ condition ]（`注意condition前后要有空格`）</span><br></pre></td></tr></table></figure><p>注意：条件非空即为true，[ atguigu ]返回true，[] 返回false。</p><p><strong>2.常用判断条件</strong></p><p>（1）两个整数之间比较</p><ul><li>&#x3D; 字符串比较</li><li>-lt 小于（less than）</li><li>-le 小于等于（less equal）</li><li>-eq 等于（equal）</li><li>-gt 大于（greater than）</li><li>-ge 大于等于（greater equal）</li><li>-ne 不等于（Not equal）</li></ul><p>（2）按照文件权限进行判断</p><ul><li>-r 有读的权限（read）</li><li>-w 有写的权限（write）</li><li>-x 有执行的权限（execute）</li></ul><p>（3）按照文件类型进行判断</p><ul><li>-f 文件存在并且是一个常规的文件（file）</li><li>-e 文件存在（existence）</li><li>-d 文件存在并是一个目录（directory）</li></ul><p>3．案例实操</p><p>（1）23是否大于等于22</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ [ 23 -ge 22 ]</span><br><span class="line">[root@master datas]$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>（2）helloworld.sh是否具有写权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ [ -w helloworld.sh ]</span><br><span class="line">[root@master datas]$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>（3）&#x2F;home&#x2F;atguigu&#x2F;cls.txt目录中的文件是否存在</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ [ -e /home/atguigu/cls.txt ]</span><br><span class="line">[root@master datas]$ <span class="built_in">echo</span> $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>（4）多条件判断（&amp;&amp; 表示前一条命令执行成功时，才执行后一条命令，|| 表示上一条命令执行失败后，才执行下一条命令）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ [ condition ] &amp;&amp; <span class="built_in">echo</span> OK || <span class="built_in">echo</span> notok</span><br><span class="line">OK</span><br><span class="line">[root@master datas]$ [ condition ] &amp;&amp; [ ] || <span class="built_in">echo</span> notok</span><br><span class="line">notok</span><br></pre></td></tr></table></figure><h1 id="第7章-流程控制（重点）"><a href="#第7章-流程控制（重点）" class="headerlink" title="第7章 流程控制（重点）"></a>第7章 流程控制（重点）</h1><h2 id="7-1-if-判断"><a href="#7-1-if-判断" class="headerlink" title="7.1 if 判断"></a>7.1 if 判断</h2><p><strong>1．基本语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件判断式 ];<span class="keyword">then</span> </span><br><span class="line">  程序 </span><br><span class="line"><span class="keyword">fi</span> </span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件判断式 ] </span><br><span class="line">  <span class="keyword">then</span> </span><br><span class="line">    程序 </span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><code>注意事项</code>：</p><ul><li>[ 条件判断式 ]，中括号和条件判断式之间必须有空格</li><li>if 后要有空格</li></ul><p><strong>2．案例实操</strong></p><p>（1）输入一个数字，如果是1，则输出banzhang zhen shuai，如果是2，则输出cls zhen mei，如果是其它，什么也不输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">touch</span> if.sh</span><br><span class="line">[root@master datas]$ vim if.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$1</span> -eq <span class="string">&quot;1&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;banzhang zhen shuai&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="variable">$1</span> -eq <span class="string">&quot;2&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;cls zhen mei&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">[root@master datas]$ <span class="built_in">chmod</span> 777 if.sh </span><br><span class="line">[root@master datas]$ ./if.sh 1</span><br><span class="line">banzhang zhen shuai</span><br></pre></td></tr></table></figure><h2 id="7-2-case-语句"><a href="#7-2-case-语句" class="headerlink" title="7.2 case 语句"></a>7.2 case 语句</h2><p><strong>1．基本语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> $变量名 <span class="keyword">in</span> </span><br><span class="line">  <span class="string">&quot;值1&quot;</span>） </span><br><span class="line">    如果变量的值等于值1，则执行程序1 </span><br><span class="line">    ;; </span><br><span class="line">  <span class="string">&quot;值2&quot;</span>） </span><br><span class="line">    如果变量的值等于值2，则执行程序2 </span><br><span class="line">    ;; </span><br><span class="line">  …省略其他分支… </span><br><span class="line">  *） </span><br><span class="line">    如果变量的值都不是以上的值，则执行此程序 </span><br><span class="line">    ;; </span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p><code>注意事项</code>：</p><ul><li>case行尾必须为单词“<code>in</code>”，每一个模式匹配必须以右括号“<code>)</code>”结束。</li><li>双分号“<code>;;</code>”表示命令序列结束，相当于java中的break。</li><li>最后的“<code>*</code>）”表示默认模式，相当于java中的default。</li></ul><p><strong>2．案例实操</strong></p><p>（1）输入一个数字，如果是1，则输出banzhang，如果是2，则输出cls，如果是其它，输出renyao。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">touch</span> case.sh</span><br><span class="line">[root@master datas]$ vim case.sh</span><br><span class="line"></span><br><span class="line">!/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line"><span class="string">&quot;1&quot;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;banzhang&quot;</span></span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;2&quot;</span>)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;cls&quot;</span></span><br><span class="line">;;</span><br><span class="line"></span><br><span class="line">*)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;renyao&quot;</span></span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"></span><br><span class="line">[root@master datas]$ <span class="built_in">chmod</span> 777 case.sh</span><br><span class="line">[root@master datas]$ ./case.sh 1</span><br><span class="line">banzhang</span><br></pre></td></tr></table></figure><h2 id="7-3-for-循环"><a href="#7-3-for-循环" class="headerlink" title="7.3 for 循环"></a>7.3 for 循环</h2><p><strong>1．基本语法1</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (( 初始值;循环控制条件;变量变化 )) </span><br><span class="line">  <span class="keyword">do</span> </span><br><span class="line">    程序 </span><br><span class="line">  <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>2．案例实操</strong></p><p>（1）从1加到100</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">touch</span> for1.sh</span><br><span class="line">[root@master datas]$ vim for1.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">s=0</span><br><span class="line"><span class="keyword">for</span>((i=<span class="number">0</span>;i&lt;=<span class="number">100</span>;i++))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        s=$[<span class="variable">$s</span>+<span class="variable">$i</span>]</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$s</span></span><br><span class="line"></span><br><span class="line">[root@master datas]$ <span class="built_in">chmod</span> 777 for1.sh </span><br><span class="line">[root@master datas]$ ./for1.sh </span><br><span class="line">5050</span><br></pre></td></tr></table></figure><p><strong>3．基本语法2</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 值1 值2 值3… </span><br><span class="line">  <span class="keyword">do</span> </span><br><span class="line">    程序 </span><br><span class="line">  <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>4．案例实操</strong></p><p>（1）打印所有输入参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">touch</span> for2.sh</span><br><span class="line">[root@master datas]$ vim for2.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment">#打印数字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $*</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;ban zhang love <span class="variable">$i</span> &quot;</span></span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">[root@master datas]$ <span class="built_in">chmod</span> 777 for2.sh </span><br><span class="line">[root@master datas]$ bash for2.sh cls xz bd</span><br><span class="line">ban zhang love cls</span><br><span class="line">ban zhang love xz</span><br><span class="line">ban zhang love b</span><br></pre></td></tr></table></figure><p>（2）比较<code>$*</code>和<code>$@</code>区别</p><ul><li><p>（a）<code>$*</code>和<code>$@</code>都表示传递给函数或脚本的所有参数，不被双引号“”包含时，都以<code>$1 $2 …$n</code>的形式输出所有参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">touch</span> for.sh</span><br><span class="line">[root@master datas]$ vim for.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;ban zhang love <span class="variable">$i</span> &quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="variable">$@</span></span><br><span class="line"><span class="keyword">do</span>      </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;ban zhang love <span class="variable">$j</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">[root@master datas]$ bash for.sh cls xz bd</span><br><span class="line">ban zhang love cls </span><br><span class="line">ban zhang love xz </span><br><span class="line">ban zhang love bd </span><br><span class="line">ban zhang love cls</span><br><span class="line">ban zhang love xz</span><br><span class="line">ban zhang love bd</span><br></pre></td></tr></table></figure></li><li><p>（b）当它们被双引号“”包含时，“<code>$*</code>”会将所有的参数作为一个整体，以“<code>$1 $2 …$n</code>”的形式输出所有参数；“<code>$@</code>”还是会将各个参数分开，以<code>“$1” “$2”…”$n”</code>的形式输出所有参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ vim for.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;$*&quot;</span> </span><br><span class="line"><span class="comment">#$*中的所有参数看成是一个整体，所以这个for循环只会循环一次 </span></span><br><span class="line">        <span class="keyword">do</span> </span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;ban zhang love <span class="variable">$i</span>&quot;</span></span><br><span class="line">        <span class="keyword">done</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span> </span><br><span class="line"><span class="comment">#$@中的每个参数都看成是独立的，所以“$@”中有几个参数，就会循环几次 </span></span><br><span class="line">        <span class="keyword">do</span> </span><br><span class="line">                <span class="built_in">echo</span> <span class="string">&quot;ban zhang love <span class="variable">$j</span>&quot;</span> </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">[root@master datas]$ <span class="built_in">chmod</span> 777 for.sh</span><br><span class="line">[root@master datas]$ bash for.sh cls xz bd</span><br><span class="line">ban zhang love cls xz bd</span><br><span class="line">ban zhang love cls</span><br><span class="line">ban zhang love xz</span><br><span class="line">ban zhang love bd</span><br></pre></td></tr></table></figure></li></ul><h2 id="7-4-while-循环"><a href="#7-4-while-循环" class="headerlink" title="7.4 while 循环"></a>7.4 while 循环</h2><p><strong>1．基本语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ 条件判断式 ] </span><br><span class="line">  <span class="keyword">do</span> </span><br><span class="line">    程序</span><br><span class="line">  <span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>2．案例实操</strong></p><p>（1）从1加到100</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">touch</span> while.sh</span><br><span class="line">[root@master datas]$ vim while.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">s=0</span><br><span class="line">i=1</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$i</span> -le 100 ] <span class="comment">#i的值小于100，并不是i小于100，所以用$i</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">        s=$[<span class="variable">$s</span>+<span class="variable">$i</span>]</span><br><span class="line">        i=$[<span class="variable">$i</span>+1]</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$s</span></span><br><span class="line"></span><br><span class="line">[root@master datas]$ <span class="built_in">chmod</span> 777 while.sh </span><br><span class="line">[root@master datas]$ ./while.sh </span><br><span class="line">5050</span><br></pre></td></tr></table></figure><h1 id="第8章-read读取控制台输入"><a href="#第8章-read读取控制台输入" class="headerlink" title="第8章 read读取控制台输入"></a>第8章 read读取控制台输入</h1><p><strong>1．基本语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>(选项)(参数)</span><br></pre></td></tr></table></figure><p>选项：</p><ul><li>-p：指定读取值时的提示符；</li><li>-t：指定读取值时等待的时间（秒）。</li></ul><p>参数</p><ul><li>变量：指定读取值的变量名</li></ul><p><strong>2．案例实操</strong></p><p>（1）提示7秒内，读取控制台输入的名称</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">touch</span> read.sh</span><br><span class="line">[root@master datas]$ vim read.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -t 7 -p <span class="string">&quot;Enter your name in 7 seconds &quot;</span> NAME</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$NAME</span></span><br><span class="line"></span><br><span class="line">[root@master datas]$ ./read.sh </span><br><span class="line">Enter your name <span class="keyword">in</span> 7 seconds xiaoze</span><br><span class="line">xiaoze</span><br></pre></td></tr></table></figure><h1 id="第9章-函数"><a href="#第9章-函数" class="headerlink" title="第9章 函数"></a>第9章 函数</h1><h2 id="9-1-系统函数"><a href="#9-1-系统函数" class="headerlink" title="9.1 系统函数"></a>9.1 系统函数</h2><p><strong>1．basename基本语法</strong>（返回文件名）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">basename</span> [string / pathname] [suffix]  </span><br></pre></td></tr></table></figure><p>（功能描述：basename命令会删掉所有的前缀包括最后一个（‘&#x2F;’）字符，然后将字符串显示出来。</p><p>选项：suffix为后缀，如果suffix被指定了，basename会将pathname或string中的suffix去掉。</p><p><strong>2．案例实操</strong></p><p>（1）截取该&#x2F;home&#x2F;atguigu&#x2F;banzhang.txt路径的文件名称</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">basename</span> /home/atguigu/banzhang.txt </span><br><span class="line">banzhang.txt</span><br><span class="line">[root@master datas]$ <span class="built_in">basename</span> /home/atguigu/banzhang.txt .txt</span><br><span class="line">banzhang</span><br></pre></td></tr></table></figure><p><strong>3 . dirname基本语法</strong>（返回路径）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dirname</span> 文件绝对路径</span><br></pre></td></tr></table></figure><p>（功能描述：从给定的包含绝对路径的文件名中去除文件名（非目录的部分），然后返回剩下的路径（目录的部分））</p><p><strong>4．案例实操</strong></p><p>（1）获取banzhang.txt文件的路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]$ <span class="built_in">dirname</span> /home/atguigu/banzhang.txt </span><br><span class="line">/home/atguigu</span><br></pre></td></tr></table></figure><h2 id="9-2-自定义函数"><a href="#9-2-自定义函数" class="headerlink" title="9.2 自定义函数"></a>9.2 自定义函数</h2><p><strong>1．基本语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="keyword">function</span> ] funname[()]</span><br><span class="line">&#123;</span><br><span class="line">Action;</span><br><span class="line">[<span class="built_in">return</span> int;]</span><br><span class="line">&#125;</span><br><span class="line">funname</span><br></pre></td></tr></table></figure><p><strong>2．经验技巧</strong></p><ul><li>必须在调用函数地方之前，先声明函数，shell脚本是逐行运行。不会像其它语言一样先编译。</li><li>函数返回值，只能通过<code>$?</code>系统变量获得，可以显示加：return返回，如果不加，将以最后一条命令运行结果，作为返回值。return后跟数值n(0-255)</li></ul><p><strong>3．案例实操</strong></p><p>（1）计算两个输入参数的和</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">touch</span> fun.sh</span><br><span class="line">[root@master datas]$ vim fun.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">sum</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    s=0</span><br><span class="line">    s=$[ <span class="variable">$1</span> + <span class="variable">$2</span> ]</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$s</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Please input the number1: &quot;</span> n1;</span><br><span class="line"><span class="built_in">read</span> -p <span class="string">&quot;Please input the number2: &quot;</span> n2;</span><br><span class="line"><span class="built_in">sum</span> <span class="variable">$n1</span> <span class="variable">$n2</span>;</span><br><span class="line"></span><br><span class="line">[root@master datas]$ <span class="built_in">chmod</span> 777 fun.sh</span><br><span class="line">[root@master datas]$ ./fun.sh </span><br><span class="line">Please input the number1: 2</span><br><span class="line">Please input the number2: 5</span><br><span class="line">7</span><br></pre></td></tr></table></figure><h1 id="第10章-输入-输出重定向"><a href="#第10章-输入-输出重定向" class="headerlink" title="第10章 输入&#x2F;输出重定向"></a>第10章 输入&#x2F;输出重定向</h1><h2 id="10-1-重定向介绍"><a href="#10-1-重定向介绍" class="headerlink" title="10.1 重定向介绍"></a>10.1 重定向介绍</h2><blockquote><p>大多数 UNIX系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。</p></blockquote><p><strong>重定向命令列表如下</strong>：</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>command &gt; file</td><td>将输出重定向到 file</td></tr><tr><td>command &lt; file</td><td>将输入重定向到 file</td></tr><tr><td>command &gt;&gt; file</td><td>将输出以追加的方式重定向到 file</td></tr><tr><td>n &gt; file</td><td>将文件描述符为 n 的文件重定向到 file</td></tr><tr><td>n &gt;&gt; file</td><td>将文件描述符为 n 的文件以追加的方式重定向到 file</td></tr><tr><td>n &gt;&amp; m</td><td>将输出文件 m 和 n 合并</td></tr><tr><td>n &lt;&amp; m</td><td>将输入文件 m 和 n 合并</td></tr><tr><td>&lt;&lt; tag</td><td>将开始标记 tag 和结束标记 tag 之间的内容作为输入</td></tr></tbody></table><p><code>注意</code>：文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）</p><h2 id="10-2-输出重定向"><a href="#10-2-输出重定向" class="headerlink" title="10.2 输出重定向"></a>10.2 输出重定向</h2><p>重定向一般通过在命令间插入特定的符号来实现。特别的，这些符号的语法如下所示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 &gt; file1</span><br></pre></td></tr></table></figure><p>上面这个命令执行command1然后将输出的内容存入file1。</p><p><code>注意</code>：任何file1内的已经存在的内容将被新内容替代。如果要将新内容添加在文件末尾，请使用&gt;&gt;操作符。</p><p><strong>实例</strong>：</p><p>1）执行下面的 who 命令，它将命令的完整的输出重定向在用户文件中(users):</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">who</span> &gt; <span class="built_in">users</span></span><br></pre></td></tr></table></figure><p>执行后，并没有在终端输出信息，这是因为输出已被从默认的标准输出设备（终端）重定向到指定的文件。</p><p>你可以使用 cat 命令查看文件内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> <span class="built_in">users</span></span><br><span class="line">_mbsetupuser console  Oct 31 17:35 </span><br><span class="line">tianqixin    console  Oct 31 17:35 </span><br><span class="line">tianqixin    ttys000  Dec  1 11:33 </span><br></pre></td></tr></table></figure><p>2）输出重定向会覆盖文件内容，请看下面的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;你好！！！&quot;</span> &gt; <span class="built_in">users</span></span><br><span class="line">$ <span class="built_in">cat</span> <span class="built_in">users</span></span><br><span class="line">你好！！</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>3）如果不希望文件内容被覆盖，可以使用 &gt;&gt; 追加到文件末尾，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;你好！！&quot;</span> &gt;&gt; <span class="built_in">users</span></span><br><span class="line">$ <span class="built_in">cat</span> <span class="built_in">users</span></span><br><span class="line">你好！！</span><br><span class="line">你好！！</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h2 id="10-3-输入重定向"><a href="#10-3-输入重定向" class="headerlink" title="10.3 输入重定向"></a>10.3 输入重定向</h2><p>和输出重定向一样，Unix 命令也可以从文件获取输入，语法为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 &lt; file1</span><br></pre></td></tr></table></figure><p>这样，本来需要从键盘获取输入的命令会转移到文件读取内容。</p><p><code>注意</code>：输出重定向是大于号(&gt;)，输入重定向是小于号(&lt;)。</p><p><strong>实例</strong>：</p><p>1）接着以上实例，我们需要统计 users 文件的行数,执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">wc</span> -l <span class="built_in">users</span></span><br><span class="line">       2 <span class="built_in">users</span></span><br></pre></td></tr></table></figure><p>2）也可以将输入重定向到 users 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$  <span class="built_in">wc</span> -l &lt; <span class="built_in">users</span></span><br><span class="line">       2 </span><br></pre></td></tr></table></figure><p><code>注意</code>：上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。</p><p>3）同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 &lt; infile &gt; outfile</span><br></pre></td></tr></table></figure><h2 id="10-4-重定向深入讲解"><a href="#10-4-重定向深入讲解" class="headerlink" title="10.4 重定向深入讲解"></a>10.4 重定向深入讲解</h2><p>一般情况下，每个 Unix&#x2F;Linux 命令运行时都会打开三个文件：</p><ul><li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li><li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li><li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li></ul><p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p><p>如果希望 stderr 重定向到 file，可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">command</span> 2&gt;file</span><br></pre></td></tr></table></figure><p>如果希望 stderr 追加到 file 文件末尾，可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">command</span> 2&gt;&gt;file</span><br></pre></td></tr></table></figure><blockquote><p>2 表示标准错误文件(stderr)。</p></blockquote><p>如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">command</span> &gt; file 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">command</span> &gt;&gt; file 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>如果希望对 stdin 和 stdout 都重定向，可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">command</span> &lt; file1 &gt;file2</span><br></pre></td></tr></table></figure><p>command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。</p><h2 id="10-5-Here-Document"><a href="#10-5-Here-Document" class="headerlink" title="10.5 Here Document"></a>10.5 Here Document</h2><blockquote><p>Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。</p></blockquote><p>它的基本的形式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &lt;&lt; <span class="string">delimiter</span></span><br><span class="line"><span class="string">    document</span></span><br><span class="line"><span class="string">delimiter</span></span><br></pre></td></tr></table></figure><p>它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。</p><p><code>注意</code>：</p><ul><li>结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。</li><li>开始的delimiter前后的空格会被忽略掉。</li></ul><p><strong>实例</strong>：</p><p>1）在命令行中通过 wc -l 命令计算 Here Document 的行数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">wc</span> -l &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">    欢迎</span></span><br><span class="line"><span class="string">    光临</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">2          <span class="comment"># 输出结果为 2 行</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>2）我们也可以将 Here Document 用在脚本中，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">欢迎</span></span><br><span class="line"><span class="string">光临</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p>执行以上脚本，输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">欢迎</span><br><span class="line">光临</span><br></pre></td></tr></table></figure><h2 id="10-6-dev-null-文件"><a href="#10-6-dev-null-文件" class="headerlink" title="10.6 &#x2F;dev&#x2F;null 文件"></a>10.6 &#x2F;dev&#x2F;null 文件</h2><blockquote><p>&#x2F;dev&#x2F;null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 &#x2F;dev&#x2F;null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果。</p></blockquote><p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 &#x2F;dev&#x2F;null：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">command</span> &gt; /dev/null</span><br></pre></td></tr></table></figure><p>如果希望屏蔽 stdout 和 stderr，可以这样写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">command</span> &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p><code>注意</code>：</p><ul><li>0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</li><li>这里的 2 和 &gt; 之间不可以有空格，2&gt; 是一体的时候才表示错误输出。</li></ul><h1 id="第11章-Shell工具（重点）"><a href="#第11章-Shell工具（重点）" class="headerlink" title="第11章 Shell工具（重点）"></a>第11章 Shell工具（重点）</h1><h2 id="11-1-cut"><a href="#11-1-cut" class="headerlink" title="11.1 cut"></a>11.1 cut</h2><blockquote><p>cut 的工作就是“剪”，具体的说就是在文件中负责剪切数据用的。cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段输出。</p></blockquote><p><strong>1.基本用法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cut</span> [选项参数]  filename</span><br></pre></td></tr></table></figure><p>说明：默认分隔符是制表符</p><p><strong>2.选项参数说明</strong></p><table><thead><tr><th>选项参数</th><th>功能</th></tr></thead><tbody><tr><td>-f</td><td>列号，提取第几列</td></tr><tr><td>-d</td><td>分隔符，按照指定分隔符分割列</td></tr></tbody></table><p><strong>3.案例实操</strong></p><p>（0）数据准备</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">touch</span> cut.txt</span><br><span class="line">[root@master datas]$ vim cut.txt</span><br><span class="line">dong shen</span><br><span class="line">guan zhen</span><br><span class="line">wo  wo</span><br><span class="line">lai  lai</span><br><span class="line">le  le</span><br></pre></td></tr></table></figure><p>（1）切割 cut.txt 第一列</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">cut</span> -d <span class="string">&quot; &quot;</span> -f 1 cut.txt </span><br><span class="line">dong</span><br><span class="line">guan</span><br><span class="line">wo</span><br><span class="line">lai</span><br><span class="line">le</span><br></pre></td></tr></table></figure><p>（2）切割 cut.txt 第二、三列</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">cut</span> -d <span class="string">&quot; &quot;</span> -f 2,3 cut.txt </span><br><span class="line">shen</span><br><span class="line">zhen</span><br><span class="line"> wo</span><br><span class="line"> lai</span><br><span class="line"> le</span><br></pre></td></tr></table></figure><p>（3）在 cut.txt 文件中切割出guan</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">cat</span> cut.txt | grep <span class="string">&quot;guan&quot;</span> | <span class="built_in">cut</span> -d <span class="string">&quot; &quot;</span> -f 1</span><br><span class="line">guan</span><br></pre></td></tr></table></figure><p>（4）选取系统PATH变量值，第2个“ ：”开始后的所有路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/usr/lib64/qt-3.3/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/atguigu/bin</span><br><span class="line"></span><br><span class="line">[atguigu@hadoop102 datas]$ <span class="built_in">echo</span> <span class="variable">$PATH</span> | <span class="built_in">cut</span> -d : -f 3- <span class="comment">#3-：表示第三列开始后面的所有</span></span><br><span class="line">/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/atguigu/bin</span><br></pre></td></tr></table></figure><p>（5）切割 ifconfig 后打印的IP地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ ifconfig eth0 | grep <span class="string">&quot;inet addr&quot;</span> | <span class="built_in">cut</span> -d : -f 2 | <span class="built_in">cut</span> -d <span class="string">&quot; &quot;</span> -f1</span><br><span class="line">192.168.1.102</span><br></pre></td></tr></table></figure><h2 id="11-2-sed"><a href="#11-2-sed" class="headerlink" title="11.2 sed"></a>11.2 sed</h2><blockquote><p>sed是一种<code>流</code>编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”，接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。<code>文件内容并没有改变</code>，除非你使用重定向存储输出。</p></blockquote><p><strong>1.基本用法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [选项参数]  ‘<span class="built_in">command</span>’  filename</span><br></pre></td></tr></table></figure><p><strong>2.选项参数说明</strong></p><table><thead><tr><th>选项参数</th><th>功能</th></tr></thead><tbody><tr><td>-e</td><td>直接在指令列模式上进行sed的动作编辑。</td></tr></tbody></table><p><strong>3.命令功能描述</strong></p><table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody><tr><td>a</td><td>新增，a的后面可以接字串，在下一行出现</td></tr><tr><td>d</td><td>删除</td></tr><tr><td>s</td><td>查找并替换</td></tr></tbody></table><p><strong>4.案例实操</strong></p><p>（0）数据准备</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">touch</span> sed.txt</span><br><span class="line">[root@master datas]$ vim sed.txt</span><br><span class="line">dong shen</span><br><span class="line">guan zhen</span><br><span class="line">wo  wo</span><br><span class="line">lai  lai</span><br><span class="line"></span><br><span class="line">le  le</span><br></pre></td></tr></table></figure><p>（1）将“mei nv”这个单词插入到sed.txt第二行下，打印（原文件并不改变）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ sed <span class="string">&#x27;2a mei nv&#x27;</span> sed.txt <span class="comment">#2a：表示第二行下</span></span><br><span class="line">dong shen</span><br><span class="line">guan zhen</span><br><span class="line">mei nv</span><br><span class="line">wo  wo</span><br><span class="line">lai  lai</span><br><span class="line"></span><br><span class="line">le  le</span><br><span class="line">[root@master datas]$ <span class="built_in">cat</span> sed.txt </span><br><span class="line">dong shen</span><br><span class="line">guan zhen</span><br><span class="line">wo  wo</span><br><span class="line">lai  lai</span><br><span class="line"></span><br><span class="line">le  le</span><br><span class="line">注意：文件并没有改变</span><br></pre></td></tr></table></figure><p>（2）删除sed.txt文件所有包含wo的行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ sed <span class="string">&#x27;/wo/d&#x27;</span> sed.txt</span><br><span class="line">dong shen</span><br><span class="line">guan zhen</span><br><span class="line">lai  lai</span><br><span class="line"></span><br><span class="line">le  le</span><br></pre></td></tr></table></figure><p>（3）将sed.txt文件中wo替换为ni</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ sed <span class="string">&#x27;s/wo/ni/g&#x27;</span> sed.txt <span class="comment">#g:表示全局替换</span></span><br><span class="line">dong shen</span><br><span class="line">guan zhen</span><br><span class="line">ni  ni</span><br><span class="line">lai  lai</span><br><span class="line"></span><br><span class="line">le  le</span><br><span class="line">注意：‘g’表示global，全部替换</span><br></pre></td></tr></table></figure><p>（4）将sed.txt文件中的第二行删除并将wo替换为ni</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ sed -e <span class="string">&#x27;2d&#x27;</span> -e <span class="string">&#x27;s/wo/ni/g&#x27;</span> sed.txt  </span><br><span class="line">dong shen</span><br><span class="line">ni  ni</span><br><span class="line">lai  lai</span><br><span class="line"></span><br><span class="line">le  le</span><br></pre></td></tr></table></figure><h2 id="11-3-awk"><a href="#11-3-awk" class="headerlink" title="11.3 awk"></a>11.3 awk</h2><blockquote><p>一个强大的文本分析工具，把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行分析处理。</p></blockquote><p><strong>1.基本用法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk [选项参数] ‘pattern1&#123;action1&#125;  pattern2&#123;action2&#125;...’ filename</span><br></pre></td></tr></table></figure><p>pattern：表示AWK在数据中查找的内容，就是匹配模式<br>action：在找到匹配内容时所执行的一系列命令</p><p><strong>2.选项参数说明</strong></p><table><thead><tr><th>选项参数</th><th>功能</th></tr></thead><tbody><tr><td>-F</td><td>指定输入文件折分隔符（切割符）</td></tr><tr><td>-v</td><td>赋值一个用户定义变量</td></tr></tbody></table><p><strong>3.案例实操</strong><br>（0）原数据<br><img src="https://img-blog.csdnimg.cn/2c75d6639b0b4888af8eb5ba2921576e.png" alt="在这里插入图片描述"></p><p>（1）搜索passwd文件以root关键字开头的所有行，并输出该行的第7列。<code>正则表达式不会的看第13章！！！</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ awk -F : <span class="string">&#x27;/^root/&#123;print $7&#125;&#x27;</span> passwd <span class="comment">#/^：表示开头</span></span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure><p>（2）搜索passwd文件以root关键字开头的所有行，并输出该行的第1列和第7列，中间以“,”号分割。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ awk -F : <span class="string">&#x27;/^root/&#123;print $1&quot;,&quot;$7&#125;&#x27;</span> passwd </span><br><span class="line">root,/bin/bash</span><br><span class="line">注意：只有匹配了pattern的行才会执行action</span><br></pre></td></tr></table></figure><p>（3）只显示&#x2F;etc&#x2F;passwd的第一列和第七列，以逗号分割，且在所有行前面添加列名user，shell在最后一行添加”dahaige，&#x2F;bin&#x2F;zuishuai”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ awk -F : <span class="string">&#x27;BEGIN&#123;print &quot;user, shell&quot;&#125; &#123;print $1&quot;,&quot;$7&#125; END &#123;print &quot;dahaige,/bin/zuishuai&quot;&#125;&#x27;</span> passwd <span class="comment">#BEGIN：表示开头位置</span></span><br><span class="line">user, shell</span><br><span class="line">root,/bin/bash</span><br><span class="line">bin,/sbin/nologin</span><br><span class="line">。。。</span><br><span class="line">atguigu,/bin/bash</span><br><span class="line">dahaige,/bin/zuishuai</span><br><span class="line">注意：BEGIN 在所有数据读取行之前执行；END 在所有数据执行之后执行。</span><br></pre></td></tr></table></figure><p>（4）将passwd文件中的用户id增加数值1并输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ awk -v i=1 -F : <span class="string">&#x27;&#123;print $3+i&#125;&#x27;</span> passwd</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p><strong>4.awk的内置变量</strong></p><table><thead><tr><th>变量</th><th>说明</th></tr></thead><tbody><tr><td>FILENAME</td><td>文件名</td></tr><tr><td>NR</td><td>已读的记录数（行数）</td></tr><tr><td>NF</td><td>浏览记录的域的个数（切割后，列的个数）</td></tr></tbody></table><p><strong>5.案例实操</strong></p><p>（1）统计passwd文件名，每行的行号，每行的列数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ awk -F : <span class="string">&#x27;&#123;print &quot;filename:&quot;  FILENAME &quot;, linenumber:&quot; NR  &quot;,columns:&quot; NF&#125;&#x27;</span> passwd </span><br><span class="line">filename:passwd, linenumber:1,columns:7</span><br><span class="line">filename:passwd, linenumber:2,columns:7</span><br><span class="line">filename:passwd, linenumber:3,columns:7</span><br></pre></td></tr></table></figure><p>（2）切割IP</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ ifconfig eth0 | grep <span class="string">&quot;inet addr&quot;</span> | awk -F : <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | awk -F <span class="string">&quot; &quot;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> </span><br><span class="line">192.168.1.102</span><br></pre></td></tr></table></figure><p>（3）查询sed.txt中空行所在的行号</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ awk <span class="string">&#x27;/^$/&#123;print NR&#125;&#x27;</span> sed.txt <span class="comment">#/^$：表示空行</span></span><br><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="11-4-sort"><a href="#11-4-sort" class="headerlink" title="11.4 sort"></a>11.4 sort</h2><blockquote><p>sort命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。</p></blockquote><p><strong>1.基本语法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(选项)(参数) filename</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-n</td><td>依照数值的大小排序</td></tr><tr><td>-r</td><td>以相反的顺序来排序</td></tr><tr><td>-t</td><td>设置排序时所用的分隔字符</td></tr><tr><td>-k</td><td>指定需要排序的列</td></tr></tbody></table><p>参数：指定待排序的文件列表</p><p><strong>2 . 案例实操</strong></p><p>（0）数据准备</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">touch</span> sort.sh</span><br><span class="line">[root@master datas]$ vim sort.sh </span><br><span class="line">bb:40:5.4</span><br><span class="line">bd:20:4.2</span><br><span class="line">xz:50:2.3</span><br><span class="line">cls:10:3.5</span><br><span class="line">ss:30:1.6</span><br></pre></td></tr></table></figure><p>（1）按照“：”分割后的第三列倒序排序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@master datas]$ <span class="built_in">sort</span> -t : -nrk 3  sort.sh </span><br><span class="line">bb:40:5.4</span><br><span class="line">bd:20:4.2</span><br><span class="line">cls:10:3.5</span><br><span class="line">xz:50:2.3</span><br><span class="line">ss:30:1.6</span><br></pre></td></tr></table></figure><h1 id="第12章-正则表达式语法大全"><a href="#第12章-正则表达式语法大全" class="headerlink" title="第12章 正则表达式语法大全"></a>第12章 正则表达式语法大全</h1><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>\</td><td>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，“n”匹配字符”n”。”\n”匹配换行符。序列”\“匹配””，”(“匹配”(“。</td></tr><tr><td>^</td><td><strong>匹配输入字符串开始的位置</strong>。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与”\n”或”\r”之后的位置匹配。</td></tr><tr><td>$</td><td><strong>匹配输入字符串结尾的位置</strong>。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与”\n”或”\r”之前的位置匹配。</td></tr><tr><td>*</td><td>零次或多次匹配前面的字符或子表达式。例如，zo* 匹配”z”和”zoo”。* 等效于 {0,}。</td></tr><tr><td><code>+</code></td><td><code>一次或多次匹配前面的字符或子表达式。例如，&quot;zo+&quot;与&quot;zo&quot;和&quot;zoo&quot;匹配，但与&quot;z&quot;不匹配。+ 等效于 &#123;1,&#125;。</code></td></tr><tr><td>?</td><td>零次或一次匹配前面的字符或子表达式。例如，”do(es)?“匹配”do”或”does”中的”do”。? 等效于 {0,1}。</td></tr><tr><td>{n}</td><td>n 是非负整数。正好匹配 n 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。</td></tr><tr><td>{n,}</td><td>n 是非负整数。至少匹配 n 次。例如，”o{2,}“不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}“等效于”o+”。”o{0,}“等效于”o*”。</td></tr><tr><td>{n,m}</td><td>M 和 n 是非负整数，其中 n &lt;&#x3D; m。匹配至少 n 次，至多 m 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。‘o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。</td></tr><tr><td>?</td><td>当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?“只匹配单个”o”，而”o+“匹配所有”o”。</td></tr><tr><td><code>.</code></td><td><code>匹配除&quot;\r\n&quot;之外的任何单个字符。若要匹配包括&quot;\r\n&quot;在内的任意字符，请使用诸如&quot;[\s\S]&quot;之类的模式。</code></td></tr><tr><td>(pattern)</td><td>匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”(“或者”)”。</td></tr><tr><td>(?:pattern)</td><td>匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 &#96;(</td></tr><tr><td>(?&#x3D;pattern)</td><td>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’&#96;Windows (?&#x3D;95</td></tr><tr><td>(?!pattern)</td><td>执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’&#96;Windows (?!95</td></tr><tr><td>&#96;x</td><td>y&#96;</td></tr><tr><td>[xyz]</td><td>字符集。匹配包含的任一字符。例如，”[abc]“匹配”plain”中的”a”。</td></tr><tr><td>[^xyz]</td><td>反向字符集。匹配未包含的任何字符。例如，”[^abc]“匹配”plain”中”p”，“l”，“i”，“n”。</td></tr><tr><td><code>[a-z]</code></td><td><code>字符范围。匹配指定范围内的任何字符。例如，&quot;[a-z]&quot;匹配&quot;a&quot;到&quot;z&quot;范围内的任何小写字母。</code></td></tr><tr><td>[^a-z]</td><td>反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。</td></tr><tr><td>\b</td><td>匹配一个字边界，即字与空格间的位置。例如，“er\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。</td></tr><tr><td>\B</td><td>非字边界匹配。“er\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。</td></tr><tr><td>\cx</td><td>匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是”c”字符本身。</td></tr><tr><td>\d</td><td>数字字符匹配。等效于 [0-9]。</td></tr><tr><td>\D</td><td>非数字字符匹配。等效于 [^0-9]。</td></tr><tr><td>\f</td><td>换页符匹配。等效于 \x0c 和 \cL。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI笔记（2）：神经网络基础</title>
      <link href="/2023/08/02/2.%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/08/02/2.%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="1-算法基础与逻辑回归"><a href="#1-算法基础与逻辑回归" class="headerlink" title="1.算法基础与逻辑回归"></a>1.算法基础与逻辑回归</h2><p><a href="https://www.showmeai.tech/article-detail/188"><strong>逻辑回归</strong>(Logistic regression)</a> 是一个用于二分类的算法。</p><h3 id="1-1-二分类问题与机器学习基础"><a href="#1-1-二分类问题与机器学习基础" class="headerlink" title="1.1 二分类问题与机器学习基础"></a>1.1 二分类问题与机器学习基础</h3><p>二分类就是输出 <img src="https://www.zhihu.com/equation?tex=y" alt="公式"> 只有 {0,1} 两个离散值(也有 {-1,1} 的情况)。我们以一个「<strong>图像识别</strong>」问题为例，判断图片是否是猫。识别是否是「猫」，这是一个典型的二分类问题——0代表「非猫(not cat)」，1代表「猫(cat)」。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7d23dfda65d2602bc638fa9b6ffda70e.png" alt="算法基础与逻辑回归"></p><p>从机器学习的角度看，我们的输入 <img src="https://www.zhihu.com/equation?tex=x" alt="公式"> 此时是一张图片，彩色图片包含RGB三个通道，图片尺寸为 <img src="https://www.zhihu.com/equation?tex=(64,64,3)" alt="公式">。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5d0357642ea81c50a4942eeedcd12601.png" alt="数据与向量化格式"></p><p>有些神经网络的输入是一维的，我们可以将图片 <img src="https://www.zhihu.com/equation?tex=x" alt="公式"> (维度 <img src="https://www.zhihu.com/equation?tex=(64,64,3)" alt="公式"> )展平为一维特征向量(feature vector)，得到的特征向量维度为 <img src="https://www.zhihu.com/equation?tex=(12288,1)" alt="公式">。我们一般用列向量表示样本，把维度记为 <img src="https://www.zhihu.com/equation?tex=n_x" alt="公式">。</p><p>如果训练样本有 <img src="https://www.zhihu.com/equation?tex=m" alt="公式"> 张图片，那么我们用矩阵存储数据，此时数据维度变为 <img src="https://www.zhihu.com/equation?tex=(n_x,m)" alt="公式">。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f849e82bf0e6d760480dcb4e469a1aed.png" alt="数据与向量化格式"></p><ul><li>矩阵 <img src="https://www.zhihu.com/equation?tex=X" alt="公式"> 的行 <img src="https://www.zhihu.com/equation?tex=n_x" alt="公式"> 代表了每个样本 <img src="https://www.zhihu.com/equation?tex=x%5E%7B(i)%7D" alt="公式"> 特征个数</li><li>矩阵 <img src="https://www.zhihu.com/equation?tex=X" alt="公式"> 的列 <img src="https://www.zhihu.com/equation?tex=m" alt="公式"> 代表了样本个数。</li></ul><p>我们可以对训练样本的标签 <img src="https://www.zhihu.com/equation?tex=Y" alt="公式"> 也做一个规整化，调整为1维的形态，标签 <img src="https://www.zhihu.com/equation?tex=Y" alt="公式"> 的维度为 <img src="https://www.zhihu.com/equation?tex=(1,m)" alt="公式">。</p><h3 id="1-2-逻辑回归算法"><a href="#1-2-逻辑回归算法" class="headerlink" title="1.2 逻辑回归算法"></a>1.2 逻辑回归算法</h3><p>逻辑回归是最常见的二分类算法，它包含以下参数：</p><ul><li>输入的特征向量： <img src="https://www.zhihu.com/equation?tex=x%20%5Cin%20R%5E%7Bn_x%7D" alt="公式">，其中 <img src="https://www.zhihu.com/equation?tex=%7Bn_x%7D" alt="公式"> 是特征数量</li><li>用于训练的标签： <img src="https://www.zhihu.com/equation?tex=y%20%5Cin%200,1" alt="公式"></li><li>权重： <img src="https://www.zhihu.com/equation?tex=w%20%5Cin%20R%5E%7Bn_x%7D" alt="公式"></li><li>偏置： <img src="https://www.zhihu.com/equation?tex=b%20%5Cin%20R" alt="公式"></li><li>输出： <img src="https://www.zhihu.com/equation?tex=%5Chat%7By%7D%20=%20%5Csigma(w%5ETx+b)" alt="公式"></li></ul><p>输出计算用到了Sigmoid函数，它是一种非线性的S型函数，输出被限定在 <img src="https://www.zhihu.com/equation?tex=%5B0,1%5D" alt="公式"> 之间，通常被用在神经网络中当作激活函数(Activation Function)使用。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/469497535f2f8c0e7621b19954e89e1a.png" alt="逻辑回归做图像分类"></p><p>Sigmoid函数的表达式如下：</p><p><img src="https://www.zhihu.com/equation?tex=s%20=%20%5Csigma(w%5ETx+b)%20=%20%5Csigma(z)%20=%20%5Cfrac%7B1%7D%7B1+e%5E%7B-z%7D%7D" alt="公式"></p><p>实际上，逻辑回归可以看作非常小的一个神经网络。</p><h3 id="1-3-逻辑回归的损失函数"><a href="#1-3-逻辑回归的损失函数" class="headerlink" title="1.3 逻辑回归的损失函数"></a>1.3 逻辑回归的损失函数</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/cfdb63c3f40566dd3eb449791bebcbf1.png" alt="逻辑回归的代价函数 Logistic Regression Cost Function"></p><p>在机器学习中，**损失函数(loss function)**用于量化衡量预测结果与真实值之间的差距，我们会通过优化损失函数来不断调整模型权重，使其最好地拟合样本数据。</p><p>在回归类问题中，我们会使用均方差损失(MSE)：</p><p><img src="https://www.zhihu.com/equation?tex=L(%5Chat%7By%7D,y)%20=%20%5Cfrac%7B1%7D%7B2%7D(%5Chat%7By%7D-y)%5E2" alt="公式"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/35b403930fdd2e18120c284b77cacad2.png" alt="逻辑回归的损失函数"></p><p>但是在逻辑回归中，我们并不倾向于使用这样的损失函数。逻辑回归使用平方差损失会得到非凸的损失函数，它会有很多个局部最优解。梯度下降法可能找不到全局最优值，从而给优化带来困难。</p><p>因此我们调整成使用对数损失(二元交叉熵损失)：</p><p><img src="https://www.zhihu.com/equation?tex=L(%5Chat%7By%7D,y)%20=%20-(y%5Clog%5Chat%7By%7D)+(1-y)%5Clog(1-%5Chat%7By%7D)" alt="公式"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/82e431bdd18d9e3d68a48bc952c566d6.png" alt="逻辑回归的损失函数"></p><p>刚才我们给到的是单个训练样本中定义的损失函数，它衡量了在单个训练样本上的表现。我们定义<strong>代价函数</strong>(Cost Function，或者称作成本函数)为全体训练样本上的表现，即 <img src="https://www.zhihu.com/equation?tex=m" alt="公式"> 个样本的损失函数的平均值，反映了 <img src="https://www.zhihu.com/equation?tex=m" alt="公式"> 个样本的预测输出与真实样本输出 <img src="https://www.zhihu.com/equation?tex=y" alt="公式"> 的平均接近程度。</p><p>成本函数的计算公式如下：</p><p><img src="https://www.zhihu.com/equation?tex=J(w,b)%20=%20%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi=1%7D%5EmL(%5Chat%7By%7D%5E%7B(i)%7D,y%5E%7B(i)%7D)" alt="公式"></p><h2 id="2-梯度下降法-Gradient-Descent"><a href="#2-梯度下降法-Gradient-Descent" class="headerlink" title="2.梯度下降法(Gradient Descent)"></a>2.梯度下降法(Gradient Descent)</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/29c24cd29c1e9cd7cecdf80e74c87d49.png" alt="梯度下降 Gradient Descent"></p><p>刚才我们了解了损失函数(Loss Function)与成本函数定义，下一步我们就要找到最优的 <img src="https://www.zhihu.com/equation?tex=w" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=b" alt="公式"> 值，最小化 <img src="https://www.zhihu.com/equation?tex=m" alt="公式"> 个训练样本的Cost Function。这里用到的方法就叫做<strong>梯度下降</strong>(<strong>Gradient Descent</strong>)算法。</p><p>在数学上，1个函数的梯度(gradient)指出了它的最陡增长方向。也就是说，沿着梯度的方向走，函数增长得就最快。那么沿着梯度的负方向走，函数值就下降得最快。</p><p>模型的训练目标是寻找合适的 <img src="https://www.zhihu.com/equation?tex=w" alt="公式"> 与 <img src="https://www.zhihu.com/equation?tex=b" alt="公式"> 以最小化代价函数值。我们先假设 <img src="https://www.zhihu.com/equation?tex=w" alt="公式"> 与 <img src="https://www.zhihu.com/equation?tex=b" alt="公式"> 都是一维实数，则代价函数 <img src="https://www.zhihu.com/equation?tex=J" alt="公式"> 关于 <img src="https://www.zhihu.com/equation?tex=w" alt="公式"> 与 <img src="https://www.zhihu.com/equation?tex=b" alt="公式"> 的图如下所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/34aa5f085eef1115e72c7d81d6920c3e.png" alt="梯度下降法"></p><p>上图中的代价函数 <img src="https://www.zhihu.com/equation?tex=J" alt="公式"> 是一个<strong>凸函数</strong>，只有一个全局最低点，它能保证无论我们初始化模型参数如何(在曲面上任何位置)，都能够寻找到合适的最优解。</p><p>基于梯度下降算法，得到以下参数 <img src="https://www.zhihu.com/equation?tex=w" alt="公式"> 的更新公式：</p><p><img src="https://www.zhihu.com/equation?tex=w%20:=%20w%20-%20%5Calpha%5Cfrac%7BdJ(w,%20b)%7D%7Bdw%7D" alt="公式"></p><p>公式中 <img src="https://www.zhihu.com/equation?tex=%5Calpha" alt="公式"> 为学习率，即每次更新的 <img src="https://www.zhihu.com/equation?tex=w" alt="公式"> 的步长。</p><p>成本函数 <img src="https://www.zhihu.com/equation?tex=J(w,%20b)" alt="公式"> 中对应的参数 <img src="https://www.zhihu.com/equation?tex=b" alt="公式"> 更新公式为：</p><p><img src="https://www.zhihu.com/equation?tex=b%20:=%20b%20-%20%5Calpha%5Cfrac%7BdJ(w,%20b)%7D%7Bdb%7D" alt="公式"></p><h2 id="3-计算图-Computation-Graph"><a href="#3-计算图-Computation-Graph" class="headerlink" title="3.计算图(Computation Graph)"></a>3.计算图(Computation Graph)</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/f3a19232b166eb3d3967377d060ceb7a.png" alt="计算图 Computation Graph"></p><p>对于神经网络而言，训练过程包含了两个阶段：前向传播(Forward Propagation)和反向传播(Back Propagation)。</p><ul><li>前向传播是从输入到输出，由神经网络前推计算得到预测输出的过程</li><li>反向传播是从输出到输入，基于Cost Function对参数 <img src="https://www.zhihu.com/equation?tex=w" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=b" alt="公式"> 计算梯度的过程。</li></ul><p>下面，我们结合一个例子用计算图(Computation graph)的形式来理解这两个阶段。</p><h3 id="3-1-前向传播-Forward-Propagation"><a href="#3-1-前向传播-Forward-Propagation" class="headerlink" title="3.1 前向传播(Forward Propagation)"></a>3.1 前向传播(Forward Propagation)</h3><p>假如我们的Cost Function为 <img src="https://www.zhihu.com/equation?tex=J(a,b,c)=3(a+bc)" alt="公式">，包含 <img src="https://www.zhihu.com/equation?tex=a" alt="公式"> 、 <img src="https://www.zhihu.com/equation?tex=b" alt="公式"> 、 <img src="https://www.zhihu.com/equation?tex=c" alt="公式"> 三个变量。</p><p>我们添加一些中间变量，用 <img src="https://www.zhihu.com/equation?tex=u" alt="公式"> 表示 <img src="https://www.zhihu.com/equation?tex=bc" alt="公式">， <img src="https://www.zhihu.com/equation?tex=v" alt="公式"> 表示 <img src="https://www.zhihu.com/equation?tex=a+u" alt="公式">，则 <img src="https://www.zhihu.com/equation?tex=J=3v" alt="公式">。</p><p>整个过程可以用计算图表示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ccc03bc0b2b89bf22d69b9f556373660.png" alt="计算图"></p><p>在上图中，我们让 <img src="https://www.zhihu.com/equation?tex=a=5" alt="公式">， <img src="https://www.zhihu.com/equation?tex=b=3" alt="公式">， <img src="https://www.zhihu.com/equation?tex=c=2" alt="公式">，则 <img src="https://www.zhihu.com/equation?tex=u=bc=6" alt="公式">， <img src="https://www.zhihu.com/equation?tex=v=a+u=11" alt="公式">， <img src="https://www.zhihu.com/equation?tex=J=3v=33" alt="公式">。</p><p>计算图中，这种从左到右，从输入到输出的过程，就对应着神经网络基于 <img src="https://www.zhihu.com/equation?tex=x" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=w" alt="公式"> 计算得到Cost Function的前向计算过程。</p><h3 id="3-2-反向传播-Back-Propagation"><a href="#3-2-反向传播-Back-Propagation" class="headerlink" title="3.2 反向传播(Back Propagation)"></a>3.2 反向传播(Back Propagation)</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/f658c4007b0b0c4d35a076daf27ea248.png" alt="计算图导数 Derivatives with a Computation Graph"></p><p>我们接着上个例子中的计算图讲解反向传播，我们的输入参数有 <img src="https://www.zhihu.com/equation?tex=a" alt="公式"> 、 <img src="https://www.zhihu.com/equation?tex=b" alt="公式"> 、 <img src="https://www.zhihu.com/equation?tex=c" alt="公式"> 三个。</p><p>① <strong>先计算 <img src="https://www.zhihu.com/equation?tex=J" alt="公式"> 对参数 <img src="https://www.zhihu.com/equation?tex=a" alt="公式"> 的偏导数</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/2011ffd4edca39d6e0535b2287a238c6.png" alt="计算图"></p><p>从计算图上来看，从右到左， <img src="https://www.zhihu.com/equation?tex=J" alt="公式"> 是 <img src="https://www.zhihu.com/equation?tex=v" alt="公式"> 的函数， <img src="https://www.zhihu.com/equation?tex=v" alt="公式"> 是 <img src="https://www.zhihu.com/equation?tex=a" alt="公式"> 的函数。基于求导链式法则得到：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial%20J%7D%7B%5Cpartial%20a%7D=%5Cfrac%7B%5Cpartial%20J%7D%7B%5Cpartial%20v%7D%5Ccdot%20%5Cfrac%7B%5Cpartial%20v%7D%7B%5Cpartial%20a%7D=3%5Ccdot%201=3" alt="公式"></p><p>② <strong>计算 <img src="https://www.zhihu.com/equation?tex=J" alt="公式"> 对参数 <img src="https://www.zhihu.com/equation?tex=b" alt="公式"> 的偏导数</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/f9875c26024de75278c3682242471803.png" alt="计算图"></p><p>从计算图上来看，从右到左， <img src="https://www.zhihu.com/equation?tex=J" alt="公式"> 是 <img src="https://www.zhihu.com/equation?tex=v" alt="公式"> 的函数， <img src="https://www.zhihu.com/equation?tex=v" alt="公式"> 是 <img src="https://www.zhihu.com/equation?tex=u" alt="公式"> 的函数， <img src="https://www.zhihu.com/equation?tex=u" alt="公式"> 是 <img src="https://www.zhihu.com/equation?tex=b" alt="公式"> 的函数。同样可得：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial%20J%7D%7B%5Cpartial%20b%7D=%5Cfrac%7B%5Cpartial%20J%7D%7B%5Cpartial%20v%7D%5Ccdot%20%5Cfrac%7B%5Cpartial%20v%7D%7B%5Cpartial%20u%7D%5Ccdot%20%5Cfrac%7B%5Cpartial%20u%7D%7B%5Cpartial%20b%7D=3%5Ccdot%201%5Ccdot%20c=3%5Ccdot%201%5Ccdot%202=6" alt="公式"></p><p>③ <strong>计算 <img src="https://www.zhihu.com/equation?tex=J" alt="公式"> 对参数 <img src="https://www.zhihu.com/equation?tex=c" alt="公式"> 的偏导数</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/24ad6820ce5d47507d6c3627fef30742.png" alt="计算图"></p><p>此时从右到左， <img src="https://www.zhihu.com/equation?tex=J" alt="公式"> 是 <img src="https://www.zhihu.com/equation?tex=v" alt="公式"> 的函数， <img src="https://www.zhihu.com/equation?tex=v" alt="公式"> 是 <img src="https://www.zhihu.com/equation?tex=u" alt="公式"> 的函数， <img src="https://www.zhihu.com/equation?tex=u" alt="公式"> 是 <img src="https://www.zhihu.com/equation?tex=c" alt="公式"> 的函数。可得：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial%20J%7D%7B%5Cpartial%20c%7D=%5Cfrac%7B%5Cpartial%20J%7D%7B%5Cpartial%20v%7D%5Ccdot%20%5Cfrac%7B%5Cpartial%20v%7D%7B%5Cpartial%20u%7D%5Ccdot%20%5Cfrac%7B%5Cpartial%20u%7D%7B%5Cpartial%20c%7D=3%5Ccdot%201%5Ccdot%20b=3%5Ccdot%201%5Ccdot%203=9" alt="公式"></p><p>这样就完成了从右往左的反向传播与梯度(偏导)计算过程。</p><h2 id="4-逻辑回归中的梯度下降法"><a href="#4-逻辑回归中的梯度下降法" class="headerlink" title="4.逻辑回归中的梯度下降法"></a>4.逻辑回归中的梯度下降法</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/560b7f3519cb6d3dff8dc079d493054d.png" alt="逻辑回归的梯度下降 Logistic Regression Gradient Descent"></p><p>回到我们前面提到的逻辑回归问题，我们假设输入的特征向量维度为2(即 <img src="https://www.zhihu.com/equation?tex=%5Bx_1,%20x_2%5D" alt="公式"> )，对应权重参数 <img src="https://www.zhihu.com/equation?tex=w_1" alt="公式"> 、 <img src="https://www.zhihu.com/equation?tex=w_2" alt="公式"> 、 <img src="https://www.zhihu.com/equation?tex=b" alt="公式"> 得到如下的计算图：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c9201f61badc2bd794dfd4fe6052e01c.png" alt="逻辑回归中的梯度下降法"></p><h4 id="反向传播计算梯度"><a href="#反向传播计算梯度" class="headerlink" title="反向传播计算梯度"></a>反向传播计算梯度</h4><p>① <strong>求出 <img src="https://www.zhihu.com/equation?tex=L" alt="公式"> 对于 <img src="https://www.zhihu.com/equation?tex=a" alt="公式"> 的导数</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/bc229a0e811de31858ef4454d73e6692.png" alt="逻辑回归中的梯度下降法"></p><p>② <strong>求出 <img src="https://www.zhihu.com/equation?tex=L" alt="公式"> 对于 <img src="https://www.zhihu.com/equation?tex=z" alt="公式"> 的导数</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/73c19076db20a22d549d531db5fb2dfb.png" alt="逻辑回归中的梯度下降法"></p><p>③ <strong>继续前推计算</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/fbc8345a74488feb08c99f23f07d12ff.png" alt="逻辑回归中的梯度下降法"></p><p>④ <strong>基于梯度下降可以得到参数更新公式</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/557bae9c5d002d787203645e6db4f99b.png" alt="逻辑回归中的梯度下降法"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/cb172a72369b42049481cbce2acc57dd.png" alt="梯度下降的例子 Gradient Descent on m Examples"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/a510f9ab08d89fd0695eb6105052ac57.png" alt="逻辑回归中的梯度下降法"></p><p>前面提到的是对单个样本求偏导和应用梯度下降算法的过程。对于有 <img src="https://www.zhihu.com/equation?tex=m" alt="公式"> 个样本的数据集，Cost Function <img src="https://www.zhihu.com/equation?tex=J(w,b)" alt="公式"> 、 <img src="https://www.zhihu.com/equation?tex=a%5E%7B(i)%7D" alt="公式"> 和 权重参数 <img src="https://www.zhihu.com/equation?tex=w_1" alt="公式"> 的计算如图所示。</p><p>完整的Logistic回归中某次训练的流程如下，这里仅假设特征向量的维度为2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">J=0; dw1=0; dw2=0; db=0;</span><br><span class="line">for i = 1 to m   z(i) = wx(i)+b;   a(i) = sigmoid(z(i));  </span><br><span class="line">J+= -[y(i)log(a(i))+(1-y(i))log(1-a(i));  </span><br><span class="line">dz(i) = a(i)-y(i);   dw1 += x1(i)dz(i);   dw2 += x2(i)dz(i);  </span><br><span class="line">db += dz(i); J /= m; dw1 /= m; dw2 /= m; db /= m;</span><br></pre></td></tr></table></figure><p>接着再对 <img src="https://www.zhihu.com/equation?tex=w_1" alt="公式"> 、 <img src="https://www.zhihu.com/equation?tex=w_2" alt="公式"> 、 <img src="https://www.zhihu.com/equation?tex=b" alt="公式"> 进行迭代。</p><p>上述计算过程有一个缺点：整个流程包含两个for循环。其中：</p><ul><li>第一个for循环遍历 <img src="https://www.zhihu.com/equation?tex=m" alt="公式"> 个样本</li><li>第二个for循环遍历所有特征</li></ul><p>如果有大量特征，在代码中显示使用for循环会使算法很低效。<strong>向量化</strong>可以用于解决显式使用for循环的问题。</p><h2 id="5-向量化-Vectorization"><a href="#5-向量化-Vectorization" class="headerlink" title="5.向量化(Vectorization)"></a>5.向量化(Vectorization)</h2><p>继续以逻辑回归为例，如果以非向量化的循环方式计算 <img src="https://www.zhihu.com/equation?tex=z=w%5ETx+b" alt="公式">，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z = 0;for i in range(n_x):    z += w[i] * x[i]z += b</span><br></pre></td></tr></table></figure><p>基于向量化的操作，可以并行计算，极大提升效率，同时代码也更为简洁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z = np.dot(w, x) + b</span><br></pre></td></tr></table></figure><p>不用显式for循环，实现逻辑回归的梯度下降的迭代伪代码如下：</p><p><img src="https://www.zhihu.com/equation?tex=Z=w%5ETX+b=np.dot(w.T,%20x)%20+%20b" alt="公式"></p><p><img src="https://www.zhihu.com/equation?tex=A=%5Csigma(Z)" alt="公式"></p><p><img src="https://www.zhihu.com/equation?tex=dZ=A-Y" alt="公式"></p><p><img src="https://www.zhihu.com/equation?tex=dw=%5Cfrac%7B1%7D%7Bm%7DXdZ%5ET" alt="公式"></p><p><img src="https://www.zhihu.com/equation?tex=db=%5Cfrac%7B1%7D%7Bm%7Dnp.sum(dZ)" alt="公式"></p><p><img src="https://www.zhihu.com/equation?tex=w:=w-%5Csigma%20dw" alt="公式"></p><p><img src="https://www.zhihu.com/equation?tex=b:=b-%5Csigma%20db" alt="公式"></p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy笔记</title>
      <link href="/2023/08/02/numpy%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/08/02/numpy%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>NumPy的主要对象是同构多维数组。它是一个元素表（通常是数字），所有类型都相同，由非负整数元组索引。在NumPy维度中称为 <em>轴</em> 。</p><p>例如，3D空间中的点的坐标<code>[1, 2, 1]</code>具有一个轴。该轴有3个元素，所以我们说它的长度为3.在下图所示的例子中，数组有2个轴。第一轴的长度为2，第二轴的长度为3。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[ <span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line"> [ <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">2.</span>]]</span><br></pre></td></tr></table></figure><p>NumPy的数组类被调用<code>ndarray</code>。它也被别名所知 <code>array</code>。请注意，<code>numpy.array</code>这与标准Python库类不同<code>array.array</code>，后者只处理一维数组并提供较少的功能。<code>ndarray</code>对象更重要的属性是：</p><ul><li><strong>ndarray.ndim</strong> - 数组的轴（维度）的个数。在Python世界中，维度的数量被称为rank。</li><li><strong>ndarray.shape</strong> - 数组的维度。这是一个整数的元组，表示每个维度中数组的大小。对于有 <em>n</em> 行和 <em>m</em> 列的矩阵，<code>shape</code> 将是 <code>(n,m)</code>。因此，<code>shape</code> 元组的长度就是rank或维度的个数 <code>ndim</code>。</li><li><strong>ndarray.size</strong> - 数组元素的总数。这等于 <code>shape</code> 的元素的乘积。</li><li><strong>ndarray.dtype</strong> - 一个描述数组中元素类型的对象。可以使用标准的Python类型创建或指定dtype。另外NumPy提供它自己的类型。例如numpy.int32、numpy.int16和numpy.float64。</li><li><strong>ndarray.itemsize</strong> - 数组中每个元素的字节大小。例如，元素为 <code>float64</code> 类型的数组的 <code>itemsize</code> 为8（&#x3D;64&#x2F;8），而 <code>complex32</code> 类型的数组的 <code>itemsize</code> 为4（&#x3D;32&#x2F;8）。它等于 <code>ndarray.dtype.itemsize</code> 。</li><li><strong>ndarray.data</strong> - 该缓冲区包含数组的实际元素。通常，我们不需要使用此属性，因为我们将使用索引访问数组中的元素。</li></ul><h3 id="一个例子"><a href="#一个例子" class="headerlink" title="#一个例子"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90">#</a>一个例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">15</span>).reshape(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>],</span><br><span class="line">       [ <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape</span><br><span class="line">(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.ndim</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.dtype.name</span><br><span class="line"><span class="string">&#x27;int64&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.itemsize</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.size</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(a)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;numpy.ndarray&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.array([<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(b)</span><br><span class="line">&lt;<span class="built_in">type</span> <span class="string">&#x27;numpy.ndarray&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="数组创建"><a href="#数组创建" class="headerlink" title="#数组创建"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E6%95%B0%E7%BB%84%E5%88%9B%E5%BB%BA">#</a>数组创建</h3><p>有几种方法可以创建数组。</p><p>例如，你可以使用array函数从常规Python列表或元组中创建数组。得到的数组的类型是从Python列表中元素的类型推导出来的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.dtype</span><br><span class="line">dtype(<span class="string">&#x27;int64&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.array([<span class="number">1.2</span>, <span class="number">3.5</span>, <span class="number">5.1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.dtype</span><br><span class="line">dtype(<span class="string">&#x27;float64&#x27;</span>)</span><br></pre></td></tr></table></figure><p>一个常见的错误，就是调用<code>array</code>的时候传入多个数字参数，而不是提供单个数字的列表类型作为参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)    <span class="comment"># WRONG</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])  <span class="comment"># RIGHT</span></span><br></pre></td></tr></table></figure><p><code>array</code> 还可以将序列的序列转换成二维数组，将序列的序列的序列转换成三维数组，等等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.array([(<span class="number">1.5</span>,<span class="number">2</span>,<span class="number">3</span>), (<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([[ <span class="number">1.5</span>,  <span class="number">2.</span> ,  <span class="number">3.</span> ],</span><br><span class="line">       [ <span class="number">4.</span> ,  <span class="number">5.</span> ,  <span class="number">6.</span> ]]) //.之后不加东西，节省空间，代表浮点数<span class="number">4.0</span> <span class="number">5.0</span>等等</span><br></pre></td></tr></table></figure><p>也可以在创建时显式指定数组的类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = np.array( [ [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>] ], dtype=<span class="built_in">complex</span> )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">array([[ <span class="number">1.</span>+<span class="number">0.j</span>,  <span class="number">2.</span>+<span class="number">0.j</span>],</span><br><span class="line">       [ <span class="number">3.</span>+<span class="number">0.j</span>,  <span class="number">4.</span>+<span class="number">0.j</span>]])</span><br></pre></td></tr></table></figure><p>通常，数组的元素最初是未知的，但它的大小是已知的。因此，NumPy提供了几个函数来创建具有初始占位符内容的数组。这就减少了数组增长的必要，因为数组增长的操作花费很大。</p><p>函数<code>zeros</code>创建一个由0组成的数组，函数 <code>ones</code>创建一个完整的数组，函数<code>empty</code> 创建一个数组，其初始内容是随机的，取决于内存的状态。默认情况下，创建的数组的dtype是 <code>float64</code> 类型的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.zeros( (<span class="number">3</span>,<span class="number">4</span>) )</span><br><span class="line">array([[ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.ones( (<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>), dtype=np.int16 )                <span class="comment"># dtype can also be specified</span></span><br><span class="line">array([[[ <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [ <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [ <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">       [[ <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [ <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [ <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]]], dtype=int16)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.empty( (<span class="number">2</span>,<span class="number">3</span>) )                                 <span class="comment"># uninitialized, output may vary</span></span><br><span class="line">array([[  <span class="number">3.73603959e-262</span>,   <span class="number">6.02658058e-154</span>,   <span class="number">6.55490914e-260</span>],</span><br><span class="line">       [  <span class="number">5.30498948e-313</span>,   <span class="number">3.14673309e-307</span>,   <span class="number">1.00000000e+000</span>]])</span><br></pre></td></tr></table></figure><p>为了创建数字组成的数组，NumPy提供了一个类似于<code>range</code>的函数，该函数返回数组而不是列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.arange( <span class="number">10</span>, <span class="number">30</span>, <span class="number">5</span> )</span><br><span class="line">array([<span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.arange( <span class="number">0</span>, <span class="number">2</span>, <span class="number">0.3</span> )                 <span class="comment"># it accepts float arguments</span></span><br><span class="line">array([ <span class="number">0.</span> ,  <span class="number">0.3</span>,  <span class="number">0.6</span>,  <span class="number">0.9</span>,  <span class="number">1.2</span>,  <span class="number">1.5</span>,  <span class="number">1.8</span>])</span><br></pre></td></tr></table></figure><p>当<code>arange</code>与浮点参数一起使用时，由于有限的浮点精度，通常不可能预测所获得的元素的数量。出于这个原因，通常最好使用<code>linspace</code>函数来接收我们想要的元素数量的函数，而不是步长（step）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> numpy <span class="keyword">import</span> pi</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.linspace( <span class="number">0</span>, <span class="number">2</span>, <span class="number">9</span> )                 <span class="comment"># 9 numbers from 0 to 2</span></span><br><span class="line">array([ <span class="number">0.</span>  ,  <span class="number">0.25</span>,  <span class="number">0.5</span> ,  <span class="number">0.75</span>,  <span class="number">1.</span>  ,  <span class="number">1.25</span>,  <span class="number">1.5</span> ,  <span class="number">1.75</span>,  <span class="number">2.</span>  ])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.linspace( <span class="number">0</span>, <span class="number">2</span>*pi, <span class="number">100</span> )        <span class="comment"># useful to evaluate function at lots of points</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = np.sin(x)</span><br></pre></td></tr></table></figure><p>另见这些API</p><p><a href="https://numpy.org/devdocs/reference/generated/numpy.array.html#numpy.array"><code>array</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.zeros.html#numpy.zeros"><code>zeros</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.zeros_like.html#numpy.zeros_like"><code>zeros_like</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.ones.html#numpy.ones"><code>ones</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.ones_like.html#numpy.ones_like"><code>ones_like</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.empty.html#numpy.empty"><code>empty</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.empty_like.html#numpy.empty_like"><code>empty_like</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.arange.html#numpy.arange"><code>arange</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.linspace.html#numpy.linspace"><code>linspace</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/random/generated/numpy.random.mtrand.RandomState.rand.html#numpy.random.mtrand.RandomState.rand"><code>numpy.random.mtrand.RandomState.rand</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/random/generated/numpy.random.mtrand.RandomState.randn.html#numpy.random.mtrand.RandomState.randn"><code>numpy.random.mtrand.RandomState.randn</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.fromfunction.html#numpy.fromfunction"><code>fromfunction</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.fromfile.html#numpy.fromfile"><code>fromfile</code>open in new window</a></p><h3 id="打印数组"><a href="#打印数组" class="headerlink" title="#打印数组"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E6%89%93%E5%8D%B0%E6%95%B0%E7%BB%84">#</a>打印数组</h3><p>当您打印数组时，NumPy以与嵌套列表类似的方式显示它，但具有以下布局：</p><ul><li>最后一个轴从左到右打印，</li><li>倒数第二个从上到下打印，</li><li>其余部分也从上到下打印，每个切片用空行分隔。</li></ul><p>然后将一维数组打印为行，将二维数据打印为矩阵，将三维数据打印为矩数组表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">6</span>)                         <span class="comment"># 1d array</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a)</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.arange(<span class="number">12</span>).reshape(<span class="number">4</span>,<span class="number">3</span>)           <span class="comment"># 2d array</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(b)</span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>]</span><br><span class="line"> [ <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>]</span><br><span class="line"> [ <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>]</span><br><span class="line"> [ <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = np.arange(<span class="number">24</span>).reshape(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)         <span class="comment"># 3d array</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(c)</span><br><span class="line">[[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line">  [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line">  [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]]</span><br><span class="line"> [[<span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>]</span><br><span class="line">  [<span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span>]</span><br><span class="line">  [<span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]]]</span><br></pre></td></tr></table></figure><p>有关 <code>reshape</code> 的详情，请参阅下文。</p><p>如果数组太大而无法打印，NumPy会自动跳过数组的中心部分并仅打印角点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(np.arange(<span class="number">10000</span>))</span><br><span class="line">[   <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span> ..., <span class="number">9997</span> <span class="number">9998</span> <span class="number">9999</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(np.arange(<span class="number">10000</span>).reshape(<span class="number">100</span>,<span class="number">100</span>))</span><br><span class="line">[[   <span class="number">0</span>    <span class="number">1</span>    <span class="number">2</span> ...,   <span class="number">97</span>   <span class="number">98</span>   <span class="number">99</span>]</span><br><span class="line"> [ <span class="number">100</span>  <span class="number">101</span>  <span class="number">102</span> ...,  <span class="number">197</span>  <span class="number">198</span>  <span class="number">199</span>]</span><br><span class="line"> [ <span class="number">200</span>  <span class="number">201</span>  <span class="number">202</span> ...,  <span class="number">297</span>  <span class="number">298</span>  <span class="number">299</span>]</span><br><span class="line"> ...,</span><br><span class="line"> [<span class="number">9700</span> <span class="number">9701</span> <span class="number">9702</span> ..., <span class="number">9797</span> <span class="number">9798</span> <span class="number">9799</span>]</span><br><span class="line"> [<span class="number">9800</span> <span class="number">9801</span> <span class="number">9802</span> ..., <span class="number">9897</span> <span class="number">9898</span> <span class="number">9899</span>]</span><br><span class="line"> [<span class="number">9900</span> <span class="number">9901</span> <span class="number">9902</span> ..., <span class="number">9997</span> <span class="number">9998</span> <span class="number">9999</span>]]</span><br></pre></td></tr></table></figure><p>要禁用此行为并强制NumPy打印整个数组，可以使用更改打印选项<code>set_printoptions</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.set_printoptions(threshold=sys.maxsize)       <span class="comment"># sys module should be imported</span></span><br></pre></td></tr></table></figure><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="#基本操作"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">#</a>基本操作</h3><p>数组上的算术运算符会应用到 <em>元素</em> 级别。下面是创建一个新数组并填充结果的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array( [<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>] )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.arange( <span class="number">4</span> )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = a-b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">array([<span class="number">20</span>, <span class="number">29</span>, <span class="number">38</span>, <span class="number">47</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b**<span class="number">2</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">10</span>*np.sin(a)</span><br><span class="line">array([ <span class="number">9.12945251</span>, -<span class="number">9.88031624</span>,  <span class="number">7.4511316</span> , -<span class="number">2.62374854</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a&lt;<span class="number">35</span></span><br><span class="line">array([ <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>])</span><br></pre></td></tr></table></figure><p>与许多矩阵语言不同，乘积运算符<code>*</code>在NumPy数组中按元素进行运算。矩阵乘积可以使用<code>@</code>运算符（在python&gt; &#x3D; 3.5中）或<code>dot</code>函数或方法执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A = np.array( [[<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line"><span class="meta">... </span>            [<span class="number">0</span>,<span class="number">1</span>]] )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B = np.array( [[<span class="number">2</span>,<span class="number">0</span>],</span><br><span class="line"><span class="meta">... </span>            [<span class="number">3</span>,<span class="number">4</span>]] )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A * B                       <span class="comment"># elementwise product</span></span><br><span class="line">array([[<span class="number">2</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A @ B                       <span class="comment"># matrix product</span></span><br><span class="line">array([[<span class="number">5</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.dot(B)                    <span class="comment"># another matrix product</span></span><br><span class="line">array([[<span class="number">5</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>]])</span><br></pre></td></tr></table></figure><p>某些操作（例如<code>+=</code>和 <code>*=</code>）会更直接更改被操作的矩阵数组而不会创建新矩阵数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.ones((<span class="number">2</span>,<span class="number">3</span>), dtype=<span class="built_in">int</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.random.random((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a *= <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b += a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([[ <span class="number">3.417022</span>  ,  <span class="number">3.72032449</span>,  <span class="number">3.00011437</span>],</span><br><span class="line">       [ <span class="number">3.30233257</span>,  <span class="number">3.14675589</span>,  <span class="number">3.09233859</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a += b                  <span class="comment"># b is not automatically converted to integer type</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: Cannot cast ufunc add output <span class="keyword">from</span> dtype(<span class="string">&#x27;float64&#x27;</span>) to dtype(<span class="string">&#x27;int64&#x27;</span>) <span class="keyword">with</span> casting rule <span class="string">&#x27;same_kind&#x27;</span></span><br></pre></td></tr></table></figure><p>当使用不同类型的数组进行操作时，结果数组的类型对应于更一般或更精确的数组（称为向上转换的行为）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.ones(<span class="number">3</span>, dtype=np.int32)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.linspace(<span class="number">0</span>,pi,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.dtype.name</span><br><span class="line"><span class="string">&#x27;float64&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = a+b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">array([ <span class="number">1.</span>        ,  <span class="number">2.57079633</span>,  <span class="number">4.14159265</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.dtype.name</span><br><span class="line"><span class="string">&#x27;float64&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = np.exp(c*<span class="number">1j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">array([ <span class="number">0.54030231</span>+<span class="number">0.84147098j</span>, -<span class="number">0.84147098</span>+<span class="number">0.54030231j</span>,</span><br><span class="line">       -<span class="number">0.54030231</span>-<span class="number">0.84147098j</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.dtype.name</span><br><span class="line"><span class="string">&#x27;complex128&#x27;</span></span><br></pre></td></tr></table></figure><p>许多一元操作，例如计算数组中所有元素的总和，都是作为<code>ndarray</code>类的方法实现的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.random.random((<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">0.18626021</span>,  <span class="number">0.34556073</span>,  <span class="number">0.39676747</span>],</span><br><span class="line">       [ <span class="number">0.53881673</span>,  <span class="number">0.41919451</span>,  <span class="number">0.6852195</span> ]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.<span class="built_in">sum</span>()</span><br><span class="line"><span class="number">2.5718191614547998</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.<span class="built_in">min</span>()</span><br><span class="line"><span class="number">0.1862602113776709</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.<span class="built_in">max</span>()</span><br><span class="line"><span class="number">0.6852195003967595</span></span><br></pre></td></tr></table></figure><p>默认情况下，这些操作适用于数组，就像它是一个数字列表一样，无论其形状如何。但是，通过指定<code>axis</code> 参数，您可以沿数组的指定轴应用操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.<span class="built_in">sum</span>(axis=<span class="number">0</span>)                            <span class="comment"># sum of each column</span></span><br><span class="line">array([<span class="number">12</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">21</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.<span class="built_in">min</span>(axis=<span class="number">1</span>)                            <span class="comment"># min of each row</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.cumsum(axis=<span class="number">1</span>)                         <span class="comment"># cumulative sum along each row</span></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">3</span>,  <span class="number">6</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">9</span>, <span class="number">15</span>, <span class="number">22</span>],</span><br><span class="line">       [ <span class="number">8</span>, <span class="number">17</span>, <span class="number">27</span>, <span class="number">38</span>]])</span><br></pre></td></tr></table></figure><h3 id="通函数"><a href="#通函数" class="headerlink" title="#通函数"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E9%80%9A%E5%87%BD%E6%95%B0">#</a>通函数</h3><p>NumPy提供熟悉的数学函数，例如sin，cos和exp。在NumPy中，这些被称为“通函数”（<code>ufunc</code>）。在NumPy中，这些函数在数组上按元素进行运算，产生一个数组作为输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>B = np.arange(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.exp(B)</span><br><span class="line">array([ <span class="number">1.</span>        ,  <span class="number">2.71828183</span>,  <span class="number">7.3890561</span> ])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.sqrt(B)</span><br><span class="line">array([ <span class="number">0.</span>        ,  <span class="number">1.</span>        ,  <span class="number">1.41421356</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C = np.array([<span class="number">2.</span>, -<span class="number">1.</span>, <span class="number">4.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.add(B, C)</span><br><span class="line">array([ <span class="number">2.</span>,  <span class="number">0.</span>,  <span class="number">6.</span>])</span><br></pre></td></tr></table></figure><p>另见这些通函数</p><p><a href="https://numpy.org/devdocs/reference/generated/numpy.all.html#numpy.all"><code>all</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.any.html#numpy.any"><code>any</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.apply_along_axis.html#numpy.apply_along_axis"><code>apply_along_axis</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.argmax.html#numpy.argmax"><code>argmax</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.argmin.html#numpy.argmin"><code>argmin</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.argsort.html#numpy.argsort"><code>argsort</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.average.html#numpy.average"><code>average</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.bincount.html#numpy.bincount"><code>bincount</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.ceil.html#numpy.ceil"><code>ceil</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.clip.html#numpy.clip"><code>clip</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.conj.html#numpy.conj"><code>conj</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.corrcoef.html#numpy.corrcoef"><code>corrcoef</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.cov.html#numpy.cov"><code>cov</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.cross.html#numpy.cross"><code>cross</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.cumprod.html#numpy.cumprod"><code>cumprod</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.cumsum.html#numpy.cumsum"><code>cumsum</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.diff.html#numpy.diff"><code>diff</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.dot.html#numpy.dot"><code>dot</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.floor.html#numpy.floor"><code>floor</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.inner.html#numpy.inner"><code>inner</code>open in new window</a>， <em>INV</em> ， <a href="https://numpy.org/devdocs/reference/generated/numpy.lexsort.html#numpy.lexsort"><code>lexsort</code>open in new window</a>， <a href="https://docs.python.org/dev/library/functions.html#max"><code>max</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.maximum.html#numpy.maximum"><code>maximum</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.mean.html#numpy.mean"><code>mean</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.median.html#numpy.median"><code>median</code>open in new window</a>， <a href="https://docs.python.org/dev/library/functions.html#min"><code>min</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.minimum.html#numpy.minimum"><code>minimum</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.nonzero.html#numpy.nonzero"><code>nonzero</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.outer.html#numpy.outer"><code>outer</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.prod.html#numpy.prod"><code>prod</code>open in new window</a>， <a href="https://docs.python.org/dev/library/re.html#module-re"><code>re</code>open in new window</a>， <a href="https://docs.python.org/dev/library/functions.html#round"><code>round</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.sort.html#numpy.sort"><code>sort</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.std.html#numpy.std"><code>std</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.sum.html#numpy.sum"><code>sum</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.trace.html#numpy.trace"><code>trace</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.transpose.html#numpy.transpose"><code>transpose</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.var.html#numpy.var"><code>var</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.vdot.html#numpy.vdot"><code>vdot</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.vectorize.html#numpy.vectorize"><code>vectorize</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.where.html#numpy.where"><code>where</code>open in new window</a></p><h3 id="索引、切片和迭代"><a href="#索引、切片和迭代" class="headerlink" title="#索引、切片和迭代"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E7%B4%A2%E5%BC%95%E3%80%81%E5%88%87%E7%89%87%E5%92%8C%E8%BF%AD%E4%BB%A3">#</a>索引、切片和迭代</h3><p><strong>一维</strong>的数组可以进行索引、切片和迭代操作的，就像 <a href="https://docs.python.org/tutorial/introduction.html#lists">列表open in new window</a> 和其他Python序列类型一样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">10</span>)**<span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([  <span class="number">0</span>,   <span class="number">1</span>,   <span class="number">8</span>,  <span class="number">27</span>,  <span class="number">64</span>, <span class="number">125</span>, <span class="number">216</span>, <span class="number">343</span>, <span class="number">512</span>, <span class="number">729</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>]</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>:<span class="number">5</span>]</span><br><span class="line">array([ <span class="number">8</span>, <span class="number">27</span>, <span class="number">64</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:<span class="number">6</span>:<span class="number">2</span>] = -<span class="number">1000</span>    <span class="comment"># equivalent to a[0:6:2] = -1000; from start to position 6, exclusive, set every 2nd element to -1000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([-<span class="number">1000</span>,     <span class="number">1</span>, -<span class="number">1000</span>,    <span class="number">27</span>, -<span class="number">1000</span>,   <span class="number">125</span>,   <span class="number">216</span>,   <span class="number">343</span>,   <span class="number">512</span>,   <span class="number">729</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[ : :-<span class="number">1</span>]                                 <span class="comment"># reversed a</span></span><br><span class="line">array([  <span class="number">729</span>,   <span class="number">512</span>,   <span class="number">343</span>,   <span class="number">216</span>,   <span class="number">125</span>, -<span class="number">1000</span>,    <span class="number">27</span>, -<span class="number">1000</span>,     <span class="number">1</span>, -<span class="number">1000</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(i**(<span class="number">1</span>/<span class="number">3.</span>))</span><br><span class="line">...</span><br><span class="line">nan</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line">nan</span><br><span class="line"><span class="number">3.0</span></span><br><span class="line">nan</span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="number">6.0</span></span><br><span class="line"><span class="number">7.0</span></span><br><span class="line"><span class="number">8.0</span></span><br><span class="line"><span class="number">9.0</span></span><br></pre></td></tr></table></figure><p><strong>多维</strong>的数组每个轴可以有一个索引。这些索引以逗号分隔的元组给出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x,y</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="number">10</span>*x+y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.fromfunction(f,(<span class="number">5</span>,<span class="number">4</span>),dtype=<span class="built_in">int</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>],</span><br><span class="line">       [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],</span><br><span class="line">       [<span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>],</span><br><span class="line">       [<span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">0</span>:<span class="number">5</span>, <span class="number">1</span>]                       <span class="comment"># each row in the second column of b</span></span><br><span class="line">array([ <span class="number">1</span>, <span class="number">11</span>, <span class="number">21</span>, <span class="number">31</span>, <span class="number">41</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[ : ,<span class="number">1</span>]                        <span class="comment"># equivalent to the previous example</span></span><br><span class="line">array([ <span class="number">1</span>, <span class="number">11</span>, <span class="number">21</span>, <span class="number">31</span>, <span class="number">41</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">1</span>:<span class="number">3</span>, : ]                      <span class="comment"># each column in the second and third row of b</span></span><br><span class="line">array([[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>],</span><br><span class="line">       [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>]])</span><br></pre></td></tr></table></figure><p>当提供的索引少于轴的数量时，缺失的索引被认为是完整的切片<code>:</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[-<span class="number">1</span>]                                  <span class="comment"># the last row. Equivalent to b[-1,:]</span></span><br><span class="line">array([<span class="number">40</span>, <span class="number">41</span>, <span class="number">42</span>, <span class="number">43</span>])</span><br></pre></td></tr></table></figure><p><code>b[i]</code> 方括号中的表达式 <code>i</code> 被视为后面紧跟着 <code>:</code> 的多个实例，用于表示剩余轴。NumPy也允许你使用三个点写为 <code>b[i,...]</code>。</p><p>三个点（ <code>...</code> ）表示产生完整索引元组所需的冒号。例如，如果 <code>x</code> 是rank为5的数组（即，它具有5个轴），则：</p><ul><li><code>x[1,2,...]</code> 相当于 <code>x[1,2,:,:,:]</code>，</li><li><code>x[...,3]</code> 等效于 <code>x[:,:,:,:,3]</code></li><li><code>x[4,...,5,:]</code> 等效于 <code>x[4,:,:,5,:]</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = np.array( [[[  <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],               <span class="comment"># a 3D array (two stacked 2D arrays)</span></span><br><span class="line"><span class="meta">... </span>                [ <span class="number">10</span>, <span class="number">12</span>, <span class="number">13</span>]],</span><br><span class="line"><span class="meta">... </span>               [[<span class="number">100</span>,<span class="number">101</span>,<span class="number">102</span>],</span><br><span class="line"><span class="meta">... </span>                [<span class="number">110</span>,<span class="number">112</span>,<span class="number">113</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.shape</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="number">1</span>,...]                                   <span class="comment"># same as c[1,:,:] or c[1]</span></span><br><span class="line">array([[<span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>],</span><br><span class="line">       [<span class="number">110</span>, <span class="number">112</span>, <span class="number">113</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[...,<span class="number">2</span>]                                   <span class="comment"># same as c[:,:,2]</span></span><br><span class="line">array([[  <span class="number">2</span>,  <span class="number">13</span>],</span><br><span class="line">       [<span class="number">102</span>, <span class="number">113</span>]])</span><br></pre></td></tr></table></figure><p>对多维数组进行 <strong>迭代（Iterating）</strong> 是相对于第一个轴完成的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> row <span class="keyword">in</span> b:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(row)</span><br><span class="line">...</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line">[<span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span>]</span><br><span class="line">[<span class="number">20</span> <span class="number">21</span> <span class="number">22</span> <span class="number">23</span>]</span><br><span class="line">[<span class="number">30</span> <span class="number">31</span> <span class="number">32</span> <span class="number">33</span>]</span><br><span class="line">[<span class="number">40</span> <span class="number">41</span> <span class="number">42</span> <span class="number">43</span>]</span><br></pre></td></tr></table></figure><p>但是，如果想要对数组中的每个元素执行操作，可以使用<code>flat</code>属性，该属性是数组的所有元素的<a href="https://docs.python.org/tutorial/classes.html#iterators">迭代器open in new window</a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> element <span class="keyword">in</span> b.flat:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(element)</span><br><span class="line">...</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">31</span></span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">33</span></span><br><span class="line"><span class="number">40</span></span><br><span class="line"><span class="number">41</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="number">43</span></span><br></pre></td></tr></table></figure><p>另见</p><p><a href="https://www.numpy.org.cn/user/basics.indexing.html#basics-indexing">Indexing</a>, <a href="https://numpy.org/devdocs/reference/arrays.indexing.html#arrays-indexing">Indexingopen in new window</a> (reference), <a href="https://numpy.org/devdocs/reference/constants.html#numpy.newaxis"><code>newaxis</code>open in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.ndenumerate.html#numpy.ndenumerate"><code>ndenumerate</code>open in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.indices.html#numpy.indices"><code>indices</code>open in new window</a></p><h2 id="形状操纵"><a href="#形状操纵" class="headerlink" title="#形状操纵"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E5%BD%A2%E7%8A%B6%E6%93%8D%E7%BA%B5">#</a>形状操纵</h2><h3 id="改变数组的形状"><a href="#改变数组的形状" class="headerlink" title="#改变数组的形状"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E6%94%B9%E5%8F%98%E6%95%B0%E7%BB%84%E7%9A%84%E5%BD%A2%E7%8A%B6">#</a>改变数组的形状</h3><p>一个数组的形状是由每个轴的元素数量决定的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">2.</span>,  <span class="number">8.</span>,  <span class="number">0.</span>,  <span class="number">6.</span>],</span><br><span class="line">       [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>],</span><br><span class="line">       [ <span class="number">8.</span>,  <span class="number">9.</span>,  <span class="number">3.</span>,  <span class="number">6.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>可以使用各种命令更改数组的形状。请注意，以下三个命令都返回一个修改后的数组，但不会更改原始数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.ravel()  <span class="comment"># returns the array, flattened</span></span><br><span class="line">array([ <span class="number">2.</span>,  <span class="number">8.</span>,  <span class="number">0.</span>,  <span class="number">6.</span>,  <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">8.</span>,  <span class="number">9.</span>,  <span class="number">3.</span>,  <span class="number">6.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.reshape(<span class="number">6</span>,<span class="number">2</span>)  <span class="comment"># returns the array with a modified shape</span></span><br><span class="line">array([[ <span class="number">2.</span>,  <span class="number">8.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">6.</span>],</span><br><span class="line">       [ <span class="number">4.</span>,  <span class="number">5.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>],</span><br><span class="line">       [ <span class="number">8.</span>,  <span class="number">9.</span>],</span><br><span class="line">       [ <span class="number">3.</span>,  <span class="number">6.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.T  <span class="comment"># returns the array, transposed</span></span><br><span class="line">array([[ <span class="number">2.</span>,  <span class="number">4.</span>,  <span class="number">8.</span>],</span><br><span class="line">       [ <span class="number">8.</span>,  <span class="number">5.</span>,  <span class="number">9.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">6.</span>,  <span class="number">1.</span>,  <span class="number">6.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.T.shape</span><br><span class="line">(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>由 ravel() 产生的数组中元素的顺序通常是“C风格”，也就是说，最右边的索引“变化最快”，因此[0,0]之后的元素是[0,1] 。如果将数组重新整形为其他形状，则该数组将被视为“C风格”。NumPy通常创建按此顺序存储的数组，因此 ravel() 通常不需要复制其参数，但如果数组是通过获取另一个数组的切片或使用不常见的选项创建的，则可能需要复制它。还可以使用可选参数指示函数 ravel() 和 reshape()，以使用FORTRAN样式的数组，其中最左边的索引变化最快。</p><p>该<a href="https://numpy.org/devdocs/reference/generated/numpy.reshape.html#numpy.reshape"><code>reshape</code>open in new window</a>函数返回带有修改形状的参数，而该 <a href="https://numpy.org/devdocs/reference/generated/numpy.ndarray.resize.html#numpy.ndarray.resize"><code>ndarray.resize</code>open in new window</a>方法会修改数组本身：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">2.</span>,  <span class="number">8.</span>,  <span class="number">0.</span>,  <span class="number">6.</span>],</span><br><span class="line">       [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>],</span><br><span class="line">       [ <span class="number">8.</span>,  <span class="number">9.</span>,  <span class="number">3.</span>,  <span class="number">6.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.resize((<span class="number">2</span>,<span class="number">6</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">2.</span>,  <span class="number">8.</span>,  <span class="number">0.</span>,  <span class="number">6.</span>,  <span class="number">4.</span>,  <span class="number">5.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">8.</span>,  <span class="number">9.</span>,  <span class="number">3.</span>,  <span class="number">6.</span>]])</span><br></pre></td></tr></table></figure><p>如果在 reshape 操作中将 size 指定为-1，则会自动计算其他的 size 大小：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.reshape(<span class="number">3</span>,-<span class="number">1</span>)</span><br><span class="line">array([[ <span class="number">2.</span>,  <span class="number">8.</span>,  <span class="number">0.</span>,  <span class="number">6.</span>],</span><br><span class="line">       [ <span class="number">4.</span>,  <span class="number">5.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>],</span><br><span class="line">       [ <span class="number">8.</span>,  <span class="number">9.</span>,  <span class="number">3.</span>,  <span class="number">6.</span>]])</span><br></pre></td></tr></table></figure><p>另见</p><p><a href="https://numpy.org/devdocs/reference/generated/numpy.ndarray.shape.html#numpy.ndarray.shape"><code>ndarray.shape</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.reshape.html#numpy.reshape"><code>reshape</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.resize.html#numpy.resize"><code>resize</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.ravel.html#numpy.ravel"><code>ravel</code>open in new window</a></p><h3 id="将不同数组堆叠在一起"><a href="#将不同数组堆叠在一起" class="headerlink" title="#将不同数组堆叠在一起"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E5%B0%86%E4%B8%8D%E5%90%8C%E6%95%B0%E7%BB%84%E5%A0%86%E5%8F%A0%E5%9C%A8%E4%B8%80%E8%B5%B7">#</a>将不同数组堆叠在一起</h3><p>几个数组可以沿不同的轴堆叠在一起，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">8.</span>,  <span class="number">8.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">8.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">4.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.vstack((a,b))</span><br><span class="line">array([[ <span class="number">8.</span>,  <span class="number">8.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">8.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">4.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.hstack((a,b))</span><br><span class="line">array([[ <span class="number">8.</span>,  <span class="number">8.</span>,  <span class="number">1.</span>,  <span class="number">8.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">4.</span>]])</span><br></pre></td></tr></table></figure><p>该函数将<a href="https://numpy.org/devdocs/reference/generated/numpy.column_stack.html#numpy.column_stack"><code>column_stack</code>open in new window</a> 1D数组作为列堆叠到2D数组中。它仅相当于 <a href="https://numpy.org/devdocs/reference/generated/numpy.hstack.html#numpy.hstack"><code>hstack</code>open in new window</a>2D数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> numpy <span class="keyword">import</span> newaxis</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.column_stack((a,b))     <span class="comment"># with 2D arrays</span></span><br><span class="line">array([[ <span class="number">8.</span>,  <span class="number">8.</span>,  <span class="number">1.</span>,  <span class="number">8.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">4.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([<span class="number">4.</span>,<span class="number">2.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.array([<span class="number">3.</span>,<span class="number">8.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.column_stack((a,b))     <span class="comment"># returns a 2D array</span></span><br><span class="line">array([[ <span class="number">4.</span>, <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">2.</span>, <span class="number">8.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.hstack((a,b))           <span class="comment"># the result is different</span></span><br><span class="line">array([ <span class="number">4.</span>, <span class="number">2.</span>, <span class="number">3.</span>, <span class="number">8.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:,newaxis]               <span class="comment"># this allows to have a 2D columns vector</span></span><br><span class="line">array([[ <span class="number">4.</span>],</span><br><span class="line">       [ <span class="number">2.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.column_stack((a[:,newaxis],b[:,newaxis]))</span><br><span class="line">array([[ <span class="number">4.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">2.</span>,  <span class="number">8.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.hstack((a[:,newaxis],b[:,newaxis]))   <span class="comment"># the result is the same</span></span><br><span class="line">array([[ <span class="number">4.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">2.</span>,  <span class="number">8.</span>]])</span><br></pre></td></tr></table></figure><p>另一方面，该函数<a href="https://numpy.org/devdocs/reference/generated/numpy.ma.row_stack.html#numpy.ma.row_stack"><code>ma.row_stack</code>open in new window</a>等效<a href="https://numpy.org/devdocs/reference/generated/numpy.vstack.html#numpy.vstack"><code>vstack</code>open in new window</a> 于任何输入数组。通常，对于具有两个以上维度的数组， <a href="https://numpy.org/devdocs/reference/generated/numpy.hstack.html#numpy.hstack"><code>hstack</code>open in new window</a>沿其第二轴<a href="https://numpy.org/devdocs/reference/generated/numpy.vstack.html#numpy.vstack"><code>vstack</code>open in new window</a>堆叠，沿其第一轴堆叠，并<a href="https://numpy.org/devdocs/reference/generated/numpy.concatenate.html#numpy.concatenate"><code>concatenate</code>open in new window</a> 允许可选参数给出连接应发生的轴的编号。</p><p><strong>注意</strong></p><p>在复杂的情况下，<a href="https://numpy.org/devdocs/reference/generated/numpy.r_.html#numpy.r_"><code>r_</code>open in new window</a>和c <a href="https://numpy.org/devdocs/reference/generated/numpy.c_.html#numpy.c_"><code>c_</code>open in new window</a>于通过沿一个轴堆叠数字来创建数组很有用。它们允许使用范围操作符(“：”)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.r_[<span class="number">1</span>:<span class="number">4</span>,<span class="number">0</span>,<span class="number">4</span>]</span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure><p>与数组一起用作参数时， <a href="https://numpy.org/devdocs/reference/generated/numpy.r_.html#numpy.r_"><code>r_</code>open in new window</a> 和 <a href="https://numpy.org/devdocs/reference/generated/numpy.c_.html#numpy.c_"><code>c_</code>open in new window</a> 在默认行为上类似于 <a href="https://numpy.org/devdocs/reference/generated/numpy.vstack.html#numpy.vstack"><code>vstack</code>open in new window</a> 和 <a href="https://numpy.org/devdocs/reference/generated/numpy.hstack.html#numpy.hstack"><code>hstack</code>open in new window</a> ，但允许使用可选参数给出要连接的轴的编号。</p><p>另见</p><p><a href="https://numpy.org/devdocs/reference/generated/numpy.hstack.html#numpy.hstack"><code>hstack</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.vstack.html#numpy.vstack"><code>vstack</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.column_stack.html#numpy.column_stack"><code>column_stack</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.concatenate.html#numpy.concatenate"><code>concatenate</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.c_.html#numpy.c_"><code>c_</code>open in new window</a>， <a href="https://numpy.org/devdocs/reference/generated/numpy.r_.html#numpy.r_"><code>r_</code>open in new window</a></p><h3 id="将一个数组拆分成几个较小的数组"><a href="#将一个数组拆分成几个较小的数组" class="headerlink" title="#将一个数组拆分成几个较小的数组"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E5%B0%86%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%E6%88%90%E5%87%A0%E4%B8%AA%E8%BE%83%E5%B0%8F%E7%9A%84%E6%95%B0%E7%BB%84">#</a>将一个数组拆分成几个较小的数组</h3><p>使用<a href="https://numpy.org/devdocs/reference/generated/numpy.hsplit.html#numpy.hsplit"><code>hsplit</code>open in new window</a>，可以沿数组的水平轴拆分数组，方法是指定要返回的形状相等的数组的数量，或者指定应该在其之后进行分割的列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">12</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">9.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">3.</span>,  <span class="number">6.</span>,  <span class="number">8.</span>,  <span class="number">0.</span>,  <span class="number">7.</span>,  <span class="number">9.</span>,  <span class="number">7.</span>,  <span class="number">2.</span>,  <span class="number">7.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">4.</span>,  <span class="number">9.</span>,  <span class="number">2.</span>,  <span class="number">2.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">6.</span>,  <span class="number">2.</span>,  <span class="number">2.</span>,  <span class="number">4.</span>,  <span class="number">0.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.hsplit(a,<span class="number">3</span>)   <span class="comment"># Split a into 3</span></span><br><span class="line">[array([[ <span class="number">9.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">4.</span>,  <span class="number">9.</span>,  <span class="number">2.</span>]]), array([[ <span class="number">6.</span>,  <span class="number">8.</span>,  <span class="number">0.</span>,  <span class="number">7.</span>],</span><br><span class="line">       [ <span class="number">2.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">6.</span>]]), array([[ <span class="number">9.</span>,  <span class="number">7.</span>,  <span class="number">2.</span>,  <span class="number">7.</span>],</span><br><span class="line">       [ <span class="number">2.</span>,  <span class="number">2.</span>,  <span class="number">4.</span>,  <span class="number">0.</span>]])]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.hsplit(a,(<span class="number">3</span>,<span class="number">4</span>))   <span class="comment"># Split a after the third and the fourth column</span></span><br><span class="line">[array([[ <span class="number">9.</span>,  <span class="number">5.</span>,  <span class="number">6.</span>],</span><br><span class="line">       [ <span class="number">1.</span>,  <span class="number">4.</span>,  <span class="number">9.</span>]]), array([[ <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">2.</span>]]), array([[ <span class="number">6.</span>,  <span class="number">8.</span>,  <span class="number">0.</span>,  <span class="number">7.</span>,  <span class="number">9.</span>,  <span class="number">7.</span>,  <span class="number">2.</span>,  <span class="number">7.</span>],</span><br><span class="line">       [ <span class="number">2.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">6.</span>,  <span class="number">2.</span>,  <span class="number">2.</span>,  <span class="number">4.</span>,  <span class="number">0.</span>]])]</span><br></pre></td></tr></table></figure><p><a href="https://numpy.org/devdocs/reference/generated/numpy.vsplit.html#numpy.vsplit"><code>vsplit</code>open in new window</a>沿垂直轴分割，并<a href="https://numpy.org/devdocs/reference/generated/numpy.array_split.html#numpy.array_split"><code>array_split</code>open in new window</a>允许指定要分割的轴。</p><h2 id="拷贝和视图"><a href="#拷贝和视图" class="headerlink" title="#拷贝和视图"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E6%8B%B7%E8%B4%9D%E5%92%8C%E8%A7%86%E5%9B%BE">#</a>拷贝和视图</h2><p>当计算和操作数组时，有时会将数据复制到新数组中，有时则不会。这通常是初学者混淆的根源。有三种情况：</p><h3 id="完全不复制"><a href="#完全不复制" class="headerlink" title="#完全不复制"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E5%AE%8C%E5%85%A8%E4%B8%8D%E5%A4%8D%E5%88%B6">#</a>完全不复制</h3><p>简单分配不会复制数组对象或其数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a            <span class="comment"># no new object is created</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a           <span class="comment"># a and b are two names for the same ndarray object</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.shape = <span class="number">3</span>,<span class="number">4</span>    <span class="comment"># changes the shape of a</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>Python将可变对象作为引用传递，因此函数调用不会复制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="built_in">id</span>(x))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(a)                           <span class="comment"># id is a unique identifier of an object</span></span><br><span class="line"><span class="number">148293216</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(a)</span><br><span class="line"><span class="number">148293216</span></span><br></pre></td></tr></table></figure><h3 id="视图或浅拷贝"><a href="#视图或浅拷贝" class="headerlink" title="#视图或浅拷贝"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E8%A7%86%E5%9B%BE%E6%88%96%E6%B5%85%E6%8B%B7%E8%B4%9D">#</a>视图或浅拷贝</h3><p>不同的数组对象可以共享相同的数据。该<code>view</code>方法创建一个查看相同数据的新数组对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = a.view()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.base <span class="keyword">is</span> a                        <span class="comment"># c is a view of the data owned by a</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.flags.owndata</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.shape = <span class="number">2</span>,<span class="number">6</span>                      <span class="comment"># a&#x27;s shape doesn&#x27;t change</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="number">0</span>,<span class="number">4</span>] = <span class="number">1234</span>                      <span class="comment"># a&#x27;s data changes</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[   <span class="number">0</span>,    <span class="number">1</span>,    <span class="number">2</span>,    <span class="number">3</span>],</span><br><span class="line">       [<span class="number">1234</span>,    <span class="number">5</span>,    <span class="number">6</span>,    <span class="number">7</span>],</span><br><span class="line">       [   <span class="number">8</span>,    <span class="number">9</span>,   <span class="number">10</span>,   <span class="number">11</span>]])</span><br></pre></td></tr></table></figure><p>切片数组会返回一个视图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = a[ : , <span class="number">1</span>:<span class="number">3</span>]     <span class="comment"># spaces added for clarity; could also be written &quot;s = a[:,1:3]&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[:] = <span class="number">10</span>           <span class="comment"># s[:] is a view of s. Note the difference between s=10 and s[:]=10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[   <span class="number">0</span>,   <span class="number">10</span>,   <span class="number">10</span>,    <span class="number">3</span>],</span><br><span class="line">       [<span class="number">1234</span>,   <span class="number">10</span>,   <span class="number">10</span>,    <span class="number">7</span>],</span><br><span class="line">       [   <span class="number">8</span>,   <span class="number">10</span>,   <span class="number">10</span>,   <span class="number">11</span>]])</span><br></pre></td></tr></table></figure><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="#深拷贝"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E6%B7%B1%E6%8B%B7%E8%B4%9D">#</a>深拷贝</h3><p>该<code>copy</code>方法生成数组及其数据的完整副本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = a.copy()                          <span class="comment"># a new array object with new data is created</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.base <span class="keyword">is</span> a                           <span class="comment"># d doesn&#x27;t share anything with a</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">9999</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[   <span class="number">0</span>,   <span class="number">10</span>,   <span class="number">10</span>,    <span class="number">3</span>],</span><br><span class="line">       [<span class="number">1234</span>,   <span class="number">10</span>,   <span class="number">10</span>,    <span class="number">7</span>],</span><br><span class="line">       [   <span class="number">8</span>,   <span class="number">10</span>,   <span class="number">10</span>,   <span class="number">11</span>]])</span><br></pre></td></tr></table></figure><p>有时，如果不再需要原始数组，则应在切片后调用 <code>copy</code>。例如，假设a是一个巨大的中间结果，最终结果b只包含a的一小部分，那么在用切片构造b时应该做一个深拷贝：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="built_in">int</span>(<span class="number">1e8</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a[:<span class="number">100</span>].copy()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a  <span class="comment"># the memory of ``a`` can be released.</span></span><br></pre></td></tr></table></figure><p>如果改为使用 <code>b = a[:100]</code>，则 <code>a</code> 由 <code>b</code> 引用，并且即使执行 <code>del a</code> 也会在内存中持久存在。</p><h3 id="功能和方法概述"><a href="#功能和方法概述" class="headerlink" title="#功能和方法概述"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E5%8A%9F%E8%83%BD%E5%92%8C%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0">#</a>功能和方法概述</h3><p>以下是按类别排序的一些有用的NumPy函数和方法名称的列表。有关完整列表，请参阅<a href="https://www.numpy.org.cn/reference/">参考手册</a>里的<a href="https://www.numpy.org.cn/reference/routines/">常用API</a>。</p><ul><li><strong>数组的创建（Array Creation）</strong> - <a href="https://numpy.org/devdocs/reference/generated/numpy.arange.html#numpy.arange">arangeopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.array.html#numpy.array">arrayopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.copy.html#numpy.copy">copyopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.empty.html#numpy.empty">emptyopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.empty_like.html#numpy.empty_like">empty_likeopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.eye.html#numpy.eye">eyeopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.fromfile.html#numpy.fromfile">fromfileopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.fromfunction.html#numpy.fromfunction">fromfunctionopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.identity.html#numpy.identity">identityopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.linspace.html#numpy.linspace">linspaceopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.logspace.html#numpy.logspace">logspaceopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.mgrid.html#numpy.mgrid">mgridopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.ogrid.html#numpy.ogrid">ogridopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.ones.html#numpy.ones">onesopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.ones_like.html#numpy.ones_like">ones_likeopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.zeros.html#numpy.zeros">zerosopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.zeros_like.html#numpy.zeros_like">zeros_likeopen in new window</a></li><li><strong>转换和变换（Conversions）</strong> - <a href="https://numpy.org/devdocs/reference/generated/numpy.ndarray.astype.html#numpy.ndarray.astype">ndarray.astypeopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.atleast_1d.html#numpy.atleast_1d">atleast_1dopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.atleast_2d.html#numpy.atleast_2d">atleast_2dopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.atleast_3d.html#numpy.atleast_3d">atleast_3dopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.mat.html#numpy.mat">matopen in new window</a></li><li><strong>操纵术（Manipulations）</strong> - <a href="https://numpy.org/devdocs/reference/generated/numpy.array_split.html#numpy.array_split">array_splitopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.column_stack.html#numpy.column_stack">column_stackopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.concatenate.html#numpy.concatenate">concatenateopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.diagonal.html#numpy.diagonal">diagonalopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.dsplit.html#numpy.dsplit">dsplitopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.dstack.html#numpy.dstack">dstackopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.hsplit.html#numpy.hsplit">hsplitopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.hstack.html#numpy.hstack">hstackopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.ndarray.item.html#numpy.ndarray.item">ndarray.itemopen in new window</a>, <a href="https://www.numpy.org.cn/reference/constants.html#numpy.newaxis">newaxis</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.ravel.html#numpy.ravel">ravelopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.repeat.html#numpy.repeat">repeatopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.reshape.html#numpy.reshape">reshapeopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.resize.html#numpy.resize">resizeopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.squeeze.html#numpy.squeeze">squeezeopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.swapaxes.html#numpy.swapaxes">swapaxesopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.take.html#numpy.take">takeopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.transpose.html#numpy.transpose">transposeopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.vsplit.html#numpy.vsplit">vsplitopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.vstack.html#numpy.vstack">vstackopen in new window</a></li><li><strong>询问（Questions）</strong> - <a href="https://numpy.org/devdocs/reference/generated/numpy.all.html#numpy.all">allopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.any.html#numpy.any">anyopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.nonzero.html#numpy.nonzero">nonzeroopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.where.html#numpy.where">whereopen in new window</a>,</li><li><strong>顺序（Ordering）</strong> - <a href="https://numpy.org/devdocs/reference/generated/numpy.argmax.html#numpy.argmax">argmaxopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.argmin.html#numpy.argmin">argminopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.argsort.html#numpy.argsort">argsortopen in new window</a>, <a href="https://docs.python.org/dev/library/functions.html#max">maxopen in new window</a>, <a href="https://docs.python.org/dev/library/functions.html#min">minopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.ptp.html#numpy.ptp">ptpopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.searchsorted.html#numpy.searchsorted">searchsortedopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.sort.html#numpy.sort">sortopen in new window</a></li><li><strong>操作（Operations）</strong> - <a href="https://numpy.org/devdocs/reference/generated/numpy.choose.html#numpy.choose">chooseopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.compress.html#numpy.compress">compressopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.cumprod.html#numpy.cumprod">cumprodopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.cumsum.html#numpy.cumsum">cumsumopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.inner.html#numpy.inner">inneropen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.ndarray.fill.html#numpy.ndarray.fill">ndarray.fillopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.imag.html#numpy.imag">imagopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.prod.html#numpy.prod">prodopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.put.html#numpy.put">putopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.putmask.html#numpy.putmask">putmaskopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.real.html#numpy.real">realopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.sum.html#numpy.sum">sumopen in new window</a></li><li><strong>基本统计（Basic Statistics）</strong> - <a href="https://numpy.org/devdocs/reference/generated/numpy.cov.html#numpy.cov">covopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.mean.html#numpy.mean">meanopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.std.html#numpy.std">stdopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.var.html#numpy.var">varopen in new window</a></li><li><strong>基本线性代数（Basic Linear Algebra）</strong> - <a href="https://numpy.org/devdocs/reference/generated/numpy.cross.html#numpy.cross">crossopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.dot.html#numpy.dot">dotopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.outer.html#numpy.outer">outeropen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.linalg.svd.html#numpy.linalg.svd">linalg.svdopen in new window</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.vdot.html#numpy.vdot">vdotopen in new window</a></li></ul><h2 id="Less-基础"><a href="#Less-基础" class="headerlink" title="#Less 基础"></a><a href="https://www.numpy.org.cn/user/quickstart.html#less-%E5%9F%BA%E7%A1%80">#</a>Less 基础</h2><h3 id="广播（Broadcasting）规则"><a href="#广播（Broadcasting）规则" class="headerlink" title="#广播（Broadcasting）规则"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E5%B9%BF%E6%92%AD-broadcasting-%E8%A7%84%E5%88%99">#</a>广播（Broadcasting）规则</h3><p>广播允许通用功能以有意义的方式处理不具有完全相同形状的输入。</p><p>广播的第一个规则是，如果所有输入数组不具有相同数量的维度，则将“1”重复地预先添加到较小数组的形状，直到所有数组具有相同数量的维度。</p><p>广播的第二个规则确保沿特定维度的大小为1的数组表现为具有沿该维度具有最大形状的数组的大小。假定数组元素的值沿着“广播”数组的那个维度是相同的。</p><p>应用广播规则后，所有数组的大小必须匹配。更多细节可以在<a href="https://www.numpy.org.cn/user/basics/broadcasting.html">广播中</a>找到。</p><h2 id="花式索引和索引技巧"><a href="#花式索引和索引技巧" class="headerlink" title="#花式索引和索引技巧"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E8%8A%B1%E5%BC%8F%E7%B4%A2%E5%BC%95%E5%92%8C%E7%B4%A2%E5%BC%95%E6%8A%80%E5%B7%A7">#</a>花式索引和索引技巧</h2><p>NumPy提供比常规Python序列更多的索引功能。除了通过整数和切片进行索引之外，正如我们之前看到的，数组可以由整数数组和布尔数组索引。</p><h3 id="使用索引数组进行索引"><a href="#使用索引数组进行索引" class="headerlink" title="#使用索引数组进行索引"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E7%B4%A2%E5%BC%95">#</a>使用索引数组进行索引</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">12</span>)**<span class="number">2</span>                       <span class="comment"># the first 12 square numbers</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = np.array( [ <span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">5</span> ] )              <span class="comment"># an array of indices</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[i]                                       <span class="comment"># the elements of a at the positions i</span></span><br><span class="line">array([ <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">9</span>, <span class="number">64</span>, <span class="number">25</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>j = np.array( [ [ <span class="number">3</span>, <span class="number">4</span>], [ <span class="number">9</span>, <span class="number">7</span> ] ] )      <span class="comment"># a bidimensional array of indices</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[j]                                       <span class="comment"># the same shape as j</span></span><br><span class="line">array([[ <span class="number">9</span>, <span class="number">16</span>],</span><br><span class="line">       [<span class="number">81</span>, <span class="number">49</span>]])</span><br></pre></td></tr></table></figure><p>当索引数组<code>a</code>是多维的时，单个索引数组指的是第一个维度<code>a</code>。以下示例通过使用调色板将标签图像转换为彩色图像来显示此行为。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>palette = np.array( [ [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],                <span class="comment"># black</span></span><br><span class="line"><span class="meta">... </span>                      [<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>],              <span class="comment"># red</span></span><br><span class="line"><span class="meta">... </span>                      [<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>],              <span class="comment"># green</span></span><br><span class="line"><span class="meta">... </span>                      [<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>],              <span class="comment"># blue</span></span><br><span class="line"><span class="meta">... </span>                      [<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>] ] )       <span class="comment"># white</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image = np.array( [ [ <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span> ],           <span class="comment"># each value corresponds to a color in the palette</span></span><br><span class="line"><span class="meta">... </span>                    [ <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span> ]  ] )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>palette[image]                            <span class="comment"># the (2,4,3) color image</span></span><br><span class="line">array([[[  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>],</span><br><span class="line">        [<span class="number">255</span>,   <span class="number">0</span>,   <span class="number">0</span>],</span><br><span class="line">        [  <span class="number">0</span>, <span class="number">255</span>,   <span class="number">0</span>],</span><br><span class="line">        [  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>]],</span><br><span class="line">       [[  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>],</span><br><span class="line">        [  <span class="number">0</span>,   <span class="number">0</span>, <span class="number">255</span>],</span><br><span class="line">        [<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>],</span><br><span class="line">        [  <span class="number">0</span>,   <span class="number">0</span>,   <span class="number">0</span>]]])</span><br></pre></td></tr></table></figure><p>我们还可以为多个维度提供索引。每个维度的索引数组必须具有相同的形状。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = np.array( [ [<span class="number">0</span>,<span class="number">1</span>],                        <span class="comment"># indices for the first dim of a</span></span><br><span class="line"><span class="meta">... </span>                [<span class="number">1</span>,<span class="number">2</span>] ] )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>j = np.array( [ [<span class="number">2</span>,<span class="number">1</span>],                        <span class="comment"># indices for the second dim</span></span><br><span class="line"><span class="meta">... </span>                [<span class="number">3</span>,<span class="number">3</span>] ] )</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[i,j]                                     <span class="comment"># i and j must have equal shape</span></span><br><span class="line">array([[ <span class="number">2</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">7</span>, <span class="number">11</span>]])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[i,<span class="number">2</span>]</span><br><span class="line">array([[ <span class="number">2</span>,  <span class="number">6</span>],</span><br><span class="line">       [ <span class="number">6</span>, <span class="number">10</span>]])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:,j]                                     <span class="comment"># i.e., a[ : , j]</span></span><br><span class="line">array([[[ <span class="number">2</span>,  <span class="number">1</span>],</span><br><span class="line">        [ <span class="number">3</span>,  <span class="number">3</span>]],</span><br><span class="line">       [[ <span class="number">6</span>,  <span class="number">5</span>],</span><br><span class="line">        [ <span class="number">7</span>,  <span class="number">7</span>]],</span><br><span class="line">       [[<span class="number">10</span>,  <span class="number">9</span>],</span><br><span class="line">        [<span class="number">11</span>, <span class="number">11</span>]]])</span><br></pre></td></tr></table></figure><p>当然，我们可以按顺序（比如列表）放入<code>i</code>，<code>j</code>然后使用列表进行索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [i,j]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[l]                                       <span class="comment"># equivalent to a[i,j]</span></span><br><span class="line">array([[ <span class="number">2</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">7</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure><p>但是，我们不能通过放入<code>i</code>和<code>j</code>放入数组来实现这一点，因为这个数组将被解释为索引a的第一个维度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = np.array( [i,j] )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[s]                                       <span class="comment"># not what we want</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> ?</span><br><span class="line">IndexError: index (<span class="number">3</span>) out of <span class="built_in">range</span> (<span class="number">0</span>&lt;=index&lt;=<span class="number">2</span>) <span class="keyword">in</span> dimension <span class="number">0</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="built_in">tuple</span>(s)]                                <span class="comment"># same as a[i,j]</span></span><br><span class="line">array([[ <span class="number">2</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">7</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure><p>使用数组索引的另一个常见用法是搜索与时间相关的系列的最大值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>time = np.linspace(<span class="number">20</span>, <span class="number">145</span>, <span class="number">5</span>)                 <span class="comment"># time scale</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = np.sin(np.arange(<span class="number">20</span>)).reshape(<span class="number">5</span>,<span class="number">4</span>)      <span class="comment"># 4 time-dependent series</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time</span><br><span class="line">array([  <span class="number">20.</span>  ,   <span class="number">51.25</span>,   <span class="number">82.5</span> ,  <span class="number">113.75</span>,  <span class="number">145.</span>  ])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data</span><br><span class="line">array([[ <span class="number">0.</span>        ,  <span class="number">0.84147098</span>,  <span class="number">0.90929743</span>,  <span class="number">0.14112001</span>],</span><br><span class="line">       [-<span class="number">0.7568025</span> , -<span class="number">0.95892427</span>, -<span class="number">0.2794155</span> ,  <span class="number">0.6569866</span> ],</span><br><span class="line">       [ <span class="number">0.98935825</span>,  <span class="number">0.41211849</span>, -<span class="number">0.54402111</span>, -<span class="number">0.99999021</span>],</span><br><span class="line">       [-<span class="number">0.53657292</span>,  <span class="number">0.42016704</span>,  <span class="number">0.99060736</span>,  <span class="number">0.65028784</span>],</span><br><span class="line">       [-<span class="number">0.28790332</span>, -<span class="number">0.96139749</span>, -<span class="number">0.75098725</span>,  <span class="number">0.14987721</span>]])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ind = data.argmax(axis=<span class="number">0</span>)                  <span class="comment"># index of the maxima for each series</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ind</span><br><span class="line">array([<span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time_max = time[ind]                       <span class="comment"># times corresponding to the maxima</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data_max = data[ind, <span class="built_in">range</span>(data.shape[<span class="number">1</span>])] <span class="comment"># =&gt; data[ind[0],0], data[ind[1],1]...</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time_max</span><br><span class="line">array([  <span class="number">82.5</span> ,   <span class="number">20.</span>  ,  <span class="number">113.75</span>,   <span class="number">51.25</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data_max</span><br><span class="line">array([ <span class="number">0.98935825</span>,  <span class="number">0.84147098</span>,  <span class="number">0.99060736</span>,  <span class="number">0.6569866</span> ])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.<span class="built_in">all</span>(data_max == data.<span class="built_in">max</span>(axis=<span class="number">0</span>))</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>您还可以使用数组索引作为分配给的目标：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]] = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>但是，当索引列表包含重复时，分配会多次完成，留下最后一个值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>]]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure><p>这是合理的，但请注意是否要使用Python的 <code>+=</code>构造，因为它可能不会按预期执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>]]+=<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure><p>即使0在索引列表中出现两次，第0个元素也只增加一次。这是因为Python要求“a + &#x3D; 1”等同于“a &#x3D; a + 1”。</p><h3 id="使用布尔数组进行索引"><a href="#使用布尔数组进行索引" class="headerlink" title="#使用布尔数组进行索引"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E4%BD%BF%E7%94%A8%E5%B8%83%E5%B0%94%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E7%B4%A2%E5%BC%95">#</a>使用布尔数组进行索引</h3><p>当我们使用（整数）索引数组索引数组时，我们提供了要选择的索引列表。使用布尔索引，方法是不同的; 我们明确地选择我们想要的数组中的哪些项目以及我们不需要的项目。</p><p>人们可以想到的最自然的布尔索引方法是使用与原始数组具有 <em>相同形状的</em> 布尔数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a &gt; <span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b                                          <span class="comment"># b is a boolean with a&#x27;s shape</span></span><br><span class="line">array([[<span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>],</span><br><span class="line">       [<span class="literal">False</span>,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>],</span><br><span class="line">       [ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[b]                                       <span class="comment"># 1d array with the selected elements</span></span><br><span class="line">array([ <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br></pre></td></tr></table></figure><p>此属性在分配中非常有用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[b] = <span class="number">0</span>                                   <span class="comment"># All elements of &#x27;a&#x27; higher than 4 become 0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure><p>您可以查看以下示例，了解如何使用布尔索引生成<a href="https://en.wikipedia.org/wiki/Mandelbrot_set">Mandelbrot集open in new window</a>的图像：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">mandelbrot</span>(<span class="params"> h,w, maxit=<span class="number">20</span> </span>):</span><br><span class="line"><span class="meta">... </span>    <span class="string">&quot;&quot;&quot;Returns an image of the Mandelbrot fractal of size (h,w).&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">... </span>    y,x = np.ogrid[ -<span class="number">1.4</span>:<span class="number">1.4</span>:h*<span class="number">1j</span>, -<span class="number">2</span>:<span class="number">0.8</span>:w*<span class="number">1j</span> ]</span><br><span class="line"><span class="meta">... </span>    c = x+y*<span class="number">1j</span></span><br><span class="line"><span class="meta">... </span>    z = c</span><br><span class="line"><span class="meta">... </span>    divtime = maxit + np.zeros(z.shape, dtype=<span class="built_in">int</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(maxit):</span><br><span class="line"><span class="meta">... </span>        z = z**<span class="number">2</span> + c</span><br><span class="line"><span class="meta">... </span>        diverge = z*np.conj(z) &gt; <span class="number">2</span>**<span class="number">2</span>            <span class="comment"># who is diverging</span></span><br><span class="line"><span class="meta">... </span>        div_now = diverge &amp; (divtime==maxit)  <span class="comment"># who is diverging now</span></span><br><span class="line"><span class="meta">... </span>        divtime[div_now] = i                  <span class="comment"># note when</span></span><br><span class="line"><span class="meta">... </span>        z[diverge] = <span class="number">2</span>                        <span class="comment"># avoid diverging too much</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> divtime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.imshow(mandelbrot(<span class="number">400</span>,<span class="number">400</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://www.numpy.org.cn/static/images/quickstart-1.png" alt="quickstart-1"></p><p>使用布尔值进行索引的第二种方法更类似于整数索引; 对于数组的每个维度，我们给出一个1D布尔数组，选择我们想要的切片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b1 = np.array([<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">True</span>])             <span class="comment"># first dim selection</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b2 = np.array([<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">True</span>,<span class="literal">False</span>])       <span class="comment"># second dim selection</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[b1,:]                                   <span class="comment"># selecting rows</span></span><br><span class="line">array([[ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[b1]                                     <span class="comment"># same thing</span></span><br><span class="line">array([[ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[:,b2]                                   <span class="comment"># selecting columns</span></span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">6</span>],</span><br><span class="line">       [ <span class="number">8</span>, <span class="number">10</span>]])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[b1,b2]                                  <span class="comment"># a weird thing to do</span></span><br><span class="line">array([ <span class="number">4</span>, <span class="number">10</span>])</span><br></pre></td></tr></table></figure><p>请注意，1D布尔数组的长度必须与要切片的尺寸（或轴）的长度一致。在前面的例子中，<code>b1</code>具有长度为3（的数目 <em>的行</em> 中<code>a</code>），和 <code>b2</code>（长度4）适合于索引的第二轴线（列） <code>a</code>。</p><h3 id="ix-函数"><a href="#ix-函数" class="headerlink" title="#ix_()函数"></a><a href="https://www.numpy.org.cn/user/quickstart.html#ix-%E5%87%BD%E6%95%B0">#</a>ix_()函数</h3><p><a href="https://numpy.org/devdocs/reference/generated/numpy.ix_.html#numpy.ix_"><code>ix_</code>open in new window</a>函数可用于组合不同的向量，以便获得每个n-uplet的结果。例如，如果要计算从每个向量a，b和c中取得的所有三元组的所有a + b * c：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.array([<span class="number">8</span>,<span class="number">5</span>,<span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = np.array([<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax,bx,cx = np.ix_(a,b,c)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax</span><br><span class="line">array([[[<span class="number">2</span>]],</span><br><span class="line">       [[<span class="number">3</span>]],</span><br><span class="line">       [[<span class="number">4</span>]],</span><br><span class="line">       [[<span class="number">5</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bx</span><br><span class="line">array([[[<span class="number">8</span>],</span><br><span class="line">        [<span class="number">5</span>],</span><br><span class="line">        [<span class="number">4</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cx</span><br><span class="line">array([[[<span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">3</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.shape, bx.shape, cx.shape</span><br><span class="line">((<span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result = ax+bx*cx</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result</span><br><span class="line">array([[[<span class="number">42</span>, <span class="number">34</span>, <span class="number">50</span>, <span class="number">66</span>, <span class="number">26</span>],</span><br><span class="line">        [<span class="number">27</span>, <span class="number">22</span>, <span class="number">32</span>, <span class="number">42</span>, <span class="number">17</span>],</span><br><span class="line">        [<span class="number">22</span>, <span class="number">18</span>, <span class="number">26</span>, <span class="number">34</span>, <span class="number">14</span>]],</span><br><span class="line">       [[<span class="number">43</span>, <span class="number">35</span>, <span class="number">51</span>, <span class="number">67</span>, <span class="number">27</span>],</span><br><span class="line">        [<span class="number">28</span>, <span class="number">23</span>, <span class="number">33</span>, <span class="number">43</span>, <span class="number">18</span>],</span><br><span class="line">        [<span class="number">23</span>, <span class="number">19</span>, <span class="number">27</span>, <span class="number">35</span>, <span class="number">15</span>]],</span><br><span class="line">       [[<span class="number">44</span>, <span class="number">36</span>, <span class="number">52</span>, <span class="number">68</span>, <span class="number">28</span>],</span><br><span class="line">        [<span class="number">29</span>, <span class="number">24</span>, <span class="number">34</span>, <span class="number">44</span>, <span class="number">19</span>],</span><br><span class="line">        [<span class="number">24</span>, <span class="number">20</span>, <span class="number">28</span>, <span class="number">36</span>, <span class="number">16</span>]],</span><br><span class="line">       [[<span class="number">45</span>, <span class="number">37</span>, <span class="number">53</span>, <span class="number">69</span>, <span class="number">29</span>],</span><br><span class="line">        [<span class="number">30</span>, <span class="number">25</span>, <span class="number">35</span>, <span class="number">45</span>, <span class="number">20</span>],</span><br><span class="line">        [<span class="number">25</span>, <span class="number">21</span>, <span class="number">29</span>, <span class="number">37</span>, <span class="number">17</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>result[<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">3</span>]+b[<span class="number">2</span>]*c[<span class="number">4</span>]</span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure><p>您还可以按如下方式实现reduce：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">ufunc_reduce</span>(<span class="params">ufct, *vectors</span>):</span><br><span class="line"><span class="meta">... </span>   vs = np.ix_(*vectors)</span><br><span class="line"><span class="meta">... </span>   r = ufct.identity</span><br><span class="line"><span class="meta">... </span>   <span class="keyword">for</span> v <span class="keyword">in</span> vs:</span><br><span class="line"><span class="meta">... </span>       r = ufct(r,v)</span><br><span class="line"><span class="meta">... </span>   <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><p>然后将其用作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ufunc_reduce(np.add,a,b,c)</span><br><span class="line">array([[[<span class="number">15</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">13</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">10</span>],</span><br><span class="line">        [<span class="number">11</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>,  <span class="number">9</span>]],</span><br><span class="line">       [[<span class="number">16</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">14</span>],</span><br><span class="line">        [<span class="number">13</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">11</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">10</span>]],</span><br><span class="line">       [[<span class="number">17</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">15</span>],</span><br><span class="line">        [<span class="number">14</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">12</span>],</span><br><span class="line">        [<span class="number">13</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">11</span>]],</span><br><span class="line">       [[<span class="number">18</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">21</span>, <span class="number">16</span>],</span><br><span class="line">        [<span class="number">15</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">13</span>],</span><br><span class="line">        [<span class="number">14</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">12</span>]]])</span><br></pre></td></tr></table></figure><p>与普通的ufunc.reduce相比，这个版本的reduce的优点是它利用了广播规则 ，以避免创建一个参数数组，输出的大小乘以向量的数量。</p><h3 id="使用字符串建立索引"><a href="#使用字符串建立索引" class="headerlink" title="#使用字符串建立索引"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95">#</a>使用字符串建立索引</h3><p>请参见<a href="https://www.numpy.org.cn/user/basics/rec.html">结构化数组</a>。</p><h2 id="线性代数"><a href="#线性代数" class="headerlink" title="#线性代数"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0">#</a>线性代数</h2><p>工作正在进行中。这里包括基本线性代数。</p><h3 id="简单数组操作"><a href="#简单数组操作" class="headerlink" title="#简单数组操作"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E7%AE%80%E5%8D%95%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C">#</a>简单数组操作</h3><p>有关更多信息，请参阅numpy文件夹中的linalg.py.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">3.0</span>, <span class="number">4.0</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(a)</span><br><span class="line">[[ <span class="number">1.</span>  <span class="number">2.</span>]</span><br><span class="line"> [ <span class="number">3.</span>  <span class="number">4.</span>]]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.transpose()</span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">2.</span>,  <span class="number">4.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.linalg.inv(a)</span><br><span class="line">array([[-<span class="number">2.</span> ,  <span class="number">1.</span> ],</span><br><span class="line">       [ <span class="number">1.5</span>, -<span class="number">0.5</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = np.eye(<span class="number">2</span>) <span class="comment"># unit 2x2 matrix; &quot;eye&quot; represents &quot;I&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u</span><br><span class="line">array([[ <span class="number">1.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>,  <span class="number">1.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>j = np.array([[<span class="number">0.0</span>, -<span class="number">1.0</span>], [<span class="number">1.0</span>, <span class="number">0.0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>j @ j        <span class="comment"># matrix product</span></span><br><span class="line">array([[-<span class="number">1.</span>,  <span class="number">0.</span>],</span><br><span class="line">       [ <span class="number">0.</span>, -<span class="number">1.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.trace(u)  <span class="comment"># trace</span></span><br><span class="line"><span class="number">2.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = np.array([[<span class="number">5.</span>], [<span class="number">7.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.linalg.solve(a, y)</span><br><span class="line">array([[-<span class="number">3.</span>],</span><br><span class="line">       [ <span class="number">4.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.linalg.eig(j)</span><br><span class="line">(array([ <span class="number">0.</span>+<span class="number">1.j</span>,  <span class="number">0.</span>-<span class="number">1.j</span>]), array([[ <span class="number">0.70710678</span>+<span class="number">0.j</span>        ,  <span class="number">0.70710678</span>-<span class="number">0.j</span>        ],</span><br><span class="line">       [ <span class="number">0.00000000</span>-<span class="number">0.70710678j</span>,  <span class="number">0.00000000</span>+<span class="number">0.70710678j</span>]]))</span><br><span class="line">Parameters:</span><br><span class="line">    square matrix</span><br><span class="line">Returns</span><br><span class="line">    The eigenvalues, each repeated according to its multiplicity.</span><br><span class="line">    The normalized (unit <span class="string">&quot;length&quot;</span>) eigenvectors, such that the</span><br><span class="line">    column ``v[:,i]`` <span class="keyword">is</span> the eigenvector corresponding to the</span><br><span class="line">    eigenvalue ``w[i]`` .</span><br></pre></td></tr></table></figure><h2 id="技巧和提示"><a href="#技巧和提示" class="headerlink" title="#技巧和提示"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E6%8A%80%E5%B7%A7%E5%92%8C%E6%8F%90%E7%A4%BA">#</a>技巧和提示</h2><p>这里我们列出一些简短有用的提示。</p><h3 id="“自动”整形"><a href="#“自动”整形" class="headerlink" title="#“自动”整形"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E8%87%AA%E5%8A%A8-%E6%95%B4%E5%BD%A2">#</a>“自动”整形</h3><p>要更改数组的尺寸，您可以省略其中一个尺寸，然后自动推导出尺寸：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">30</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape = <span class="number">2</span>,-<span class="number">1</span>,<span class="number">3</span>  <span class="comment"># -1 means &quot;whatever is needed&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape</span><br><span class="line">(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">        [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">        [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">        [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]],</span><br><span class="line">       [[<span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>],</span><br><span class="line">        [<span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">        [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>],</span><br><span class="line">        [<span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>],</span><br><span class="line">        [<span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>]]])</span><br></pre></td></tr></table></figure><h3 id="矢量堆叠"><a href="#矢量堆叠" class="headerlink" title="#矢量堆叠"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E7%9F%A2%E9%87%8F%E5%A0%86%E5%8F%A0">#</a>矢量堆叠</h3><p>我们如何从同等大小的行向量列表中构造一个二维数组？在MATLAB这是很简单：如果<code>x</code>和<code>y</code>你只需要做两个相同长度的向量<code>m=[x;y]</code>。在此NumPy的通过功能的工作原理<code>column_stack</code>，<code>dstack</code>，<code>hstack</code>和<code>vstack</code>，视维在堆叠是必须要做的。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">0</span>,<span class="number">10</span>,<span class="number">2</span>)                     <span class="comment"># x=([0,2,4,6,8])</span></span><br><span class="line">y = np.arange(<span class="number">5</span>)                          <span class="comment"># y=([0,1,2,3,4])</span></span><br><span class="line">m = np.vstack([x,y])                      <span class="comment"># m=([[0,2,4,6,8],</span></span><br><span class="line">                                          <span class="comment">#     [0,1,2,3,4]])</span></span><br><span class="line">xy = np.hstack([x,y])                     <span class="comment"># xy =([0,2,4,6,8,0,1,2,3,4])</span></span><br></pre></td></tr></table></figure><p>这些函数背后的逻辑在两个以上的维度上可能很奇怪。</p><p>另见</p><p><a href="https://www.numpy.org.cn/user/numpy_for_matlab_users.html">与 Matlab 比较</a></p><h3 id="直方图"><a href="#直方图" class="headerlink" title="#直方图"></a><a href="https://www.numpy.org.cn/user/quickstart.html#%E7%9B%B4%E6%96%B9%E5%9B%BE">#</a>直方图</h3><p><code>histogram</code>应用于数组的NumPy 函数返回一对向量：数组的直方图和bin的向量。注意： <code>matplotlib</code>还有一个构建直方图的功能（<code>hist</code>在Matlab中称为），与NumPy中的直方图不同。主要区别在于<code>pylab.hist</code>自动绘制直方图，而 <code>numpy.histogram</code>只生成数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Build a vector of 10000 normal deviates with variance 0.5^2 and mean 2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mu, sigma = <span class="number">2</span>, <span class="number">0.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v = np.random.normal(mu,sigma,<span class="number">10000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Plot a normalized histogram with 50 bins</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.hist(v, bins=<span class="number">50</span>, density=<span class="number">1</span>)       <span class="comment"># matplotlib version (plot)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://www.numpy.org.cn/static/images/quickstart-2_00_00.png" alt="quickstart-2_00_00"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># Compute the histogram with numpy and then plot it</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(n, bins) = np.histogram(v, bins=<span class="number">50</span>, density=<span class="literal">True</span>)  <span class="comment"># NumPy version (no plot)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.plot(<span class="number">.5</span>*(bins[<span class="number">1</span>:]+bins[:-<span class="number">1</span>]), n)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://www.numpy.org.cn/static/images/quickstart-2_01_00.png" alt="quickstart-2_01_00"></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> Python </tag>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL刷题笔记</title>
      <link href="/2023/08/02/SQL%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/08/02/SQL%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><p>SQL刷题笔记</p><p>基础题：</p><p>表 user_profile</p><table><thead><tr><th>id</th><th>device_id</th><th>gender</th><th>age</th><th>university</th><th>province</th></tr></thead><tbody><tr><td>1</td><td>2138</td><td>male</td><td>21</td><td>北京大学</td><td>Beijing</td></tr><tr><td>2</td><td>3214</td><td>male</td><td></td><td>复旦大学</td><td>Shanghai</td></tr><tr><td>3</td><td>6543</td><td>female</td><td>20</td><td>北京大学</td><td>Beijing</td></tr><tr><td>4</td><td>2315</td><td>female</td><td>23</td><td>浙江大学</td><td>ZheJiang</td></tr><tr><td>5</td><td>5432</td><td>male</td><td>25</td><td>山东大学</td><td>Shandong</td></tr></tbody></table><p>1.查看用户信息表中所有的数据，请你取出相应结果   select * from user_profile</p><p>2.想要用户的设备id对应的性别、年龄和学校的数据，请你取出相应数据  </p><p>​    select device_id,gender,age,university from user_profile;</p><p>3.查看用户来自于哪些学校，请从用户信息表中取出学校的<strong>去重</strong>数据  </p><p>（1）select  DISTINCT university from user_profile;</p><p>（2）select university from user_profile group by university；</p><p>4.查看前2个用户明细设备ID数据，请你从用户信息表 user_profile 中取出相应结果</p><p>​    select  device_id  from user_profile limit 0,2;</p><p>5.查看前2个用户明细设备ID数据，并将列名改为 user_infos_example,从用户信息表取出相应结果</p><p>   select  device_id   user_infos_example from  user_profile limit  0, 2;</p><p>​                (原列名)   省略as （新列名）</p><p>6.想要筛选出所有北京大学的学生进行用户调研，请你从用户信息表中取出满足条件的数据，结果返回设备id和学校</p><p>   select device_id,university from user_profile where university&#x3D;’北京大学’;</p><p>7.想要针对24岁以上的用户开展分析，请你取出满足条件的设备ID、性别、年龄、学校</p><p>   select device_id,gender,age,university from user_profile where age&gt;24;</p><p>8.想要针对20岁及以上且23岁及以下的用户开展分析，请你取出满足条件的设备ID、性别、年龄。</p><p>  select device_id,gender,age from user_profile where age&gt;19 and age&lt;24;</p><p>9.想要查看除复旦大学以外的所有用户明细，请你取出相应数据</p><p>（1）select device_id,gender ,age,  university from user_profile where  university !&#x3D;’复旦大学’;</p><p>（2）select device_id,gender ,age,  university from user_profile where  university NOT IN(<code>&quot;复旦大学&quot;</code>);</p><p>10.剔除没有获取到年龄的用户，请你取出所有年龄值不为空的用户的设备ID，性别，年龄，学校的信息</p><p>​    select device_id,gender ,age,  university from user_profile where  age !&#x3D;”NULL”;</p><p>user_profile</p><table><thead><tr><th>id</th><th>device_id</th><th>gender</th><th>age</th><th>university</th><th>gpa</th></tr></thead><tbody><tr><td>1</td><td>2138</td><td>male</td><td>21</td><td>北京大学</td><td>3.4</td></tr><tr><td>2</td><td>3214</td><td>male</td><td></td><td>复旦大学</td><td>4.0</td></tr><tr><td>3</td><td>6543</td><td>female</td><td>20</td><td>北京大学</td><td>3.2</td></tr><tr><td>4</td><td>2315</td><td>female</td><td>23</td><td>浙江大学</td><td>3.6</td></tr><tr><td>5</td><td>5432</td><td>male</td><td>25</td><td>山东大学</td><td>3.8</td></tr></tbody></table><p>11.想要找到学校为北大<strong>或</strong>GPA在3.7以上(不包括3.7)的用户进行调研，请你取出相关数据（使用OR实现）</p><p> select device_id,gender,age,university,gpa from user_profile where university &#x3D;”北京大学” or gpa &gt;3.7;</p><p>12.想要找到学校为北大、复旦和山大的同学进行调研，请你取出相关数据</p><p>select device_id,gender,age,university,gpa from user_profile where university IN (‘北京大学’,’复旦大学’,’山东大学’);</p><p>13.找到gpa在3.5以上(不包括3.5)的山东大学用户 或 gpa在3.8以上(不包括3.8)的复旦大学同学进行用户调研，请你取出相应数据</p><p>select device_id,gender,age,university,gpa from user_profile where (university &#x3D;”山东大学” and gpa &gt;3.5) or (university&#x3D;”复旦大学” and gpa&gt;3.8);</p><p>14.查看所有大学中带有北京的用户的信息，请你取出相应数据。</p><p>   select device_id,age,university from user_profile where university like ‘%北京%’;</p><p>15.想要知道复旦大学学生gpa最高值是多少，请你取出相应数据</p><p>(1)SELECT gpa FROM user_profile WHERE university&#x3D;’复旦大学’ HAVING max(gpa);</p><p>(2)SELECT MAX(gpa) FROM user_profile WHERE university&#x3D;’复旦大学’;</p><p>16.想要看一下男性用户有多少人以及他们的平均gpa是多少，用以辅助设计相关活动，请你取出相应数据</p><p>select count(gender) as male_num ,avg(gpa)from user_profile where gender&#x3D;’male’;</p><p>17.现在运营想要对每个学校不同性别的用户活跃情况和发帖数量进行分析，请分别计算出每个学校每种性别的用户数、30天内平均活跃天数和平均发帖数量。</p><p>SELECT gender,university,COUNT(gender),avg(active_days_within_30)as avg_active_days,</p><p>avg(question_cnt)as question_cnt from user_profile</p><p>GROUP by gender,university</p><p>18.想查看每个学校用户的平均发贴和回帖情况，寻找低活跃度学校进行重点运营，请取出平均发贴数低于5的学校或平均回帖数小于20的学校</p><p>select university,avg(question_cnt) as avg_question_cnt,avg(answer_cnt) as avg_answer_cnt </p><p>from user_profile                                                                                            可以省略as</p><p>group by university</p><p>having avg_question_cnt&lt;5 or avg_answer_cnt &lt;20;</p><p>19.想要查看不同大学的用户平均发帖情况，并期望结果按照平均发帖情况进行升序排列，请你取出相应数据。</p><p>SELECT university,AVG(question_cnt)avg_quesition_cnt</p><p>FROM user_profile</p><p>GROUP BY university</p><p>ORDER BY avg_quesition_cnt ASC;&#x2F;&#x2F;降序 DESC</p><p>20.查看所有来自浙江大学的用户题目回答明细情况，请你取出相应数据</p><p>select device_id,question_id,result</p><p>from question_practice_detail</p><p>where device_id &#x3D; (select device_id </p><p>​          from user_profile </p><p>​          where university &#x3D; ‘浙江大学’)</p><p>question_practice_detail</p><table><thead><tr><th>id</th><th>device_id</th><th>question_id</th><th>result</th><th>date</th></tr></thead><tbody><tr><td>1</td><td>2138</td><td>111</td><td>wrong</td><td>2021-05-03</td></tr><tr><td>2</td><td>3214</td><td>112</td><td>wrong</td><td>2021-05-09</td></tr><tr><td>3</td><td>3214</td><td>113</td><td>wrong</td><td>2021-06-15</td></tr><tr><td>4</td><td>6543</td><td>111</td><td>right</td><td>2021-08-13</td></tr><tr><td>5</td><td>2315</td><td>115</td><td>right</td><td>2021-08-13</td></tr><tr><td>6</td><td>2315</td><td>116</td><td>right</td><td>2021-08-14</td></tr><tr><td>7</td><td>2315</td><td>117</td><td>wrong</td><td>2021-08-15</td></tr></tbody></table><p>21.想要了解2021年8月份所有练习过题目的总用户数和练习过题目的总次数，请取出相应结果</p><p>select</p><p>  count(distinct device_id) as did_cnt,</p><p>  count(question_id) as question_cnt</p><p>from question_practice_detail</p><p>where date like “2021-08%”</p><p>22.将用户划分为25岁以下和25岁及以上两个年龄段，分别查看这两个年龄段用户数量</p><p>SELECT if(age&lt;25 OR age IS null,”25岁以下”,”25岁及以上”) as age_cut,<br>count(user_profile.device_id) as number<br>FROM user_profile<br>GROUP BY age_cut</p><p>23.将用户划分为<strong>20岁以下，20-24岁，25岁及以上</strong>三个年龄段，分别查看不同年龄段用户的明细情况，请取出相应数据。（注：若<strong>年龄为空</strong>请返回<strong>其他</strong>。）</p><p>select device_id,  gender,</p><p>  case</p><p>​    when age &gt;&#x3D; 25 then ‘25岁及以上’</p><p>​    when age &gt;&#x3D; 20 then ‘20-24岁’</p><p>​    when age &lt; 20 then ‘20岁以下’</p><p>​    else ‘其他’</p><p>  end as age_cut</p><p>from  user_profile</p><p>24.想要计算出<strong>2021年8月每天用户练习题目的数量</strong>，请取出相应数据。</p><p>select    day(date) as day,   count(question_id) as question_cnt</p><p>from question_practice_detail</p><p>where month(date)&#x3D;8 and year(date)&#x3D;2021  &#x2F;&#x2F;  where date like “2021-08%”</p><p>group by date</p><p>user_submit</p><table><thead><tr><th>device_id</th><th>profile</th><th>blog_url</th></tr></thead><tbody><tr><td>2138</td><td>180cm,75kg,27,male</td><td>http:&#x2F;ur&#x2F;bisdgboy777</td></tr><tr><td>3214</td><td>165cm,45kg,26,female</td><td>http:&#x2F;url&#x2F;dkittycc</td></tr><tr><td>6543</td><td>178cm,65kg,25,male</td><td>http:&#x2F;ur&#x2F;tigaer</td></tr><tr><td>4321</td><td>171 cm,55kg,23,female</td><td>http:&#x2F;url&#x2F;uhksd</td></tr><tr><td>2131</td><td>168cm,45kg,22,female</td><td>http:&#x2F;url&#x2F;sydney</td></tr></tbody></table><p>25.对于申请参与比赛的用户，blog_url字段中url字符后的字符串为用户个人博客的用户名，现在运营想要把用户的个人博客用户字段提取出单独记录为一个新的字段，请取出所需数据</p><p>select device_id, substring_index(blog_url, ‘&#x2F;‘, -1) as user_name </p><p> &#x2F;&#x2F;负数代表从右往左  -1代表最后一个&#x2F;后面   正数代表代表从左往右  1代表第一个&#x2F;后面</p><p>from user_submit</p><p>26.统计每个性别的用户分别有多少参赛者，请取出相应结果</p><p>select  substring_index(profile, ‘,’, -1) as gender,  &#x2F;&#x2F;最后一个字符串是性别</p><p>count(device_id) as number</p><p>from user_submit</p><p>group by gender</p><p>27.统计每个年龄的用户分别有多少参赛者，请取出相应结果</p><p>SELECT </p><p>  substring_index(substring_index(profile, “,”, -2), “,”, 1) as age,</p><p>​                                                      拿到年龄xxkg       把kg去掉赋给age</p><p>  COUNT(device_id )  as number</p><p>FROM user_submit</p><p>GROUP BY age;</p><p>28.现在运营想要找到每个学校gpa最低的同学来做调研，请你取出每个学校的最低gpa。</p><p>&#x2F;&#x2F;<code>SELECT device_id,</code><br>       <code>university,</code><br>       <code>min(gpa) as gpa</code>           这代码是错的 有聚合函数min() where失效了 可用having语句<br><code>FROM user_profile</code><br>&#x2F;&#x2F;<code>GROUP BY university</code></p><p>正确代码：</p><p><code>select  device_id, university,gpa</code>   </p><p><code>from user_profile</code></p><p><code>where (university, gpa) in (</code></p><p>​    <code>select university,min(gpa)</code></p><p>​    <code>from  user_profile</code></p><p>​    <code>group by university )</code></p><p><code>order by university</code></p><p>29.编写 SQL 语句，返回顾客 ID（cust_id）、顾客名称（cust_name）和登录名（user_login），其中登录名全部为大写字母，并由顾客联系人的前两个字符（cust_contact）和其所在城市的前三个字符（cust_city）组成。提示：需要使用函数、拼接和别名。</p><p><code>select</code> </p><p><code>cust_id,cust_name,</code></p><p><code>upper(concat(left(cust_contact,2),left(cust_city,3))) as user_login</code></p><p>​               cust_contact   前两个字符 拼接cust_city前三个字符赋给user_login</p><p><code>from Customers</code></p><p>30.编写 SQL 语句，返回 2020 年 1 月的所有订单的订单号（order_num）和订单日期（order_date），并按订单日期升序排序</p><p><code>select order_num,order_date</code></p><p><code>from Orders</code></p><p><code>where order_date like &#39;2020-01%&#39;</code></p><p><code>order by order_date;</code></p><p>31.使用子查询，返回购买价格为 10 美元或以上产品的顾客列表，结果无需排序。</p><p><code>SELECT DISTINCT cust_id</code></p><p><code>FROM Orders</code></p><p><code>WHERE order_num IN (</code></p><p>  <code>SELECT order_num</code></p><p>  <code>FROM OrderItems</code></p><p>  <code>WHERE item_price &gt;= 10</code></p><p><code>)</code></p><p>32.编写 SQL语句，返回顾客 ID（Orders 表中的 cust_id），并使用子查询返回total_ordered 以便返回每个顾客的订单总数，将结果按金额从大到小排序</p><p><code>select cust_id,(select</code></p><p> <code>SUM(item_price*quantity)</code></p><p><code>FROM OrderItems</code> </p><p><code>WHERE OrderItems .order_num=Orders .order_num) total_ordered</code></p><p><code>from Orders</code> </p><p><code>ORDER BY total_ordered DESC</code></p><p>33.编写 SQL 语句，返回 Customers 表中的顾客名称（cust_name）和Orders 表中的相关订单号（order_num），并按顾客名称再按订单号对结果进行升序排序。你可以尝试用两个不同的写法，一个使用简单的等联结语法，另外一个使用 INNER JOIN。</p><p>(1)<code>select cust_name,order_num</code></p><p><code>from Customers C,Orders O</code></p><p><code>where C.cust_id=O.cust_id</code></p><p><code>order by cust_name</code></p><p>(2)<code>select cust_name,order_num</code></p><p><code>from Customers</code> </p><p><code>inner join Orders</code></p><p><code>on Customers.cust_id=Orders.cust_id</code></p><p><code>order by cust_name</code></p><p>34.使用子查询来确定哪些订单（在 OrderItems 中）购买了 prod_id 为 “BR01” 的产品，然后从 Orders 表中返回每个产品对应的顾客 ID（cust_id）和订单日期（order_date），按订购日期对结果进行升序排序</p><p><code>select cust_id,order_date</code></p><p><code>from Orders</code> </p><p>&#96;&#96;where order_num  in&#96;</p><p><code>(``select order_num</code>  <code>from OrderItems</code> <code>where  prod_id=&#39;BR01&#39;``)</code></p><p><code>order by order_date</code></p><ol start="35"><li>SQL 100题   编写 SQL 语句，返回订单总价不小于1000 的客户名称和总额,需要计算总和（item_price 乘以 quantity）。按总额对结果进行排序，请使用INNER JOIN 语法。</li></ol><p><code>select cust_name,sum(item_price*quantity) total_price</code></p><p><code>from Customers C</code></p><p><code>inner join Orders  O</code></p><p><code>on C.cust_id=O.cust_id</code></p><p><code>inner join OrderItems OI</code></p><p><code>on O.order_num=OI.order_num</code></p><p><code>group by cust_name</code>                           &#x2F;&#x2F;having语句前要用group by   有聚合函数时不能使用where</p><p><code>having total_price&gt;=1000</code></p><p><code>order by total_price</code></p><ol start="36"><li><p>将两个 SELECT 语句结合起来，以便从 OrderItems表中检索产品 id（prod_id）和 quantity。其中，一个 SELECT 语句过滤数量为 100 的行，另一个 SELECT 语句过滤 id 以 BNBG 开头的产品，最后按产品 id 对结果进行升序排序</p><p>（1）<code>select *from OrderItems</code></p><p><code>where quantity in (</code></p><p>  <code>select quantity   from OrderItems  where quantity = 100 )</code></p><p><code>or prod_id like &quot;BNBG%&quot;</code></p><p><code>order by prod_id;</code></p><hr><p>（2）<code>select prod_id,quantity</code></p><p><code>from OrderItems</code></p><p><code>where quantity =100</code></p><p><code>union all</code>               &#x2F;&#x2F;union把select语句结合以后  取的或  即满足一个条件即可</p><p><code>select prod_id,quantity</code></p><p><code>from OrderItems</code></p><p><code>where prod_id like&#39;BNBG%&#39;</code></p><p><code>order by prod_id</code></p></li></ol><p><strong>各种连接：推荐使用左连接</strong></p><p><img src="https://img-blog.csdnimg.cn/20200802150143677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTEwNDc5Njg=,size_16,color_FFFFFF,t_70" alt="sqljoins"></p><p>表A记录如下：                           表B记录如下:<br><strong>aID    aNum</strong>                             <strong>bID    bName</strong><br>1      a20050111                        1      2006032401<br>2      a20050112                        2      2006032402<br>3      a20050113                        3      2006032403<br>4     a20050114                         4      2006032404<br>5      a20050115                        8      2006032408<br><strong>1.  left join</strong><br>sql语句如下:</p><p>SELECT * FROM A<br>LEFT JOIN B<br>ON A.aID &#x3D; B.bID</p><p>结果如下:<br>aID    aNum          bID      bName<br>1      a20050111     1        2006032401<br>2       a20050112     2        2006032402<br>3       a20050113     3        2006032403                   左(主)表元素全会存在，即使右(副)表没有此行，<br>4      a20050114     4        2006032404                          若没有，右表会全置为null<br>5      a20050115     NULL    NULL<br>（所影响的行数为 5 行）</p><p>**大数据时删除数据(不推荐使用delete)**使用新建表，copy旧表到新表，删除旧表，重命名新表为旧表名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">--创建分区表。</span><br><span class="line">CREATE TABLE tpcds.reason_p</span><br><span class="line">(</span><br><span class="line">  r_reason_sk integer,</span><br><span class="line">  r_reason_id character(16),</span><br><span class="line">  r_reason_desc character(100)</span><br><span class="line">)PARTITION BY RANGE (r_reason_sk)</span><br><span class="line">(</span><br><span class="line">  partition p_05_before values less than (05),</span><br><span class="line">  partition p_15 values less than (15),</span><br><span class="line">  partition p_25 values less than (25),</span><br><span class="line">  partition p_35 values less than (35),</span><br><span class="line">  partition p_45_after values less than (MAXVALUE)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">--插入数据。</span><br><span class="line">INSERT INTO tpcds.reason_p SELECT * FROM tpcds.reason;</span><br><span class="line"></span><br><span class="line">--清空分区p_05_before。</span><br><span class="line">ALTER TABLE tpcds.reason_p TRUNCATE PARTITION p_05_before;</span><br><span class="line"></span><br><span class="line">--清空分区p_15。</span><br><span class="line">ALTER TABLE tpcds.reason_p TRUNCATE PARTITION for (13);</span><br><span class="line"></span><br><span class="line">--清空分区表。</span><br><span class="line">TRUNCATE TABLE tpcds.reason_p;</span><br><span class="line"></span><br><span class="line">--删除表。</span><br><span class="line">DROP TABLE tpcds.reason_p;</span><br></pre></td></tr></table></figure><p><strong>删除</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name</span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure><p><strong>插入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table_name</span><br><span class="line">VALUES (value1,value2,value3,...);</span><br><span class="line">或</span><br><span class="line">INSERT INTO table_name (column1,column2,column3,...)</span><br><span class="line">VALUES (value1,value2,value3,...);</span><br></pre></td></tr></table></figure><p>32：牛客后台会记录每个用户的试卷作答记录到exam_record表，现在有两个用户的作答记录详情如下：</p><p>  用户1001在2021年9月1日晚上10点11分12秒开始作答试卷9001，并在50分钟后提交，得了90分；</p><p>  用户1002在2021年9月4日上午7点1分2秒开始作答试卷9002，并在10分钟后退出了平台。</p><p><code>INSERT INTO exam_record VALUES</code></p><p><code>(NULL, 1001, 9001, &#39;2021-09-01 22:11:12&#39;, &#39;2021-09-01 23:01:12&#39;, 90),</code></p><p><code>(NULL, 1002, 9002, &#39;2021-09-04 07:01:02&#39;, NULL, NULL);</code></p><p>33：我们已经创建了一张新表exam_record_before_2021用来备份2021年之前的试题作答记录，结构和exam_record表一致，请将2021年之前的已完成了的试题作答纪录导入到该表</p><p><code>INSERT INTO exam_record_before_2021(uid, exam_id, start_time, submit_time, score)</code></p><p><code>SELECT uid, exam_id, start_time, submit_time, score</code></p><p><code>FROM exam_record</code></p><p><code>WHERE YEAR(submit_time) &lt; &#39;2021&#39;;</code></p><p>34.有一套ID为9003的高难度SQL试卷，时长为一个半小时，请你将 2021-01-01 00:00:00 作为发布时间插入到试题信息表examination_info（其表结构如下图），不管该ID试卷是否存在，都要插入成功，请尝试插入它</p><p><code>replace INTO examination_info</code>  &#x2F;&#x2F;会先检查是否存在此数据，如果有则不插入，没有则插入</p><p><code>VALUES(NULL,9003,&#39;SQL&#39;,&#39;hard&#39;,90,&#39;2021-01-01 00:00:00&#39;);</code></p><p><strong>或</strong></p><p><code>insert INTO examination_info</code>  &#x2F;&#x2F;不会检查是否存在此数据，直接插入</p><p><code>VALUES(NULL,9003,&#39;SQL&#39;,&#39;hard&#39;,90,&#39;2021-01-01 00:00:00&#39;);</code></p><p><strong>更新</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name</span><br><span class="line">SET column1 = value1, column2 = value2, ...</span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure><p>35.把examination_info表中tag为PYTHON的tag字段全部修改为Python。</p><p><code>update examination_info  set tag=&#39;Python&#39;   where tag=&#39;PYTHON&#39;</code></p><p>36.编写SQL 语句，查找所有订购了数量至少100 个的 BR01、BR02 或BR03 的订单。你需要返回 OrderItems 表的订单号（order_num）、产品 ID（prod_id）和数量（quantity），并按产品 ID 和数量进行过滤</p><p><code>select order_num,prod_id,quantity</code></p><p><code>from OrderItems</code></p><p><code>where (prod_id=&#39;BR01&#39;or prod_id=&#39;BR02&#39;or prod_id=&#39;BR03&#39;) and quantity&gt;=100</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT order_num,prod_id,quantity</span><br><span class="line">FROM OrderItems</span><br><span class="line">WHERE quantity &gt;= ``100` `AND prod_id IN (``&#x27;BR01&#x27;``, ``&#x27;BR02&#x27;``, ``&#x27;BR03&#x27;``);</span><br></pre></td></tr></table></figure><p>37.编写 SQL 语句，返回每个订单号（order_num）各有多少行数（order_lines），并按 order_lines对结果进行升序排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select order_num,count(*) order_lines``</span><br><span class="line">from OrderItems``</span><br><span class="line">group by order_num``</span><br><span class="line">order by order_lines;</span><br></pre></td></tr></table></figure><p>知识点：<br>1、count(*),count(列名)都可以，区别在于，count(列名)是统计非NULL的行数<br>2、order by最后执行，所以可以使用列别名<br><strong>3、分组聚合一定不要忘记加上 group by ,不然只会有一行结果</strong></p><p>38.请从试卷作答记录表中找到SQL试卷得分不小于该类试卷平均得分的用户最低得分。</p><p><code>select score min_score_over_avg</code></p><p><code>from exam_record,examination_info</code></p><p><code>where examination_info.tag=&#39;SQL&#39;</code></p><p><code>and exam_record.exam_id = examination_info.exam_id</code></p><p><code>and score&gt;=(</code>select<code> </code>avg(score)&#96; </p><p>  <code>from exam_record , examination_info</code> </p><p>  <code>where examination_info.tag = &#39;SQL&#39;</code></p><p>  <code>and exam_record.exam_id = examination_info.exam_id``)</code></p><p><code>order by score</code>    <code>limit 1</code></p><p><strong>union</strong>:连接两表，会去重，效率较低</p><p><strong>union all</strong>：连接两表，不去重，效率较高</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT EMP_ID, NAME, DEPT FROM COMPANY INNER JOIN DEPARTMENT</span><br><span class="line">   ON COMPANY.ID = DEPARTMENT.EMP_ID</span><br><span class="line">   UNION   //UNION ALL</span><br><span class="line">SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT</span><br><span class="line">    ON COMPANY.ID = DEPARTMENT.EMP_ID;</span><br></pre></td></tr></table></figure><p><strong>触发器</strong>：触发器是与表有关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。也就是由事件来触发某个操作，事件包括INSERT语句，UPDATE语句和DELETE语句；可以协助应用在数据库端确保数据的完整性。</p><p><strong>1、创建触发器：</strong></p><p>  1.创建只有一个执行语句的触发器</p><blockquote><p>例1：创建了一个名为trig1的触发器，一旦在work表中有插入动作，就会自动往time表里插入当前时间</p><p>CREATE TRIGGER 触发器名 BEFORE|AFTER 触发事件 ON 表名 FOR EACH ROW 执行语句;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TRIGGER trig1 AFTER INSERT</span><br><span class="line">    -&gt; ON work FOR EACH ROW</span><br><span class="line">    -&gt; INSERT INTO time VALUES(NOW());</span><br></pre></td></tr></table></figure></blockquote><p>  2.创建有多个执行语句的触发器</p><blockquote><p>CREATE TRIGGER 触发器名 BEFORE|AFTER 触发事件</p><p>ON 表名 FOR EACH ROW</p><p>BEGIN</p><p>​    执行语句列表</p><p>END;</p><p>例2：定义一个触发器，一旦有满足条件的删除操作，就会执行BEGIN和END中的语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">trigger_time: &#123; BEFORE | AFTER &#125;//触发器触发时间</span><br><span class="line"></span><br><span class="line">trigger_event: &#123; INSERT | UPDATE | DELETE &#125;//触发器可以执行的三种操作</span><br><span class="line"></span><br><span class="line">trigger_order: &#123; FOLLOWS | PRECEDES &#125; other_trigger_name</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TRIGGER trig2 BEFORE DELETE</span><br><span class="line">    -&gt; ON work FOR EACH ROW</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; 　　INSERT INTO time VALUES(NOW());</span><br><span class="line">    -&gt; 　　INSERT INTO time VALUES(NOW());</span><br><span class="line">    -&gt; END||</span><br></pre></td></tr></table></figure><p><strong>2、NEW与OLD详解</strong></p><p>MySQL 中定义了 NEW 和 OLD，用来表示触发器的所在表中，触发了触发器的那一行数据，来引用触发器中发生变化的记录内容，具体地：</p><p>　　①在INSERT型触发器中，NEW用来表示将要（BEFORE）或已经（AFTER）插入的新数据；</p><p>　　②在UPDATE型触发器中，OLD用来表示将要或已经被修改的原数据，NEW用来表示将要或已经修改为的新数据；</p><p>　　③在DELETE型触发器中，OLD用来表示将要或已经被删除的原数据；</p><p>使用方法：</p><p>　　NEW.columnName （columnName为相应数据表某一列名）</p><p>另外，OLD是只读的，而NEW则可以在触发器中使用 SET 赋值，这样不会再次触发触发器，造成循环调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE TRIGGER upd_check BEFORE UPDATE ON account</span><br><span class="line">    -&gt; FOR EACH ROW</span><br><span class="line">    -&gt; BEGIN</span><br><span class="line">    -&gt; 　　IF NEW.amount &lt; 0 THEN</span><br><span class="line">    -&gt; 　　　　SET NEW.amount = 0;</span><br><span class="line">    -&gt; 　　ELSEIF NEW.amount &gt; 100 THEN</span><br><span class="line">    -&gt; 　　　　SET NEW.amount = 100;</span><br><span class="line">    -&gt; 　　END IF;</span><br><span class="line">    -&gt; END$$</span><br></pre></td></tr></table></figure><p><strong>3、查看触发器</strong></p><p>(1)SHOW TRIGGERS语句查看触发器信息</p><p>mysql&gt; SHOW TRIGGERS\G;</p><p>……</p><p>结果，显示所有触发器的基本信息；无法查询指定的触发器。</p><p>(2)、在information_schema.triggers表中查看触发器信息</p><p>mysql&gt; SELECT * FROM information_schema.triggers\G</p><p><strong>4、删除触发器</strong></p><p><em>DROP TRIGGER [IF EXISTS] [schema_name.]trigger_name</em></p><p><strong>创建数据库</strong>：CREATE DATABASE dbname;</p><p><strong>删除数据库</strong>：DROP DATABASE [ IF EXISTS ] name</p><p><strong>创建表格</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name(</span><br><span class="line">   column1 datatype,</span><br><span class="line">   column2 datatype,</span><br><span class="line">   column3 datatype,</span><br><span class="line">   .....</span><br><span class="line">   columnN datatype,</span><br><span class="line">   PRIMARY KEY( 一个或多个列 )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>删除表格</strong>：DROP TABLE IF EXISTS   table_name;</p><p><strong>增删改查</strong>：INSERT  DELETE&#x2F;TRUNCAT  UPDATE   SELECT</p><p>   (1**)增加表中数据**：INSERT INTO…VALUES…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO TABLE_NAME (column1, column2, column3,...columnN)</span><br><span class="line">VALUES (value1, value2, value3,...valueN);</span><br></pre></td></tr></table></figure><ul><li><strong>嵌套增加</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table_name [ (column1 [, column2 ]) ]</span><br><span class="line">   SELECT [ *|column1 [, column2 ] ]</span><br><span class="line">   FROM table1 [, table2 ]</span><br><span class="line">   [ WHERE VALUE OPERATOR ]</span><br></pre></td></tr></table></figure><p><strong>（2)删除表中数据：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name WHERE [condition];</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TRUNCATE TABLE  table_name;</span><br></pre></td></tr></table></figure><ul><li><strong>嵌套</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM TABLE_NAME</span><br><span class="line">[ WHERE OPERATOR [ VALUE ]</span><br><span class="line">   (SELECT COLUMN_NAME</span><br><span class="line">   FROM TABLE_NAME)</span><br><span class="line">   [ WHERE) ]</span><br></pre></td></tr></table></figure><p>(3)<strong>更新&#x2F;修改表中数据</strong>：UPDATE 表名 SET … WHERE…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table_name</span><br><span class="line">SET column1 = value1, column2 = value2...., columnN = valueN</span><br><span class="line">WHERE [condition];</span><br></pre></td></tr></table></figure><ul><li><strong>嵌套</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UPDATE table</span><br><span class="line">SET column_name = new_value</span><br><span class="line">[ WHERE OPERATOR [ VALUE ]</span><br><span class="line">   (SELECT COLUMN_NAME</span><br><span class="line">   FROM TABLE_NAME)</span><br><span class="line">   [ WHERE) ]</span><br></pre></td></tr></table></figure><p>ALTER TABLE 语句用于在已有的表中添加、删除或修改列。</p><p><strong>alter add;添加列 alter change;改列名 alter modify;修改列数据类型</strong></p><p><strong>如需在表中添加列，请使用下面的语法:</strong></p><p>ALTER TABLE table_name<br>ADD column_name datatype</p><p><strong>如需删除表中的列，请使用下面的语法</strong>（请注意，某些数据库系统不允许这种在数据库表中删除列的方式）：</p><p>ALTER TABLE table_name<br>DROP COLUMN column_name</p><p><strong>要改变表中列的数据类型，请使用下面的语法：</strong></p><p>ALTER TABLE table_name<br>MODIFY COLUMN column_name datatype         </p><p>(4)<strong>查找表中数据</strong>：SELECT…FROM…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT column1, column2,...columnN FROM table_name;</span><br></pre></td></tr></table></figure><ul><li><strong>嵌套子查询</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name [, column_name ]</span><br><span class="line">FROM   table1 [, table2 ]</span><br><span class="line">WHERE  column_name OPERATOR</span><br><span class="line">      (SELECT column_name [, column_name ]</span><br><span class="line">      FROM table1 [, table2 ]</span><br><span class="line">      [WHERE])</span><br></pre></td></tr></table></figure><p>例：</p><p><strong>1.带in的子查询</strong></p><p><code>select sno, sname</code><br><code>from student</code><br><code>where sno in (select sno from sc where cno=&#39;C001&#39;);</code></p><p><strong>2.带比较运算符的子查询</strong></p><p><code>select cno from sc as x</code><br><code>where score &gt;</code><br><code>(</code><br>    <code>select avg(score) from sc as y where x.sno=y.sno and x.sno = &#39;2016110129&#39;</code><br><code>)</code><br><code>and sno = &#39;2016110129&#39;;</code></p><p><strong>3.带any（some）或all的子查询</strong></p><p><code>select cno from sc</code><br><code>group by cno</code><br><code>having COUNT(*) &gt;= all(select COUNT(*) from sc group by cno);</code></p><p><strong>4.带exists的子查询</strong></p><p><code>#列出选修了C001课程的学生的学号、姓名</code><br><code>select sno,sname from student</code><br><code>where exists(</code><br><code>select * from sc where sc.sno=student.sno and cno=&#39;C001&#39;</code><br><code>);</code></p><p>5.<strong>基于派生表的查询</strong></p><p><code>select sc.sno,total_cre,avg(score) from</code><br>    <code>(select sc``， sno,SUM(ceredit) as total_cre from sc,course``` where sc.cno=course.cno</code><br>    <code>and score &gt;= 60</code><br>    <code>group by sno</code><br>    <code>having SUM(ceredit) &gt;= 8) as temptable </code>&#x2F;&#x2F;一定要取别名！</p><p><code> </code>where temptable.sno&#x3D;sc.sno<code>  </code>group by sc.sno,sum_cre;&#96;</p><p>&#x2F;&#x2F;有select 后面接子查询；也有from后面接子查询(相当于试图)，最后要其别名</p><ul><li><strong>where型子查询：</strong>把内层查询的结果作为外层查询的比较条件</li></ul><p>​         (1)SELECT goods_id,goods_name,shop_price </p><p>​             FROM goods </p><p>​            WHERE goods_id <strong>&#x3D; (SELECT MAX(goods_id) FROM goods)</strong></p><p>​        (2)SELECT goods_id,goods_name,cat_id,shop_price</p><p>​             FROM goods </p><p>​             WHERE goods_id <strong>IN (SELECT MAX(goods_id) FROM goods GROUP BY cat_id);</strong></p><ul><li><p><strong>from型子查询：</strong>把内层的查询结果当成临时表，供外层sql再次查询。查询结果集可以当成表看待。临时表要使用一个别名</p><p> (1) SELECT goods_id,goods_name,cat_id,shop_price</p><p>​      FROM <strong>(SELECT goods_id,goods_name,cat_id,shop_price</strong> </p><p>​             <strong>FROM goods</strong> </p><p>​             <strong>ORDER BY cat_id ASC,goods_id DESC) AS tmp</strong></p><p>　  GROUP BY cat_id;</p></li></ul><p><strong>连接：union &#x2F;union all</strong></p><p>**union:**连接两表，去重，效率低          </p><p>**union all:**连接两表，不去重，效率高  </p><p> <strong>&#x2F;&#x2F;使用union以后 上下语句只能使用一个order by</strong></p><p><code>SELECT cust_name, cust_contact, cust_email</code> </p><p><code>FROM Customers</code> </p><p><code>WHERE cust_state = &#39;MI&#39;</code> </p><ul><li>ORDER BY cust_name;  ×          &#x2F;&#x2F;不能在此使用order by</li></ul><p><code>UNION</code> </p><p><code>SELECT cust_name, cust_contact, cust_email</code> </p><p><code>FROM Customers</code> </p><p><code>WHERE cust_state = &#39;IL&#39;</code></p><p><code>ORDER BY cust_name;</code></p><p><strong>group by用法:</strong></p><ol><li><strong>当select使用了聚合函数时，只会产生一个数据，若要产生多个数据，则后面需加个group by</strong></li></ol><p>GROUP BY 叙述句搭配聚合函数 (aggregation function) 使用，是用来将查询结果中特定栏位值相同的资料分为若干个群组，而每一个群组都会传回一个资料列。若没有使用 GROUP BY，聚合函数针对一个 SELECT 查询，只会返回一个汇总值。</p><p><code>select  prod_name,count(OrderItems.prod_id) orders</code></p><p><code>from Products p</code></p><p><code>left join OrderItems</code> </p><p><code>on p.prod_id=OrderItems.prod_id</code></p><p><code>group by prod_name</code>         &#x2F;&#x2F;无这个则输出只有一个</p><p><code>order by prod_name</code></p><p>  <strong>2.去重，代替distinct去重</strong></p><p>各种函数：</p><ol><li><p><strong>timestampdiff(minute, begin, end)</strong>   算时间</p><p>例&#x2F;timestampdiff(minute,start_time,submit_time)&lt;5</p><p>2.<strong>if(condition, value_if_true, value_if_false)</strong>  条件函数</p><p>例if(score is null,0,score)</p><p>3.<strong>round(x,d)</strong>  ，x指要处理的数，d是指保留几位小数</p><p>例round(**sum(if(score is null,0,score))&#x2F;count(uid) **, 0 ) </p><p>round(x)  ,其实就是round(x,0),也就是默认d为0</p><p>4.<strong>char_length(s)</strong>返回字符串 s 的字符长度</p><p>5.<strong>concat(s1,s2…sn)</strong>字符串 s1,s2 ..sn等多个字符串合并为一个字符串</p><p>例 CONCAT(substring(nick_name,1,10),”…”)  nick_name前10个字符和 ‘…’拼接</p><p>6.<strong>left(s,n)</strong>返回字符串 s 的前 n 个字符 </p><p>7.<strong>RIGHT(s,n)</strong>返回字符串 s 的后 n 个字符</p><p>8.<strong>replace(s,s1,s2)</strong>将字符串 s2 替代字符串 s 中的字符串 s1</p><p>9.<strong>reverse(s)</strong>将字符串s的顺序反过来</p><p>10.<strong>substr(s, start, length)</strong>从字符串 s 的 start 位置截取长度为 length 的子字符串11.<strong>substring(s, start, length)</strong>从字符串 s 的 start 位置截取长度为 length 的子字符串，等同于         SUBSTR(s, start, length)</p></li></ol><p>  12.<strong>date_format(d,f)</strong>按表达式 f的要求显示日期 d </p><p>   例  date_format(start_time, ‘%Y-%m-%d %H:%i:%s’)</p><ol start="13"><li><p><strong>day(d)&#x2F;month(d)&#x2F;year(d)</strong>返回日期值 d 的日期部分&#x2F;月份&#x2F;年份   &#x2F;&#x2F;DAY(“2017-06-15”)</p></li><li><p><strong>count()</strong>:  count(1)    1代表这个表达式不为 NULL 的记录   count(*)   count(字段)</p></li><li><p><strong>sum(if( )) 、count(if( ))</strong></p><p><strong>sum(if(fenlei&#x3D;’分类1’,1,0))  A</strong></p><p>即：如果是’分类1’的则返回1，否则返回0，对返回辅助列进行求和,得到符合此条件的数据的总和</p><p>满足条件的对象求和，即统计<code>1</code>的数量</p><p><strong>count(if(fenlei&#x3D;’分类2’,1,0)) B</strong></p><p>即：如果是’分类2’的则返回1，否则返回0，但是因为都有数值，count对所有有值的列进行计数</p><p>无视条件求和，即统计<code>0</code>或者<code>1</code>的数量</p></li></ol><p><strong>case..when语句：</strong>CASE</p><p>​     WHEN SCORE &#x3D; ‘A’ THEN ‘优’<br>​     WHEN SCORE &#x3D; ‘B’ THEN ‘良’<br>​     WHEN SCORE &#x3D; ‘C’ THEN ‘中’</p><p>​      ELSE ‘不及格’ </p><p>END</p><p>例：SELECT    STUDENT_NAME,   </p><p> (CASE </p><p>WHEN score &lt; 60 THEN ‘不及格’        </p><p>WHEN score &gt;&#x3D; 60 AND score &lt; 80 THEN ‘及格’     </p><p>WHEN score &gt;&#x3D; 80 THEN ‘優秀’     </p><p>ELSE ‘異常’ </p><p>END) AS REMARK  FROM    TABLE</p><p><strong>with语句：给子查询语句取别名，下次就能直接取。</strong></p><p>with u1 as</p><p> (select id, sum(amount) as num from pay where pay_time &gt;&#x3D; 1493568000 and pay_time &lt; 1494172800 group by id), </p><p>u2 as(select id, sum(amount) as total from pay where pay_time &lt; 1494172800 group by id) </p><p>select u1.id, pinfo.sid, u1.num, u2.total from u1, u2, pinfo where u2.id &#x3D; u1.id and pinfo.id &#x3D; u1.id;</p><p>窗口函数：<strong>窗口函数原则上只能写在select子句中</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;窗口函数&gt; over (partition by &lt;用于分组的列名&gt;</span><br><span class="line">                order by &lt;用于排序的列名&gt;)</span><br></pre></td></tr></table></figure><p>(1)专用窗口函数：rank, dense_rank, row_number</p><p><strong>例：select   row_number() over(partition by Uid  order by score) as A</strong></p><p>&#x2F;&#x2F;在原表的基础上再加一列，普通聚合函数只是查询出某列</p><p>(2)聚合函数：sum. avg, count, max, min</p><p><strong>例：select sum(salary) over( partition by Uid order by score ) as B</strong></p><p>​        <strong>salary&#x2F;sum(salary) over( ) as B</strong></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AI笔记（1）：基础知识</title>
      <link href="/2023/08/01/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86,%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
      <url>/2023/08/01/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86,%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<p><strong>基本名词</strong></p><ul><li><strong>示例&#x2F;样本</strong>：上面一条数据集中的一条数据。</li><li><strong>属性&#x2F;特征</strong>：「色泽」「根蒂」等。</li><li><strong>属性空间&#x2F;样本空间&#x2F;输入空间X</strong>：由全部属性张成的空间。</li><li><strong>特征向量</strong>：空间中每个点对应的一个坐标向量。</li><li><strong>标记</strong>：关于示例结果的信息，如（（色泽&#x3D;青绿，根蒂&#x3D;蜷缩，敲声&#x3D;浊响），好瓜），其中「好瓜」称为标记。</li><li><strong>分类</strong>：若要预测的是离散值，如「好瓜」，「坏瓜」，此类学习任务称为分类。</li><li><strong>假设</strong>：学得模型对应了关于数据的某种潜在规律。</li><li><strong>真相</strong>：潜在规律自身。</li><li><strong>学习过程</strong>：是为了找出或逼近真相。</li><li><strong>泛化能力</strong>：学得模型适用于新样本的能力。一般来说，训练样本越大，越有可能通过学习来获得具有强泛化能力的模型。</li></ul><p><strong>欠拟合(Underfitting)：</strong>常常在模型学习能力较弱，而数据复杂度较高的情况出现，此时模型由于学习能力不足，无法学习到数据集中的“一般规律”，因而导致泛化能力弱。</p><p><strong>过拟合(Overfitting)：</strong>模型学习能力太强，以至于将训练集单个样本自身的特点都能捕捉到，并将其认为是“一般规律”，同样这种情况也会导致模型泛化能力下降。</p><p><img src="https://img2018.cnblogs.com/blog/1503464/201903/1503464-20190305144802712-254685763.png" alt="img"></p><p><strong>偏差 (Bias)</strong> 和<strong>方差 (Variance)</strong> 是机器学习领域非常重要的两个概念和需要解决的问题。在传统的机器学习算法中，Bias和Variance是对立的，分别对应着欠拟合和过拟合.</p><p><strong>偏差(Bias)：</strong>度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法本身的拟合能力</p><p><strong>方差(Variance)：</strong>度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响。</p><p><strong>High Bias对应着欠拟合</strong>，而<strong>High Variance对应着过拟合</strong>。在欠拟合 (underfitting) 的情况下，出现高偏差 (High Bias) 的情况，即不能很好地对数据进行分类.</p><ul><li>训练集的错误率较小，而验证集的错误率却较大，说明模型存在较大方差 (Variance) ，可能出现了过拟合。</li><li>训练集和验证集的错误率都较大，且两者相当，说明模型存在较大偏差 (Bias) ，可能出现了欠拟合。</li><li>训练集错误率较大，且验证集的错误率远较训练集大，说明方差和偏差都较大，模型很差。</li><li>训练集和验证集的错误率都较小，且两者的相差也较小，说明方差和偏差都较小，这个模型效果比较好。</li></ul><p>模型存在<strong>高偏差</strong>：扩大网络规模，如添加隐藏层或隐藏单元数目；寻找合适的网络架构，使用更大的NN结构；花费更长时间训练。模型存在<strong>高方差</strong>：获取更多的数据；<strong>正则化 (Regularization)</strong> ；寻找更合适的网络结构。</p><p><strong>正则化:</strong> 若参数过多，模型过于复杂，则会容易造成过拟合（overfitting）。即模型在<strong>训练样本数据</strong>上表现的很好，但在<strong>实际测试样本</strong>上表现的较差，<strong>不具备良好的泛化能力</strong>。 为了避免过拟合，最常用的一种方法是使用正则化，例如 L1 和 L2 正则化。</p><p>Dropout:解决过拟合问题,我们在前向传播的时候，让某个神经元的激活值以一定的概率p停止工作，这样可以使模型泛化性更强，因为它不会太依赖某些局部的特征,如图：</p><img src="https://pic2.zhimg.com/80/v2-5530bdc5d49f9e261975521f8afd35e9_1440w.webp" alt="img" style="zoom:50%;"><h3 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h3><p>分类问题是机器学习非常重要的一个组成部分。它的目标是根据已知样本的某些特征，判断一个新的样本属于哪种已知的样本类。分类问题可以细分如下：</p><ul><li><strong>二分类问题</strong>：表示分类任务中有两个类别新的样本属于哪种已知的样本类。</li><li><strong>多类分类</strong>（Multiclass classification）问题：表示分类任务中有多类别。</li><li><strong>多标签分类</strong>（Multilabel classification）问题：给每个样本一系列的目标标签。</li></ul><p><strong>回归类问题</strong>：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/66cee18f94eed83c74b218db90c42757.png" alt="机器学习基础知识; 机器学习算法分类; 监督学习-分类与回归 ;"></p><p><strong>监督学习</strong>（<strong>Supervised Learning</strong>）：训练集有标记信息，学习方式有分类和回归。从给定的训练数据集中学习出一个函数，当新的数据到来时，可以根据这个函数预测结果。监督学习的训练集要求是包括输入和输出，也可以说是特征和目标。训练集中的目标是由人标注的。常见的监督学习算法包括回归分析和统计分类</p><p><strong>无监督学习</strong>（<strong>Unsupervised Learning</strong>）：训练集没有标记信息，学习方式有聚类和降维。与监督学习相比，训练集没有人为标注的结果。常见的无监督学习算法有生成对抗网络（GAN）、聚类。</p><p><strong>强化学习</strong>（<strong>Reinforcement Learning</strong>）：有延迟和稀疏的反馈标签的学习方式。通过观察来学习做成如何的动作。每个动作都会对环境有所影响，学习对象根据观察到的周围环境的反馈来做出判断。</p><p><strong>损失函数：</strong>用于量化衡量预测结果与真实值之间的差距，我们会通过优化损失函数来不断调整模型权重，使其最好地拟合样本数据。均方差损失(MSE)：</p><p><img src="https://www.zhihu.com/equation?tex=L(%5Chat%7By%7D,y)%20=%20%5Cfrac%7B1%7D%7B2%7D(%5Chat%7By%7D-y)%5E2" alt="公式"></p><p><strong>代价函数</strong>：是定义在整个训练集上的，是所有样本误差的平均，也就是损失函数的平均。＝成本函数</p><p><strong>成本函数</strong>：为全体训练样本上的表现，即 <img src="https://www.zhihu.com/equation?tex=m" alt="公式"> 个样本的损失函数的平均值，反映了 <img src="https://www.zhihu.com/equation?tex=m" alt="公式"> 个样本的预测输出与真实样本输出 <img src="https://www.zhihu.com/equation?tex=y" alt="公式"> 的平均接近程度</p><p><img src="https://www.zhihu.com/equation?tex=J(w,b)%20=%20%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi=1%7D%5EmL(%5Chat%7By%7D%5E%7B(i)%7D,y%5E%7B(i)%7D)" alt="公式"></p><p><strong>激活函数：</strong>是一种添加到人工神经网络中的函数，旨在帮助网络学习数据中的复杂模式。类似于人类大脑中基于神经元的模型，激活函数最终决定了要发射给下一个神经元的内容。</p><p><strong>训练集：</strong>用来训练模型内参数的数据集</p><p><strong>验证集:<strong>用于在训练过程中检验模型的状态，收敛情况。验证集通常</strong>用于调整超参数</strong>，根据几组模型验证集上的表现决定哪组超参数拥有最好的性能。同时验证集在训练过程中还可以用来监控模型<strong>是否发生过拟合</strong></p><p><strong>测试集：</strong>用来评价模型泛化能力，即之前模型使用验证集确定了超参数，使用训练集调整了参数，最后使用一个从没有见过的数据集来判断这个模型是否Work。</p><p>**交叉验证法:**交叉验证法的作用就是尝试利用不同的训练集&#x2F;测试集划分来对模型做多组不同的训练&#x2F;测试，来应对单词测试结果过于片面以及训练数据不足的问题。</p><p>交叉验证的做法就是将数据集粗略地分为比较均等不相交的k份，即</p><p><img src="https://pic2.zhimg.com/80/v2-b265503192f5de4842b16fec9564e58d_1440w.webp" alt="img"></p><p>然后取其中的一份进行测试，另外的k-1份进行训练，然后求得error的平均值作为最终的评价，具体算法流程西瓜书中的插图如下：</p><p><img src="https://pic2.zhimg.com/80/v2-93cc8f61173a74302c2f25df2bffc1f9_1440w.webp" alt="img"></p><p><strong>梯度下降：</strong>我们就要找到最优的 <img src="https://www.zhihu.com/equation?tex=w" alt="公式"> 和 <img src="https://www.zhihu.com/equation?tex=b" alt="公式"> 值，最小化 <img src="https://www.zhihu.com/equation?tex=m" alt="公式"> 个训练样本的Cost Function。这里用到的方法就叫做<strong>梯度下降</strong>(<strong>Gradient Descent</strong>)算法。</p><p>模型的训练目标是寻找合适的 <img src="https://www.zhihu.com/equation?tex=w" alt="公式"> 与 <img src="https://www.zhihu.com/equation?tex=b" alt="公式"> 以最小化代价函数值。我们先假设 <img src="https://www.zhihu.com/equation?tex=w" alt="公式"> 与 <img src="https://www.zhihu.com/equation?tex=b" alt="公式"> 都是一维实数，则代价函数 <img src="https://www.zhihu.com/equation?tex=J" alt="公式"> 关于 <img src="https://www.zhihu.com/equation?tex=w" alt="公式"> 与 <img src="https://www.zhihu.com/equation?tex=b" alt="公式"> 的图如下所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/34aa5f085eef1115e72c7d81d6920c3e.png" alt="梯度下降法"></p><p><strong>前向传播:</strong> 将上一层的输出作为下一层的输入，并计算下一层的输出，一直到运算到输出层为止。</p><p><img src="https://img2020.cnblogs.com/blog/1664108/202107/1664108-20210707205337747-841309468.png" alt="img"></p><p><strong>反向传播:<strong>反向传播是一种与最优化方法（如梯度下降法）结合使用的，该方法对网络中所有权重计算损失函数的</strong>梯度</strong>。根据微积分中的<em>链式规则</em>，按相反的顺序从输出层到输入层遍历网络。 这个梯度会反馈给最优化方法，用来更新权值以最小化损失函数。</p><p>步骤：求损失函数最小值 → 梯度下降法 → 求梯度 → 求偏导数</p><p>前向传播是为反向传播准备好要用到的数值，反向传播本质上是一种求梯度的高效方法。</p><p>TPTrue Positive，预测结果为正类，且与事实相符，即事实为正类。<br>TNTrue Negative，预测结果为负类，且与事实相符，即事实为负类。<br>FPFalse Positive，预测结果为正类，但与事实不符，即事实为负类。<br>FNFalse Negative，预测结果为负类，但与事实不符，即事实为正类。<br>有了结果分类，就可以计算指标了。常见有三个指标：准确率、精确率（查准率）、召回率（查全率）</p><ol><li><p>准确率<br>从上面的计算式可知，准确率的含义是模型猜对了的结果在全部结果中的占比，猜对的越多，得分就越高。</p></li><li><p>精确率（查准率）<br>分母说的是所有预测为正类的结果，分子说的是正类结果中猜对了的那部分。换句话说，模型预测对正类结果的预测越准确，查准率就越高。</p></li><li><p>召回率（查全率）<br>整个表达式的意思是，在全部正类中，看看模型能正确找出来多少，找出来的越多，查全率就越高。</p></li></ol><p><strong>机器学习工作流</strong>（WorkFlow）包含数据<strong>预处理</strong>（Processing）、<strong>模型学习</strong>（Learning）、<strong>模型评估</strong>（Evaluation）、<strong>新样本预测</strong>（Prediction）几个步骤。</p><ul><li><strong>数据预处理</strong>：输入（未处理的数据 + 标签）→处理过程（特征处理+幅度缩放、特征选择、维度约减、采样）→输出（测试集 + 训练集）。</li><li><strong>模型学习</strong>：模型选择、交叉验证、结果评估、超参选择。</li><li><strong>模型评估</strong>：了解模型对于数据集测试的得分。</li><li><strong>新样本预测</strong>：预测测试集。</li></ul><p><strong>梯度消失：</strong>经常出现，产生的原因有：一是在<strong>深层网络</strong>中，二是采用了<strong>不合适的损失函数</strong>，比如sigmoid。当梯度消失发生时，接近于输出层的隐藏层由于其梯度相对正常，所以权值更新时也就相对正常，但是当越靠近输入层时，由于梯度消失现象，会导致靠近输入层的隐藏层权值更新缓慢或者更新停滞。这就导致在训练时，只等价于后面几层的浅层网络的学习。</p><p><strong>梯度爆炸：</strong>一般出现在<strong>深层网络</strong>和<strong>权值初始化值太大</strong>的情况下。在深层神经网络或循环神经网络中，<strong>误差的梯度可在更新中累积相乘</strong>。如果网络层之间的<strong>梯度值大于 1.0</strong>，那么<strong>重复相乘会导致梯度呈指数级增长</strong>，梯度变的非常大，然后导致网络权重的大幅更新，并因此使网络变得不稳定。</p><p>如果接近输出层的激活函数求导后梯度值大于1，那么层数增多的时候，最终求出的梯度很容易指数级增长，就会产生<strong>梯度爆炸</strong>；相反，如果小于1，那么经过链式法则的连乘形式，也会很容易衰减至0，就会产生<strong>梯度消失</strong>。</p><p>梯度爆炸会伴随一些细微的信号，如：①模型不稳定，导致更新过程中的损失出现显著变化；②训练过程中，在极端情况下，权重的值变得非常大，以至于溢出，导致模型损失变成 NaN等等。</p><p><strong>神经网络相关知识</strong></p><p>神经网络：如果我们有一个𝑛 × 𝑛的图像，用𝑓 × 𝑓的过滤器做卷积，那么输出的维度就是(𝑛 − 𝑓 + 1) × (𝑛 − 𝑓 + 1)。       </p><p> 例：如果你用一个3×3 的过滤器卷积一个6×6 的图像，你最后会得到一个4×4 的输出，也就是一个4×4 矩阵。那是因为你的3×3 过滤器在6×6 矩阵中，只可能有4×4 种可能的位置           </p><img src="/2023/08/01/1/Users\12805\AppData\Roaming\Typora\typora-user-images\image-20230627155420750.png" alt="image-20230627155420750" style="zoom:67%;">                                   <p><strong>填充（padding）</strong>：前面可以发现，输入图像与卷积核进行卷积后的结果中损失了部分值，输入图像的边缘被“修剪”掉了（边缘处只检测了部分像素点，丢失了图片边界处的众多信息）。这是因为边缘上的像素永远不会位于卷积核中心，而卷积核也没法扩展到边缘区域以外。</p><p>这个结果我们是不能接受的，有时我们还希望输入和输出的大小应该保持一致。为解决这个问题，可以在进行卷积操作前，对原矩阵进行边界<strong>填充（Padding）</strong>，也就是在矩阵的边界上填充一些值，以增加矩阵的大小，通常都用“0”来进行填充的。<strong>即填充些没用的数据在外边，使得有用的数据处于中心。</strong></p><p><strong>（1）valid padding</strong>：不进行任何处理，只使用原始图像，不允许卷积核超出原始图像边界</p><p><strong>（2）same padding</strong>：进行填充，允许卷积核超出原始图像边界，并使得卷积后结果的大小与原来的一致</p><p><strong>迁移学习</strong>：<strong>神经网络可以从一个任务中习得知识，并将这些知识应用到另一个独立的任务中。</strong>例如，你训练好一个神经网络，能够识别像猫这样的对象，然后使用那些知识，或者部分习得的知识去帮助您更好地阅读x 射线扫描图，这就是所谓的迁移学习。</p><p><strong>CNN(卷积神经网络)</strong></p><p>CNN网络一共有5个层级结构：</p><ul><li><ul><li><strong>输入层</strong>(INPUT)</li><li><strong>卷积层</strong>(CONV)</li><li><strong>激活层</strong>(RELU)</li><li><strong>池化层</strong>(POOL)</li><li><strong>全连接层</strong> (FC层 输出层)</li></ul></li></ul><p><img src="https://handbook.pytorch.wiki/chapter2/resnet18.jpg" alt="img"></p><p>  <strong>输入层</strong>：输入数据，一般会并入卷积层。</p><p>  <strong>卷积层</strong>：如图，卷积层由两个结构组成，x * x * x的图像(三维或二维)和卷积核(滤波器，过滤器),在每一个卷积层中我们都会设置多个核，每个核代表着不同的特征，这些特征就是我们需要传递到下一层的输出，而我们训练的过程就是训练这些不同的核.</p><img src="https://img2020.cnblogs.com/blog/1226410/202007/1226410-20200731144538794-946475492.png" alt="img" style="zoom:50%;"><img src="https://upload-images.jianshu.io/upload_images/1845730-5ca69abe03f57d72.gif?imageMogr2/auto-orient/strip|imageView2/2/w/860/format/webp" style="zoom:50%;"><p>　<strong>激励层</strong>：所谓<strong>激励</strong>，实际上是对卷积层的输出结果做一次非线性映射。 如果不用激励函数（其实       就相当于激励函数是f(x)&#x3D;x），这种情况下，每一层的输出都是上一层输入的线性函数。容易得出，无论有多少神经网络层，输出都是输入的线性组合，与没有隐层的效果是一样的，这就是最原始的<strong>感知机</strong>了。<br>常用的激励函数有：</p><ul><li><ul><li><strong>Sigmoid函数</strong></li><li>Tanh函数</li><li>ReLU</li><li>Leaky ReLU</li><li>ELU</li><li>Maxout</li></ul></li></ul><p>　　激励层建议：首先ReLU，因为迭代速度快，但是有可能效果不加。如果ReLU失效的情况下，考虑使用Leaky ReLU或者Maxout，此时一般情况都可以解决。Tanh函数在文本和音频处理有比较好的效果。</p><p>   <strong>池化层</strong>：池化层夹在连续的卷积层中间， 用于压缩数据和参数的量，减小过拟合。主要用于特征降维，压缩数据和参数的数量，减小过拟合，同时提高模型的容错性。</p><p><img src="https://handbook.pytorch.wiki/chapter2/vgg16.png" alt="img"></p><p>　主要方式有：</p><ul><li><ul><li>Max Pooling：最大池化</li><li>Average Pooling：平均池化</li></ul></li></ul><p>　　Max Pooling：选取最大的，我们定义一个空间邻域（比如，2*2的窗口），并从窗口内的修正特征图中取出最大的元素，最大池化被证明效果更好一些。</p><p>　　Average Pooling：平均的，我们定义一个空间邻域（比如，2*2的窗口），并从窗口内的修正特征图中算出平均值。</p><p>  <strong>全连接层</strong>：经过前面若干次卷积+激励+池化后，终于来到了输出层，模型会将学到的一个高质量的特征图片全连接层。其实在全连接层之前，如果神经元数目过大，学习能力强，有可能出现过拟合。因此，可以引入dropout操作，来随机删除神经网络中的部分神经元，来解决此问题。还可以进行<strong>局部归一化</strong>（LRN）、数据增强等操作，来增加鲁棒性。    <img src="https://upload-images.jianshu.io/upload_images/1845730-cc2d9549416e6250.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/813/format/webp"></p><p>卷积神将网络的计算公式为：<strong>N&#x3D;(W-F+2P)&#x2F;S+1</strong><br>其中N：输出大小  W：输入大小  F：卷积核大小  P：填充值的大小  S：步长大小</p><p>例：P&#x3D;1, S&#x3D;2</p><p><img src="https://upload-images.jianshu.io/upload_images/1845730-5ca69abe03f57d72.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/860/format/webp" alt="img"></p><p><strong>白化：</strong>白化的目的就是降低输入的冗余性；更正式的说，我们希望通过白化过程使得学习算法的输入具有如下性质：(i)特征之间相关性较低；(ii)所有特征具有相同的方差。</p><p>PCA(主成分分析):是一种常见的数据分析方式，常用于高维数据的降维，可用于提取数据的主要特征分量。</p><p>循环神经网络（Recurrent Neural Network，RNN）：是一种用于处理序列数据的神经网络。相比一般的神经网络来说，他能够处理序列变化的数据。</p><p><strong>LSTM - 长短期记忆递归神经网络</strong>: 一种特殊的RNN，主要是为了解决长序列训练过程中的梯度消失和梯度爆炸问题。简单来说，就是相比普通的RNN，LSTM能够在更长的序列中有更好的表现。</p><img src="https://pic4.zhimg.com/80/v2-e4f9851cad426dfe4ab1c76209546827_1440w.webp" alt="img" style="zoom:50%;"><p>​                         <img src="https://pic2.zhimg.com/80/v2-556c74f0e025a47fea05dc0f76ea775d_1440w.webp" alt="img" style="zoom:50%;"></p><p>LSTM内部主要有三个阶段：</p><ol><li><p>忘记阶段。这个阶段主要是对上一个节点传进来的输入进行<strong>选择性</strong>忘记。简单来说就是会 “忘记不重要的，记住重要的”。</p></li><li><p>选择记忆阶段。这个阶段将这个阶段的输入有选择性地进行“记忆”。主要是会对输入 x^t进行选择记忆。哪些重要则着重记录下来，哪些不重要，则少记一些。当前的输入内容由前面计算得到的 z表示。而选择的门控信号则是由 z^i（i代表information）来进行控制。</p></li><li><p>这个阶段将决定哪些将会被当成当前状态的输出。主要是通过 z^o来进行控制的。并且还对上一阶段得到的 c^o进行了放缩（通过一个tanh激活函数进行变化）。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux</title>
      <link href="/2023/07/13/linux/"/>
      <url>/2023/07/13/linux/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h2 id="linux常见的分支"><a href="#linux常见的分支" class="headerlink" title="linux常见的分支"></a>linux常见的分支</h2><ul><li>实际上Linus Torvalds所创建的是linux内核，而linux内核至今只发行了几个版本，变化并不是很大。但围绕着linux内核，不同的开发商开发出了很多linux系统（在linux内核上加入一些应用软件），这些linux系统就称为linux的分支。</li></ul><p><img src="https://segmentfault.com/img/remote/1460000039073645" alt="在这里插入图片描述"></p><ul><li>linux有非常多的分支，常见的分支有CentOs,Ubuntu，RedHat等。</li></ul><p><img src="https://segmentfault.com/img/remote/1460000039073644" alt="在这里插入图片描述"></p><h2 id="linux系统的安装"><a href="#linux系统的安装" class="headerlink" title="linux系统的安装"></a>linux系统的安装</h2><ul><li>目前主要采用虚拟机安装，常见的虚拟机有vmware出品的vmware workstation、oracle 出品的virtual Box.但vmware的性能比virtual Box好一点。</li><li>具体的安装方式百度一下教程。</li><li>这里注意一下VMware的备份功能，合理使用可以提高效率。VMware的备份方式有两种：克隆和快照。</li><li>快照：又称还原点，就是保存在拍快照时候的系统的状态（包含了所有的内容），在后期的时候随时可以恢复。【侧重在于短期备份，需要频繁备份的时候可以使用快照，做快照的时候虚拟的操作系统一般处于开启状态】</li><li>克隆：就是复制的意思。【侧重长期备份，做克隆的时候是必须得关闭】</li></ul><h2 id="linux系统文件与目录"><a href="#linux系统文件与目录" class="headerlink" title="linux系统文件与目录"></a>linux系统文件与目录</h2><h3 id="1-linux中一切皆文件"><a href="#1-linux中一切皆文件" class="headerlink" title="1.linux中一切皆文件"></a>1.linux中一切皆文件</h3><ul><li>首先了解一下什么是文件，什么是文件夹。</li></ul><blockquote><ul><li>文件：一般都是一个独立的东西，可以通过一些特定的工具进行打开，并且其中不能在包含除了文字以外的东西。</li><li>文件夹：可以包含其他文件的东西。</li></ul></blockquote><ul><li>在linux中一切皆文件，linux本身也是一个基于文件形式表示的操作系统。所以在linux中的操作本质上就是对文件的操作。</li></ul><h3 id="2-linux的-目录结构"><a href="#2-linux的-目录结构" class="headerlink" title="2.linux的 目录结构"></a>2.linux的 目录结构</h3><p>#### 第一步</p><p><img src="https://segmentfault.com/img/remote/1460000039073643" alt="在这里插入图片描述"></p><h5 id="相对-绝对路径"><a href="#相对-绝对路径" class="headerlink" title="相对&#x2F;绝对路径"></a>相对&#x2F;绝对路径</h5><blockquote><p>linux的工作路径分为两种：相对路径和绝对路径。</p><ul><li>相对路径：‘相对’指的是相对于当前的工作路径。相对路径的写法：<code>./</code> 表示当前目录。<code>../</code> :表示上一级目录。例如由 &#x2F;usr&#x2F;share&#x2F;doc 要到 &#x2F;usr&#x2F;share&#x2F;man 底下时，可以写成： <code>cd ../man</code> 这就是相对路径的写法</li><li>绝对路径：从根目录<code>/</code>下找对应路径。<code>cd /home</code>：可以直接从任意目录到达home目录。</li></ul></blockquote><h5 id="对文件目录结构的分析"><a href="#对文件目录结构的分析" class="headerlink" title="对文件目录结构的分析"></a>对文件目录结构的分析</h5><p><img src="https://segmentfault.com/img/remote/1460000039073641" alt="在这里插入图片描述"><br><strong>上面蓝色的表示文件夹，白色的表示文件，绿色表示拥有所有权限，红色表示压缩包</strong>。</p><ol><li><strong>bin</strong> : 全称binary（二进制），该目录中存储的都是一些二进制文件，文件都是可以被运行的。</li><li>boot: 这里存放一些启动linux时使用的核心文件，包括一些连接文件以及镜像文件。</li><li><strong>dev</strong> :该目录中主要存放的是外接设备，例如盘，其他的光盘等。其中的外接设备不能直接被使用，需要挂载（类似Windows下的分配盘符）</li><li><strong>etc</strong>: 主要存储系统管理所需的一些配置文件。</li><li><strong>home</strong>: 表示“家”，存储除了root用户以外其他所有用户，类似于Windows下的user&#x2F;用户。在linux中，每个用户都有自己的家目录，一般该目录名以用户的账号命名。</li></ol><p><img src="https://segmentfault.com/img/remote/1460000039073642" alt="在这里插入图片描述"></p><p><img src="https://segmentfault.com/img/remote/1460000039073649" alt="在这里插入图片描述"></p><ol><li><strong>proc</strong> :全称process（进程），该目录存储linux运行时的进程。【这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</li></ol><p>】</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</span><br></pre></td></tr></table></figure><ol><li>lib ： 全称library(库)，存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</li><li>lost+found : 这个目录一般是空的，当系统非法关机后，会存放一些文件。</li><li>media ： linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下</li><li>mnt : 当外接设备要挂载时，挂载到此目录下。可以将光驱挂载在 &#x2F;mnt&#x2F; 上，然后进入该目录就可以查看光驱里的内容了</li><li>opt : 全称optional(可选的)，在系统中安装额外的软件（例如数据库）所摆放的位置。默认是空的。</li><li><strong>root</strong> ：该目录是root用户的家目录，拥有超级权限。</li><li><strong>run</strong> ： 该目录临时存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除</li><li>sbin : 全称super binary,存储系统管理员使用的二进制系统管理程序</li><li>srv : 存一些服务启动之后需要提取的数据。</li><li>sys : 这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</li><li><strong>tmp</strong> : 全称temporary（临时的），当系统运行时产生的临时文件会在这个目录下。</li><li><strong>usr</strong> : 全称unix shared resources(共享资源)， 存放的是用户的应用程序和文件。类似于Windows下的program files.</li></ol><p><img src="https://segmentfault.com/img/remote/1460000039073650" alt="在这里插入图片描述"></p><ol><li><strong>usr&#x2F;bin</strong> : 存放系统使用的文件程序。</li><li><strong>usr&#x2F;sbin</strong> :存放超级用户使用的比较高级的管理程序和系统守护程序</li><li><strong>usr&#x2F;src</strong> ：内核源代码默认放置位置。</li><li><strong>var</strong> : 存放程序&#x2F;系统的日志文件</li></ol><h5 id="其中重要的目录有如下几个（上面加粗的）"><a href="#其中重要的目录有如下几个（上面加粗的）" class="headerlink" title="其中重要的目录有如下几个（上面加粗的）"></a>其中重要的目录有如下几个（上面加粗的）</h5><p><img src="https://segmentfault.com/img/remote/1460000039073640" alt="在这里插入图片描述"></p><h2 id="linux的基本指令"><a href="#linux的基本指令" class="headerlink" title="linux的基本指令"></a>linux的基本指令</h2><h5 id="linux指令的格式："><a href="#linux指令的格式：" class="headerlink" title="linux指令的格式："></a>linux指令的格式：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ 指令主体(空格)[选项](空格)[操作对象]</span><br></pre></td></tr></table></figure><p><em>其中指令可以包含多个选项和空格</em></p><h5 id="linux基础指令"><a href="#linux基础指令" class="headerlink" title="linux基础指令"></a>linux基础指令</h5><h6 id="1-ls指令"><a href="#1-ls指令" class="headerlink" title="1. ls指令"></a>1. ls指令</h6><ol><li><code>ls</code> : 列出当前工作目录下的所有文件和文件夹名称</li><li><code>ls 路径</code> :列出指定路径下的所有文件和文件夹的名称。</li></ol><p><em>在home目录下直接访问dev目录下的所有文件，文件夹</em><br><img src="https://segmentfault.com/img/remote/1460000039073647" alt="在这里插入图片描述"></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>. `ls -l 路径` ：以详细列表的形式展示对应路径下的文件，文件夹。</span><br><span class="line"><span class="number">4</span>. `ls -la 路径` ： 显示所有文件，文件夹（包括隐藏文件，文件夹）</span><br></pre></td></tr></table></figure><p><img src="https://segmentfault.com/img/remote/1460000039073651" alt="在这里插入图片描述"></p><blockquote><ul><li>上述列表第一行字符表示文档类型，其中“-”表示类型为文件，“d”表示文档类型为文件夹。</li><li>在linux中隐藏文档以<code>.</code>开头</li></ul></blockquote><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>. `ls -lh 路径` ： 以可读性较高的形式显示 文件，文件夹</span><br></pre></td></tr></table></figure><p><img src="https://segmentfault.com/img/remote/1460000039073646" alt="在这里插入图片描述"></p><h6 id="2-pwd指令"><a href="#2-pwd指令" class="headerlink" title="2. pwd指令"></a>2. pwd指令</h6><p><code>pwd</code> :显示当前工作目录</p><h6 id="3-cd指令"><a href="#3-cd指令" class="headerlink" title="3. cd指令"></a>3. cd指令</h6><ol><li><code>cd 路径</code> : 切换当前工作目录到指定目录。</li><li><code>cd /</code> :切换到根目录</li><li><code>cd ~</code> :切换到当前用户的家目录</li><li><code>cd ..</code> : 返回上一级目录</li><li><code>cd</code> ：切换到当前用户的家目录</li></ol><p><img src="https://segmentfault.com/img/remote/1460000039073652" alt="在这里插入图片描述"></p><h6 id="4-mkdir指令"><a href="#4-mkdir指令" class="headerlink" title="4. mkdir指令"></a>4. mkdir指令</h6><ol><li><code>mkdir 文件夹名称</code> ：创建一个文件夹 （可以在前面加上文件夹的绝对路径）</li></ol><p><code>mkdir /usr/helloworld</code> :在usr目录里创建一个helloworld文件夹</p><ol><li><code>mkdir 文件夹1 文件夹2 文件夹3 ...</code> ： 一次性创建多个文件夹，中间用空格隔开。</li></ol><h6 id="5-touch-指令"><a href="#5-touch-指令" class="headerlink" title="5. touch 指令"></a>5. touch 指令</h6><ol><li><code>touch 文件名</code> ：创建文件</li><li><code>touch 文件名1 文件名2 文件名3 ...</code> : 一次性创建多个文件，中间用空格隔开。</li></ol><h6 id="6-cp指令"><a href="#6-cp指令" class="headerlink" title="6. cp指令"></a>6. cp指令</h6><ol><li><code>cp 文件路径 要复制到的路径</code> ： 复制文件到指定位置。</li></ol><p><img src="https://segmentfault.com/img/remote/1460000039073653" alt="在这里插入图片描述"><br><img src="https://segmentfault.com/img/remote/1460000039073654" alt="在这里插入图片描述"><br><em>注意这里是相对路径</em></p><p><em>注意：Linux在复制过程中是可以重新对新位置的文件进行重命名的，但是如果不是必须的需要，则建议保持前后名称一致。</em></p><ol><li><code>cp -r 文件夹路径 文件夹要去的路径</code> ：复制文件夹到指定位置。 <code>-r</code> 表示递归复制，否则复制失败</li></ol><h6 id="7-mv指令"><a href="#7-mv指令" class="headerlink" title="7. mv指令"></a>7. mv指令</h6><ul><li><code>mv 文件/文件夹路径 要去的路径</code> ： 移动（剪切）文件&#x2F;文件夹到指定位置 。</li><li><code>mv 文件/文件夹名 新的文件/文件夹名</code> ：对文件&#x2F;文件夹重命名</li></ul><p><img src="https://segmentfault.com/img/remote/1460000039073657" alt="在这里插入图片描述"></p><h6 id="8-rm-指令"><a href="#8-rm-指令" class="headerlink" title="8. rm 指令"></a>8. rm 指令</h6><ol><li><code>rm 文件</code> : 删除文件</li><li><code>rm -f 文件</code> :强制删除文件，不提示是否删除。<code>-f</code> 表示强制（force）</li><li><code>rm -r 文件夹</code> ：删除文件夹。<code>-r</code>表示递归</li><li><code>rm -rf 文件夹</code> ：删除文件夹，并且不需要进行删除确认询问。</li><li><code>rm -rf 文件1 文件2 文件3 ...</code> ：删除多个文件或文件夹</li></ol><h6 id="9-输出重定向"><a href="#9-输出重定向" class="headerlink" title="9. 输出重定向"></a>9. 输出重定向</h6><blockquote><ul><li>一般命令的输出都会显示在终端中，有些时候需要将一些命令的执行结果想要保存到文件中进行后续的分析&#x2F;统计，则这时候需要使用到的输出重定向技术。</li><li>重定向有覆盖输出和追加输出两种。</li></ul></blockquote><ol><li><code>执行的指令 &gt; 文件路径</code> ：覆盖输出，会覆盖掉原先的文件内容。</li><li><code>执行的指令 &gt;&gt; 文件路径</code> ： 追加输出，不会覆盖原始文件内容，会在原始内容末尾继续添加</li><li>如果在指定的路径中文件不存在，会自动新建一个。</li></ol><h6 id="10-cat指令"><a href="#10-cat指令" class="headerlink" title="10. cat指令"></a>10. cat指令</h6><ol><li>cat 文件路径 在指定路径打开一个文件。</li><li><code>cat 文件路径1 文件路径2 ... &gt; 文件路径x</code>： 文件文件路径1 文件路径2 …的内容全部转到文件路径x 【配合输出重定向使用】</li><li>只有cat时，录入数据后，按crtl+d返回</li></ol><h6 id="11-clear-ctrl-L指令"><a href="#11-clear-ctrl-L指令" class="headerlink" title="11. clear &#x2F; ctrl + L指令"></a>11. clear &#x2F; ctrl + L指令</h6><ul><li><code>clear</code> : 清除终端已经存在的命令和结果，不是真的清除，只是隐藏起来。</li><li>ctrl + L：功能同上</li></ul><h6 id="12-history-指令"><a href="#12-history-指令" class="headerlink" title="12 .history 指令"></a>12 .history 指令</h6><ul><li><code>history</code> :查看之前输过的历史指令</li></ul><h6 id="13-有关ctrl的快捷键操作"><a href="#13-有关ctrl的快捷键操作" class="headerlink" title="13.有关ctrl的快捷键操作"></a>13.有关ctrl的快捷键操作</h6><ul><li><code>ctrl+c</code> ：强制终止程序的执行</li><li><code>ctrl+z</code> ：常用于挂起一个进程</li><li><code>ctrl+d</code> : 一个特殊的二进制值，表示 EOF，作用相当于在终端中输入exit后回车；</li><li><code>ctrl +s</code>：中断控制台的输出</li><li><code>ctrl+q</code>：恢复控制台输出</li><li><code>ctrl+l</code> ：清屏</li></ul><h6 id="14-tra-gz文件的解压缩及相关操作"><a href="#14-tra-gz文件的解压缩及相关操作" class="headerlink" title="14. .tra.gz文件的解压缩及相关操作"></a>14. .tra.gz文件的解压缩及相关操作</h6><p>参考链接：Ubuntu 常用解压与压缩命令：<a href="https://link.segmentfault.com/?enc=3Jz9JxfzmbWZ33b9TxtWCw==.VhncQRsQtbRaZRlhuGHYFOy8R+P6PsLeOzjPp3qatuWfA09QBOqiAJkaen7Tr6wI4G4YhBIlGXHEBNny8j/mdg==">https://blog.csdn.net/songbinxu/article/details/80435665</a></p><blockquote><ul><li><code>tar -zxvf FileName.tar.gz</code> # 解压<ul><li><code>tar -zcvf FileName.tar.gz DirName</code> # 将DirName和其下所有文件（夹）压缩</li><li><code>tar -C DesDirName -zxvf FileName.tar.gz</code> # 解压到目标路径</li></ul></li></ul></blockquote><h6 id="n-shift-PgUp-PgDn"><a href="#n-shift-PgUp-PgDn" class="headerlink" title="n. shift + PgUp&#x2F;PgDn"></a>n. shift + PgUp&#x2F;PgDn</h6><ul><li><code>shift + PgUp</code> :向上翻页</li><li><code>shift + PgDn</code> :向下翻页</li></ul><h5 id="linux进阶指令"><a href="#linux进阶指令" class="headerlink" title="linux进阶指令"></a>linux进阶指令</h5><h6 id="1-df指令"><a href="#1-df指令" class="headerlink" title="1. df指令"></a>1. df指令</h6><ul><li><code>df -h</code> : 查看磁盘空间。<code>-h</code>表示以可读性较高的方式展示大小。</li></ul><p><img src="https://segmentfault.com/img/remote/1460000039073655" alt="在这里插入图片描述"></p><h6 id="2-free指令"><a href="#2-free指令" class="headerlink" title="2.free指令"></a>2.free指令</h6><ul><li><code>free -m</code> :查看内存使用情况。<code>-m</code>表示以mb为单位查看。</li></ul><p><img src="https://segmentfault.com/img/remote/1460000039073658" alt="在这里插入图片描述"></p><h6 id="3-head指令"><a href="#3-head指令" class="headerlink" title="3.head指令"></a>3.head指令</h6><ul><li><code>head -n</code> :查看一个文件的前n行，如果不指定n，则默认显示前十行。</li></ul><p>查看t.txt文件的前四行：<br><img src="https://segmentfault.com/img/remote/1460000039073656" alt="在这里插入图片描述"></p><h6 id="4-tail指令"><a href="#4-tail指令" class="headerlink" title="4.tail指令"></a>4.tail指令</h6><ul><li><code>tail -n 文件路径</code> ：查看文件的末n行，n 不指定则默认显示后十行。</li><li><code>tail -f 文件路径</code> ：一般用于查看系统的日志，查看文件的动态变化内容。</li></ul><h6 id="5-less指令"><a href="#5-less指令" class="headerlink" title="5.less指令"></a>5.less指令</h6><ul><li><code>less 文件路径</code> ：查看文件，以较少的内容进行输出。</li><li>退出使用<code>q</code>指令</li></ul><h6 id="6-wc指令"><a href="#6-wc指令" class="headerlink" title="6.wc指令"></a>6.wc指令</h6><ul><li><code>wc 文件路径</code> ：统计文件内容的行数，单词数，字节数。</li><li><code>wc -l 文件路径</code> :统计文件内容的行数。<code>-h</code>表示lines，行数。</li><li><code>wc -w 文件路径</code> :统计文件内容的单词数，依据空格来判断单词数量。<code>-w</code> 表示words，单词数。</li><li><code>wc -c 文件路径</code> ：统计文件的字节数。<code>-c</code>表示bytes,字节数。</li></ul><p><img src="https://segmentfault.com/img/remote/1460000039073660" alt="在这里插入图片描述"></p><h6 id="7-date指令"><a href="#7-date指令" class="headerlink" title="7.date指令"></a>7.date指令</h6><ul><li><code>date</code> : 显示当前的时间</li></ul><p><img src="https://segmentfault.com/img/remote/1460000039073661" alt="在这里插入图片描述"></p><ul><li><code>date +%F</code> 或者 <code>date &quot;+%Y-%m-%d&quot;</code></li></ul><p><img src="https://segmentfault.com/img/remote/1460000039073659" alt="在这里插入图片描述"></p><ul><li><code>date &quot;+%F %T&quot;</code> 或者 <code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code></li></ul><p><img src="https://segmentfault.com/img/remote/1460000039073664" alt="在这里插入图片描述"></p><ul><li><code>date -d &quot;-1 day&quot; &quot;+%Y-%m-%d %H:%M:%S&quot;</code> 获取之前或者之后的某个时间，其中的可选值：<code>+，-，day , month , year .</code></li></ul><p><img src="https://segmentfault.com/img/remote/1460000039073662" alt="在这里插入图片描述"></p><blockquote><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">F</span></span>：表示完整的年月日</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">%<span class="selector-tag">T</span></span>：表示完整的时分秒</span><br></pre></td></tr></table></figure><p>%Y：表示四位年份<br>%m：表示两位月份（带前导0）<br>%d：表示日期（带前导0）<br>%H：表示小时（带前导0）<br>%M：表示分钟（带前导0）<br>%S：表示秒数（带前导0）</p><h6 id="8-cal指令"><a href="#8-cal指令" class="headerlink" title="8.cal指令"></a>8.cal指令</h6><ul><li><code>cal</code> : 输出当前月份日历</li><li><code>cal -3</code> ：输出上+本+下三个月</li><li><code>cal -y 年份</code> ：输出某一年的日历。</li></ul><p><img src="https://segmentfault.com/img/remote/1460000039073668" alt="在这里插入图片描述"><br><img src="https://segmentfault.com/img/remote/1460000039073663" alt="在这里插入图片描述"></p><h6 id="9-管道指令"><a href="#9-管道指令" class="headerlink" title="9.管道指令"></a>9.管道指令</h6><ul><li>管道符 ：<code>|</code> 。它的作用一般是“过滤”，“特殊”，“扩展处理”。它不能单独使用，一般是结合一些指令使用，管道在其中起到辅助作用。管道顾名思义就是起到一个管道的作用，一个管道指令以管道符<code>|</code>为分界线，表示将管道符前边的指令输入管道，然后经过管道符后面的指令的处理然后输出。</li><li>作用1：过滤。</li></ul><p><code>ls / | gerp y</code> :通过管道查询出根目录下包含y的文档名称。<code>grep</code>指令表示过滤</p><p><img src="https://segmentfault.com/img/remote/1460000039073665" alt="在这里插入图片描述"></p><ul><li>作用2 ：特殊用法</li></ul><p><code>cat 文件路径 | less</code> ：通过管道的操作方法来实现less的等价效果。</p><ul><li>作用3：扩展处理</li></ul><p><code>ls /home/chenshuai | wc -l</code> : 统计用户目录下文档的个数<br><img src="https://segmentfault.com/img/remote/1460000039073670" alt="在这里插入图片描述"></p><h5 id="linux高级指令"><a href="#linux高级指令" class="headerlink" title="linux高级指令"></a>linux高级指令</h5><h6 id="1-hostname指令"><a href="#1-hostname指令" class="headerlink" title="1.hostname指令"></a>1.hostname指令</h6><ul><li><code>hostname</code> : 输出完整的主机名</li><li><code>hostname -f</code> 输出当前主机名中的FQDN（全限定域名）</li></ul><p><img src="https://segmentfault.com/img/remote/1460000039073667" alt="在这里插入图片描述"></p><h6 id="2-id指令"><a href="#2-id指令" class="headerlink" title="2.id指令"></a>2.id指令</h6><ul><li><p><code>id</code> :默认显示当前执行命令的用户的基本信息（基本信息&#x3D;用户id，用户组id，附加组id…）</p></li><li><pre><code>id 用户名<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ： 显示指定用户的基本信息。</span><br><span class="line"></span><br><span class="line">  ![在这里插入图片描述](https://segmentfault.com/img/remote/1460000039073666)</span><br><span class="line"></span><br><span class="line">###### 3.whoami 指令</span><br><span class="line"></span><br><span class="line">- `whoami` :显示当前登录的用户名，一般用于shell脚本，用于获取当前操作对象的用户名方便记录日志。</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://segmentfault.com/img/remote/1460000039073669)</span><br><span class="line"></span><br><span class="line">###### 4.ps -ef指令</span><br><span class="line"></span><br><span class="line">- ps -ef :查看服务器进程信息。-e 等价于“-A”表示列出全部的进程。-f 显示全部的列（显示全字段）</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://segmentfault.com/img/remote/1460000039073673)</span><br><span class="line">上图的含义：</span><br><span class="line"></span><br><span class="line">&gt; UID: 该进程执行的用户id</span><br><span class="line">&gt; PID：进程id</span><br><span class="line">&gt; PPID：该进程的父进程id，如果一个程序的父级进程找不到，该程序的的进程称为僵尸进程。</span><br><span class="line">&gt; C：cpu的占用率，其形式是百分数。</span><br><span class="line">&gt; TTY：终端设备，发起该进程的设备识别符号，如果显示“?”则表示该进程并不是由终端设备发起；</span><br><span class="line">&gt; TIME：进程的执行时间</span><br><span class="line">&gt; CMD：该进程的名称或者对应的路径；</span><br><span class="line"></span><br><span class="line">###### 5.top指令</span><br><span class="line"></span><br><span class="line">- `top` ：查看服务器的进程占的资源（`q`指令退出）</span><br><span class="line">- 对top指令结果的操作：</span><br><span class="line"></span><br><span class="line">M:将结果按内存从高到低进行降序排列</span><br><span class="line">P：表示将结果按照CPU使用率从高到低进行降序排列；</span><br><span class="line">1：当服务器拥有多个cpu的时候可以使用“1”快捷键来切换是否展示显示各个cpu的详细信息；</span><br><span class="line">![在这里插入图片描述](https://segmentfault.com/img/remote/1460000039073671)</span><br><span class="line"></span><br><span class="line">&gt; 表头含义：</span><br><span class="line">&gt; PID：进程id；</span><br><span class="line">&gt; USER：该进程对应的用户；</span><br><span class="line">&gt; PR：优先级；</span><br><span class="line">&gt; VIRT：虚拟内存；</span><br><span class="line">&gt; RES：常驻内存；</span><br><span class="line">&gt; SHR：共享内存；</span><br><span class="line"></span><br><span class="line">```abnf</span><br><span class="line">计算一个进程实际使用的内存 = 常驻内存（RES）- 共享内存（SHR）</span><br></pre></td></tr></table></figure></code></pre></li></ul><p>S：表示进程的状态status（sleeping，其中S表示睡眠，R表示运行）；<br>%CPU：表示CPU的占用百分比；<br>%MEM：表示内存的占用百分比；<br>TIME+：执行的时间；<br>COMMAND：进程的名称或者路径；</p><h6 id="6-du-sh-指令"><a href="#6-du-sh-指令" class="headerlink" title="6.du -sh 指令"></a>6.du -sh 指令</h6><ul><li><code>du -sh 文件路径</code> ：查看文件的真实大小</li></ul><p><img src="https://segmentfault.com/img/remote/1460000039073676" alt="在这里插入图片描述"></p><h6 id="7-find-指令"><a href="#7-find-指令" class="headerlink" title="7.find 指令"></a>7.find 指令</h6><ul><li><code>find 路径 -name *.conf</code> ：查询指定路径下以.conf结尾的文件。</li></ul><p><img src="https://segmentfault.com/img/remote/1460000039073672" alt="在这里插入图片描述"></p><h6 id="8-service指令"><a href="#8-service指令" class="headerlink" title="8.service指令"></a>8.service指令</h6><ul><li><code>service 服务名 start/stop/restart</code> ：控制一些软件的服务启动&#x2F;停止&#x2F;重启</li></ul><h6 id="9-kill指令"><a href="#9-kill指令" class="headerlink" title="9.kill指令"></a>9.kill指令</h6><ul><li><code>killall 进程名称</code>：杀死进程</li></ul><h6 id="10-ifconfig"><a href="#10-ifconfig" class="headerlink" title="10.ifconfig"></a>10.ifconfig</h6><ul><li><code>ifconfig</code> :获取网卡信息。</li></ul><p><img src="https://segmentfault.com/img/remote/1460000039073677" alt="在这里插入图片描述"><br>ens33表示Linux中的一个网卡，eth0是其名称。Lo（loop，本地回还网卡，其ip地址一般都是127.0.0.1）也是一个网卡名称。inet 就是网卡的ip地址.<br>详细分析<a href="https://link.segmentfault.com/?enc=7JTtpxKA34e5dhi1vBmigA==.ITUtWLa1Sye1YqVqSsPFfyY41wp4ILemIa8zs7TLDnDuejRWbnKj4+Ztifg3+nZY">https://man.linuxde.net/ifconfig</a></p><h6 id="11-reboot指令"><a href="#11-reboot指令" class="headerlink" title="11.reboot指令"></a>11.reboot指令</h6><ul><li><code>reboot</code> ：重启计算机</li><li><code>reboot -w</code> :模拟重启，但是不重启（只写关机与开机日志信息）</li></ul><h6 id="12-shutdown-指令"><a href="#12-shutdown-指令" class="headerlink" title="12.shutdown 指令"></a>12.shutdown 指令</h6><ul><li><code>shutdown -h now &quot;关机提示&quot;</code> 或者 <code>shutdown -h 12:00 &quot;关机提示&quot;</code> ：立即关机和指定时间关机</li></ul><h6 id="13-uptime-指令"><a href="#13-uptime-指令" class="headerlink" title="13.uptime 指令"></a>13.uptime 指令</h6><ul><li><code>uptime</code> ：输出计算机从开机到现在的运行时间</li></ul><h6 id="14-uname指令"><a href="#14-uname指令" class="headerlink" title="14.uname指令"></a>14.uname指令</h6><ul><li><code>uname</code> :获取操作系统的类型</li><li><code>uname -a</code> ：获取全部系统信息（类型，全部主机名，内核版本，发布时间，开源计划）</li></ul><h6 id="15-man指令"><a href="#15-man指令" class="headerlink" title="15.man指令"></a>15.man指令</h6><ul><li><code>man 指令</code>:查询指令的用法（英文描述）退出用<code>q</code>指令</li></ul><h6 id="16-防火墙指令"><a href="#16-防火墙指令" class="headerlink" title="16. 防火墙指令"></a>16. 防火墙指令</h6><blockquote><p>Linux原始的防火墙工具iptables比较繁琐，ubuntu默认提供了一个基于iptable之上的防火墙配置工具ufw，使管理iptables更简单。</p></blockquote><ul><li>查看防火墙当前状态：<code>sudo ufw status</code></li><li>开启防火墙：<code>sudo ufw enable</code></li><li>关闭防火墙：<code>sudo ufw disable</code></li><li>查看防火墙版本：<code>sudo ufw version</code></li><li>默认允许外部访问本机：<code>sudo ufw default allow</code></li><li>默认拒绝外部访问本机： sudo ufw default deny</li><li>允许外部访问端口33： <code>sudo ufw allow 53</code></li><li>拒绝外部访问端口33：<code> sudo ufw deny 53</code></li><li>允许某个IP地址访问本机所有端口：<code>sudo ufw allow from 192.168.0.1</code></li></ul><h6 id="17-ping命令"><a href="#17-ping命令" class="headerlink" title="17.ping命令"></a>17.ping命令</h6><blockquote><p>ping命令用来测试主机之间网络的连通性。执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p></blockquote><ul><li><code>ping 目的主机</code> ：测试与目的主机网络连接情况。</li></ul><h2 id="vim编辑器"><a href="#vim编辑器" class="headerlink" title="vim编辑器"></a>vim编辑器</h2><h5 id="1-简单了解vim"><a href="#1-简单了解vim" class="headerlink" title="1. 简单了解vim"></a>1. 简单了解vim</h5><ul><li><strong>vi</strong> 是Unix和linux系统下的最基本的文本编辑器，适用于linux的任何版本，类似于Windows下的记事本。<strong>vim</strong>是vi的升级版，是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</li></ul><h5 id="2-vim的三种模式"><a href="#2-vim的三种模式" class="headerlink" title="2. vim的三种模式"></a>2. vim的三种模式</h5><ul><li><p>vim中存在三种模式：命令模式，编辑模式，末行模式。</p><p>首先简单认识一下基本概念：</p></li></ul><blockquote><ul><li>命令模式：即用vim打开文件后默认的模式，在该模式下是不能对文件直接编辑的，但可以通过快捷键进行一些操作,常见的操作：删除行，复制行，移动光标，粘贴等。</li><li>编辑模式：在该模式下可以对文件的内容进行编辑。</li><li>末行模式：可以在末行输入命令来对文件进行操作，常见的操作：搜索，替换，保存，退出，撤销，高亮等。</li></ul></blockquote><ul><li>vim打开文件的方式</li></ul><p><code>vim 文件路径</code> ：打开指定文件。<br><code>vim 文件路径1 文件路径2 文件路径3</code> ： 打开多个文件</p><h5 id="3-命令模式的常用操作"><a href="#3-命令模式的常用操作" class="headerlink" title="3.命令模式的常用操作"></a>3.命令模式的常用操作</h5><ul><li>使用命令<code>vim 文件路径</code> 后第一个看到的模式就是命令模式</li><li>退出： 使用<code>:q+回车</code></li><li>操作1：光标移动</li></ul><blockquote><p>光标移动到行首：<code>^</code><br>光标移动到行尾：<code>$</code><br>光标移动到第一行：<code>gg</code><br>光标移动到最后一行：<code>G</code><br>向上翻屏：<code>PgUp</code><br>向下翻屏：<code>PgDn</code></p></blockquote><ul><li>操作2：复制操作</li></ul><blockquote><p>复制 ：先<code>ctrl +v</code>然后通过<code>↑↓←→</code>选择复制内容，最后用<code>y</code>复制<br>粘贴：<code>p</code></p></blockquote><ul><li>操作3：剪切，删除</li></ul><blockquote><ul><li>剪切&#x2F;删除光标所在行（删除之后下一行上移）：<code>dd</code> —-这里注意<code>dd</code>严格来说是剪切命令，如果剪切后不用<code>p</code>粘贴就是删除。</li><li>剪切&#x2F;删除光标所在行及以下指定的行 :<code>数字n dd</code></li></ul></blockquote><ul><li>操作4 ：撤销，恢复</li></ul><blockquote><p>撤销：<code>:u</code><br>恢复：<code>ctrl+r</code></p></blockquote><ul><li>操作5：光标的移动</li></ul><blockquote><p>光标的左右上下移动：<code>↑ ↓ ← →</code><br>光标移动到指定n行：<code>nG</code></p></blockquote><h5 id="4-末行模式的常用操作"><a href="#4-末行模式的常用操作" class="headerlink" title="4.末行模式的常用操作"></a>4.末行模式的常用操作</h5><ul><li>在命令模式下使用<code>:</code>或者<code>/</code>即可进入末行模式。</li><li>退出：按下<code>esc</code> 或者 连按两下<code>esc</code> 或者 删除末行全部输入字符（三种方式选择）</li><li>操作1：保存操作</li></ul><blockquote><p>保存文件 ：<code>:w</code><br>另存为 ：<code>:w 路径</code></p></blockquote><h5 id="5-编辑模式常用操作"><a href="#5-编辑模式常用操作" class="headerlink" title="5.编辑模式常用操作"></a>5.编辑模式常用操作</h5><ul><li>在命令模式下，使用命令<code>i</code>或者<code>a</code>进入</li><li>退出方式：按下<code>esc</code></li></ul><h5 id="6-三个模式之间的关系图"><a href="#6-三个模式之间的关系图" class="headerlink" title="6.三个模式之间的关系图"></a>6.三个模式之间的关系图</h5><p><img src="https://segmentfault.com/img/remote/1460000039073678" alt="在这里插入图片描述"></p><ul><li>关于命令模式向终端的一些退出方式说明</li></ul><blockquote><p><code>:q</code> ：未对文件做任何修改退出<br><code>:q!</code>：强制退出，不保存修改<br><code>:wq</code>：保存修改并退出<br><code>:wq!</code> ：保存修改并强制退出<br><code>:x</code> : 在文件没有修改的情况下，表示直接退出，在文件修改的情况下表示保存并退出；</p></blockquote><ul><li>注意1： <code>:x</code>与<code>:wq</code>的区别<br>如果文件没有被修改，但是使用wq进行退出的话，则文件的修改时间会被更新；但是如果文件没有被修改，使用x进行退出的话，则文件修改时间不会被更新的；主要是会混淆用户对文件的修改时间的认定。</li></ul><p>*注意2：<code>X</code>表示对文件加密，<code>x</code>表示文件的退出</p><h5 id="7-vim的异常退出"><a href="#7-vim的异常退出" class="headerlink" title="7.vim的异常退出"></a>7.vim的异常退出</h5><ul><li>当使用vim编辑文件时，如果没有正常的使用vim提供的退出方式（<code>:wq</code>）强制关闭终端时，就会产生异常退出，如下图。这时系统会建立file.swp这个缓存文件，这个文件中保存着没有<code>:wq</code>动作保存的信息。</li></ul><p><img src="https://segmentfault.com/img/remote/1460000039073674" alt="在这里插入图片描述"></p><ul><li>解决办法：删除file.swp文件。<code>rm -rf file.swp</code></li></ul><h2 id="apt软件管理包"><a href="#apt软件管理包" class="headerlink" title="apt软件管理包"></a>apt软件管理包</h2><h5 id="快速了解"><a href="#快速了解" class="headerlink" title="快速了解"></a>快速了解</h5><blockquote><ul><li>apt（Advanced Packaging Tool）是一个在 Debian 和 Ubuntu 中的 Shell 前端软件包管理器。</li><li>apt 命令提供了查找、安装、升级、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</li><li>apt 命令执行需要超级管理员权限(root)。</li></ul></blockquote><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><ul><li>语法： <code>apt [options] [command] [package ...]</code></li></ul><blockquote><ul><li>options：可选，选项包括 -h（帮助），-y（当安装过程提示选择全部为”yes”），-q（不显示安装的过程）等等。</li><li>command：要进行的操作。</li><li>package：安装的包名。</li></ul></blockquote><ul><li>安装软件：<code>sudo apt install &lt;package_name&gt;</code></li><li>删除软件包：<code>sudo apt remove &lt;package_name&gt;</code></li><li>清理不再使用的依赖和库文件 :<code> sudo apt autoremove</code></li><li>更新软件包：<code>sudo apt update &lt;package_name&gt;</code></li><li>移除软件包及配置文件: <code>sudo apt purge &lt;package_name&gt;</code></li><li>显示软件包具体信息,例如：版本号，安装大小，依赖关系等等：<code>sudo apt show &lt;package_name&gt;</code></li></ul><p><img src="https://segmentfault.com/img/remote/1460000039073675" alt="在这里插入图片描述"></p><ul><li>升级软件包：<code>sudo apt upgrade</code></li></ul><p><img src="https://segmentfault.com/img/remote/1460000039073679" alt="在这里插入图片描述"></p><p><a href="https://segmentfault.com/t/linux">linux</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/07/12/hello-world/"/>
      <url>/2023/07/12/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
